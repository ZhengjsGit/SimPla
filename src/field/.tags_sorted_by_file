!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
SIMPLA_FIELD_H	Field.h	8;"	d
FIELD_DENSE_H_	FieldDense.h	9;"	d
Field	FieldDense.h	/^    Field() : m_data_(nullptr) { }$/;"	f	class:simpla::Field
Field	FieldDense.h	/^    Field(mesh_type &m, std::string const &name = "")$/;"	f	class:simpla::Field
Field	FieldDense.h	/^    Field(mesh_type const &m)$/;"	f	class:simpla::Field
Field	FieldDense.h	/^    Field(std::shared_ptr<attribute_type> d) : m_data_(d) { }$/;"	f	class:simpla::Field
Field	FieldDense.h	/^    Field(this_type &&other) : m_data_(other.m_data_) { }$/;"	f	class:simpla::Field
Field	FieldDense.h	/^    Field(this_type const &other) : m_data_(other.m_data_) { }$/;"	f	class:simpla::Field
Field	FieldDense.h	/^class Field<TV, TMesh, std::integral_constant<int, IFORM>, Policies...>$/;"	c	namespace:simpla
accept	FieldDense.h	/^    void accept(Args &&...args) { data()->accept(std::forward<Args>(args)...); }$/;"	f	class:simpla::Field
add	FieldDense.h	/^    void add(id_type const &s, Other const &other)$/;"	f	class:simpla::Field
apply	FieldDense.h	/^    void apply(TOP const &op, this_type &f, Args &&... args)$/;"	f	class:simpla::Field
assign	FieldDense.h	/^    void assign(id_type const &s, Other const &other)$/;"	f	class:simpla::Field
attribute	FieldDense.h	/^    std::shared_ptr<const attribute_type> attribute() const { return m_data_; }$/;"	f	class:simpla::Field
attribute_type	FieldDense.h	/^    typedef typename mesh_type::template Attribute<value_type, iform> attribute_type;$/;"	t	class:simpla::Field
calculus_policy	FieldDense.h	/^    typedef typename this_type::calculus_policy calculus_policy;$/;"	t	class:simpla::Field
clear	FieldDense.h	/^    void clear() { data()->clear(); }$/;"	f	class:simpla::Field
data	FieldDense.h	/^    std::shared_ptr<attribute_type> data() { return m_data_; }$/;"	f	class:simpla::Field
data_set	FieldDense.h	/^    data_model::DataSet data_set() const { return attribute()->data_set(); }$/;"	f	class:simpla::Field
data_set	FieldDense.h	/^    data_model::DataSet data_set() { return data()->data_set(); }$/;"	f	class:simpla::Field
deploy	FieldDense.h	/^    void deploy() { data()->deploy(); }$/;"	f	class:simpla::Field
empty	FieldDense.h	/^    bool empty() { return m_data_ == nullptr || m_data_->empty(); }$/;"	f	class:simpla::Field
field_value_type	FieldDense.h	/^    typedef typename traits::field_value_type<this_type>::type field_value_type;$/;"	t	class:simpla::Field
gather	FieldDense.h	/^    field_value_type gather(Args &&...args) const$/;"	f	class:simpla::Field
id_type	FieldDense.h	/^    typedef typename mesh_type::id_type id_type;$/;"	t	class:simpla::Field
iform	FieldDense.h	/^    static constexpr int iform = IFORM;$/;"	m	class:simpla::Field
iform	FieldDense.h	/^struct iform<Field<TV, TM, TFORM, Others...> > : public TFORM$/;"	s	namespace:simpla::traits
interpolate_policy	FieldDense.h	/^    typedef typename this_type::interpolate_policy interpolate_policy;$/;"	t	class:simpla::Field
m_data_	FieldDense.h	/^    std::shared_ptr<attribute_type> m_data_;$/;"	m	class:simpla::Field
mesh	FieldDense.h	/^    mesh_type const &mesh() const { return attribute()->mesh(); }$/;"	f	class:simpla::Field
mesh_type	FieldDense.h	/^    typedef TMesh mesh_type;$/;"	t	class:simpla::Field
mesh_type	FieldDense.h	/^template<typename TV, typename TM, typename ...Others> struct mesh_type<Field<TV, TM, Others...> >$/;"	s	namespace:simpla::traits
operator ()	FieldDense.h	/^    field_value_type operator()(Args &&...args) const$/;"	f	class:simpla::Field
operator *=	FieldDense.h	/^    inline this_type &operator*=(Other const &other)$/;"	f	class:simpla::Field
operator +=	FieldDense.h	/^    inline this_type &operator+=(Other const &other)$/;"	f	class:simpla::Field
operator -=	FieldDense.h	/^    inline this_type &operator-=(Other const &other)$/;"	f	class:simpla::Field
operator /=	FieldDense.h	/^    inline this_type &operator\/=(Other const &other)$/;"	f	class:simpla::Field
operator =	FieldDense.h	/^    inline this_type &operator=(Other const &other)$/;"	f	class:simpla::Field
operator =	FieldDense.h	/^    inline this_type &operator=(this_type const &other)$/;"	f	class:simpla::Field
operator []	FieldDense.h	/^    value_type &operator[](id_type const &s) { return m_data_->at(s); }$/;"	f	class:simpla::Field
operator []	FieldDense.h	/^    value_type const &operator[](id_type const &s) const { return m_data_->at(s); }$/;"	f	class:simpla::Field
point_type	FieldDense.h	/^    typedef typename mesh_type::point_type point_type;$/;"	t	class:simpla::Field
range	FieldDense.h	/^    typename mesh_type::range_type range() const { return mesh().template range<iform>(); }$/;"	f	class:simpla::Field
reference	FieldDense.h	/^    void reference(this_type &other) { m_data_ = other.m_data_; }$/;"	f	class:simpla::Field
simpla	FieldDense.h	/^namespace simpla$/;"	n
swap	FieldDense.h	/^    void swap(this_type &other) { std::swap(m_data_, other.m_data_); }$/;"	f	class:simpla::Field
sync	FieldDense.h	/^    void sync() { data()->sync(); }$/;"	f	class:simpla::Field
this_type	FieldDense.h	/^    typedef Field<TV, TMesh, std::integral_constant<int, IFORM>, Policies...> this_type;$/;"	t	class:simpla::Field
traits	FieldDense.h	/^namespace traits$/;"	n	namespace:simpla
type	FieldDense.h	/^    typedef TM type;$/;"	t	struct:simpla::traits::mesh_type
type	FieldDense.h	/^    typedef TV type;$/;"	t	struct:simpla::traits::value_type
value_type	FieldDense.h	/^    typedef TV value_type;$/;"	t	class:simpla::Field
value_type	FieldDense.h	/^struct value_type<Field<TV, Policies...>>$/;"	s	namespace:simpla::traits
~Field	FieldDense.h	/^    virtual ~Field() { }$/;"	f	class:simpla::Field
COREFieldField_EXPRESSION_H_	FieldExpression.h	9;"	d
Field	FieldExpression.h	/^struct Field<AssignmentExpression<TOP, TL, TR> > : public AssignmentExpression<TOP, TL, TR>$/;"	s	namespace:simpla
Field	FieldExpression.h	/^struct Field<BooleanExpression<T...> > : Expression<T...>$/;"	s	namespace:simpla
Field	FieldExpression.h	/^struct Field<Expression<T...> > : public Expression<T...>$/;"	s	namespace:simpla
SP_DEF_BINOPField_NTUPLE	FieldExpression.h	135;"	d
SP_DEF_BINOPField_NTUPLE	FieldExpression.h	162;"	d
do_not_excute	FieldExpression.h	/^    void do_not_excute()$/;"	f	struct:simpla::Field
excute	FieldExpression.h	/^    void excute()$/;"	f	struct:simpla::Field
expression_type	FieldExpression.h	/^    typedef AssignmentExpression<TOP, TL, TR> expression_type;$/;"	t	struct:simpla::Field
field_value_type	FieldExpression.h	/^struct field_value_type<Field<BooleanExpression<TOP, T...> > >$/;"	s	namespace:simpla::traits
iform	FieldExpression.h	/^struct iform<Field<Expression<TAG, T0, T...> > > : public traits::iform<T0>::type$/;"	s	namespace:simpla::traits
simpla	FieldExpression.h	/^namespace simpla {$/;"	n
this_type	FieldExpression.h	/^    typedef Field<AssignmentExpression<TOP, TL, TR>> this_type;$/;"	t	struct:simpla::Field
this_type	FieldExpression.h	/^    typedef Field<Expression<T...> > this_type;$/;"	t	struct:simpla::Field
traits	FieldExpression.h	/^namespace traits$/;"	n	namespace:simpla
type	FieldExpression.h	/^    typedef bool type;$/;"	t	struct:simpla::traits::field_value_type
type	FieldExpression.h	/^    typedef bool type;$/;"	t	struct:simpla::traits::value_type
type	FieldExpression.h	/^    typedef result_of_t<TOP(typename value_type<T>::type ...)> type;$/;"	t	struct:simpla::traits::value_type
value_type	FieldExpression.h	/^    typedef traits::value_type_t<TL> value_type;$/;"	t	struct:simpla::Field
value_type	FieldExpression.h	/^struct value_type<Field<BooleanExpression<TOP, T...> > >$/;"	s	namespace:simpla::traits
value_type	FieldExpression.h	/^struct value_type<Field<Expression<TOP, T...> > >$/;"	s	namespace:simpla::traits
~Field	FieldExpression.h	/^    ~Field()$/;"	f	struct:simpla::Field
COREFieldField_FUNCTION_H_	FieldFunction.h	9;"	d
Field	FieldFunction.h	/^    Field(mesh_type const &m, TF const &fun, TBox const &box) :$/;"	f	class:simpla::Field
Field	FieldFunction.h	/^    Field(this_type const &other) :$/;"	f	class:simpla::Field
Field	FieldFunction.h	/^class Field<TV, TMesh, std::integral_constant<int, IFORM>, tags::function, TFun, TBox, Policies...>$/;"	c	namespace:simpla
at	FieldFunction.h	/^    value_type at(id_type const &s) const$/;"	f	class:simpla::Field
calculus_policy	FieldFunction.h	/^    typedef typename this_type::calculus_policy calculus_policy;$/;"	t	class:simpla::Field
create	FieldFunction.h	/^    static this_type create(mesh_type const &m, TFun const &fun)$/;"	f	class:simpla::Field
create_from_config	FieldFunction.h	/^    static this_type create_from_config(mesh_type const &m, TDict const &dict)$/;"	f	class:simpla::Field
field_value_type	FieldFunction.h	/^    typedef typename traits::field_value_type<this_type>::type field_value_type;$/;"	t	class:simpla::Field
id_type	FieldFunction.h	/^    typedef typename mesh_type::id_type id_type;$/;"	t	class:simpla::Field
iform	FieldFunction.h	/^    static constexpr int iform = IFORM;$/;"	m	class:simpla::Field
interpolate_policy	FieldFunction.h	/^    typedef typename this_type::interpolate_policy interpolate_policy;$/;"	t	class:simpla::Field
is_valid	FieldFunction.h	/^    bool is_valid() const { return (!!m_fun_); }$/;"	f	class:simpla::Field
m_define_domain_	FieldFunction.h	/^    spatial_domain_type m_define_domain_;$/;"	m	class:simpla::Field
m_fun_	FieldFunction.h	/^    TFun m_fun_;$/;"	m	class:simpla::Field
m_mesh_	FieldFunction.h	/^    mesh_type const &m_mesh_;$/;"	m	class:simpla::Field
m_mutex_	FieldFunction.h	/^    std::mutex m_mutex_;$/;"	m	class:simpla::Field
mesh_type	FieldFunction.h	/^    typedef TMesh mesh_type;$/;"	t	class:simpla::Field
ndims	FieldFunction.h	/^    static constexpr int ndims = mesh_type::ndims;$/;"	m	class:simpla::Field
operator ()	FieldFunction.h	/^    field_value_type operator()(point_type const &x) const$/;"	f	class:simpla::Field
operator []	FieldFunction.h	/^    value_type operator[](id_type const &s) const$/;"	f	class:simpla::Field
operator bool	FieldFunction.h	/^    operator bool() const { return !!m_fun_; }$/;"	f	class:simpla::Field
point_type	FieldFunction.h	/^    typedef typename mesh_type::point_type point_type;$/;"	t	class:simpla::Field
simpla	FieldFunction.h	/^namespace simpla$/;"	n
spatial_domain_type	FieldFunction.h	/^    typedef typename mesh_type::box_type spatial_domain_type;$/;"	t	class:simpla::Field
tags	FieldFunction.h	/^namespace tags { struct function; }$/;"	n	namespace:simpla
this_type	FieldFunction.h	/^    typedef Field<TV, mesh_type, std::integral_constant<int, IFORM>, tags::function, TFun, TBox, Policies...> this_type;$/;"	t	class:simpla::Field
value_type	FieldFunction.h	/^    typedef TV value_type;$/;"	t	class:simpla::Field
~Field	FieldFunction.h	/^    ~Field() { }$/;"	f	class:simpla::Field
COREFieldField_TRAITS_H_	FieldTraits.h	9;"	d
extent	FieldTraits.h	/^struct extent<Field<T ...>, M> : public std::integral_constant<int,$/;"	s	namespace:simpla::traits
field_value_type	FieldTraits.h	/^struct field_value_type$/;"	s	namespace:simpla::traits
isField	FieldTraits.h	/^struct isField : public std::integral_constant<bool, false>$/;"	s	namespace:simpla::traits
isField	FieldTraits.h	/^struct isField<Field<T...>> : public std::integral_constant<$/;"	s	namespace:simpla::traits
key_type	FieldTraits.h	/^struct key_type<Field<T ...> >$/;"	s	namespace:simpla::traits
reference	FieldTraits.h	/^struct reference<Field<TM, TV, Others...> >$/;"	s	namespace:simpla::traits
simpla	FieldTraits.h	/^namespace simpla$/;"	n
traits	FieldTraits.h	/^namespace traits$/;"	n	namespace:simpla
type	FieldTraits.h	/^            value_type_t<T>, nTuple<value_type_t<T>, 3> >::type type;$/;"	t	struct:simpla::traits::field_value_type
type	FieldTraits.h	/^    typedef Field<TM, TV, Others...> const &type;$/;"	t	struct:simpla::traits::reference
type	FieldTraits.h	/^    typedef size_t type;$/;"	t	struct:simpla::traits::key_type
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
CORE_FIELD_COMM_H_	obsoleted/field_comm.h	8;"	d
simpla	obsoleted/field_comm.h	/^namespace simpla$/;"	n
tags	obsoleted/field_comm.h	/^namespace tags$/;"	n	namespace:simpla
FIELD_CONSTANT_H_	obsoleted/field_constant.h	9;"	d
Field	obsoleted/field_constant.h	/^	Field(mesh_type const &m, value_type const &f)$/;"	f	class:simpla::Field
Field	obsoleted/field_constant.h	/^	Field(this_type const &other)$/;"	f	class:simpla::Field
Field	obsoleted/field_constant.h	/^class Field<TM, TV, _impl::this_is_constant>$/;"	c	namespace:simpla
_impl	obsoleted/field_constant.h	/^namespace _impl$/;"	n	namespace:simpla
coordinates_type	obsoleted/field_constant.h	/^	typedef typename mesh_type::coordinates_type coordinates_type;$/;"	t	class:simpla::Field
id_type	obsoleted/field_constant.h	/^	typedef typename mesh_type::id_type id_type;$/;"	t	class:simpla::Field
m_mesh_	obsoleted/field_constant.h	/^	mesh_type m_mesh_;$/;"	m	class:simpla::Field
m_value_	obsoleted/field_constant.h	/^	value_type m_value_;$/;"	m	class:simpla::Field
make_field_constant	obsoleted/field_constant.h	/^Field<TM, TV, _impl::this_is_constant> make_field_constant(TM const &m,$/;"	f	namespace:simpla
mesh_type	obsoleted/field_constant.h	/^	typedef TM mesh_type;$/;"	t	class:simpla::Field
operator ()	obsoleted/field_constant.h	/^	value_type operator()(coordinates_type const &x) const$/;"	f	class:simpla::Field
operator =	obsoleted/field_constant.h	/^	this_type &operator=(this_type const &other)$/;"	f	class:simpla::Field
simpla	obsoleted/field_constant.h	/^namespace simpla$/;"	n
swap	obsoleted/field_constant.h	/^	void swap(this_type &other)$/;"	f	class:simpla::Field
this_type	obsoleted/field_constant.h	/^	typedef Field<TM, TV, _impl::this_is_constant> this_type;$/;"	t	class:simpla::Field
value_type	obsoleted/field_constant.h	/^	typedef TV value_type;$/;"	t	class:simpla::Field
~Field	obsoleted/field_constant.h	/^	~Field()$/;"	f	class:simpla::Field
COREFieldField_CONSTRAINT_H_	obsoleted/field_constraint.h	9;"	d
simpla	obsoleted/field_constraint.h	/^namespace simpla$/;"	n
FieldAMRPolicy	obsoleted/field_patch.h	/^class FieldAMRPolicy : public mesh::EnablePatchFromThis<TF>$/;"	c	namespace:simpla
SIMPLA_FIELD_PATCH_H	obsoleted/field_patch.h	8;"	d
coarsen	obsoleted/field_patch.h	/^    virtual void coarsen(size_t id)$/;"	f	class:simpla::FieldAMRPolicy
erase_patch	obsoleted/field_patch.h	/^    virtual void erase_patch(size_t id)$/;"	f	class:simpla::FieldAMRPolicy
field_type	obsoleted/field_patch.h	/^    typedef TF field_type;$/;"	t	class:simpla::FieldAMRPolicy
iform	obsoleted/field_patch.h	/^    static constexpr int iform = field_type::iform;$/;"	m	class:simpla::FieldAMRPolicy
mesh_type	obsoleted/field_patch.h	/^    typedef typename field_type::mesh_type mesh_type;$/;"	t	class:simpla::FieldAMRPolicy
patch	obsoleted/field_patch.h	/^    field_type patch(size_t id) const$/;"	f	class:simpla::FieldAMRPolicy
patch	obsoleted/field_patch.h	/^    field_type patch(size_t id)$/;"	f	class:simpla::FieldAMRPolicy
refinement	obsoleted/field_patch.h	/^    virtual void refinement(size_t id)$/;"	f	class:simpla::FieldAMRPolicy
simpla	obsoleted/field_patch.h	/^namespace simpla$/;"	n
value_type	obsoleted/field_patch.h	/^    typedef typename field_type::value_type value_type;$/;"	t	class:simpla::FieldAMRPolicy
COREFieldField_SPARSE_H_	obsoleted/field_sparse.h	9;"	d
Field	obsoleted/field_sparse.h	/^	Field(mesh_type const & d, Args && ... args)$/;"	f	struct:simpla::Field
Field	obsoleted/field_sparse.h	/^	Field(this_type const & that)$/;"	f	struct:simpla::Field
Field	obsoleted/field_sparse.h	/^struct Field<TM, TV, _impl::is_associative_container> : public SpObject$/;"	s	namespace:simpla
clear	obsoleted/field_sparse.h	/^	void clear()$/;"	f	struct:simpla::Field
clone	obsoleted/field_sparse.h	/^	cloneField_type<TU> clone() const$/;"	f	struct:simpla::Field
container_type	obsoleted/field_sparse.h	/^	typedef std::map<id_type, value_type> container_type;$/;"	t	struct:simpla::Field
coordinate_tuple	obsoleted/field_sparse.h	/^	typedef typename mesh_type::coordinate_tuple coordinate_tuple;$/;"	t	struct:simpla::Field
empty	obsoleted/field_sparse.h	/^	bool empty() const$/;"	f	struct:simpla::Field
field_value_type	obsoleted/field_sparse.h	/^	typedef typename mesh_type::template field_value_type<value_type> field_value_type;$/;"	t	struct:simpla::Field
gather	obsoleted/field_sparse.h	/^	field_value_type gather(coordinate_tuple const& x) const$/;"	f	struct:simpla::Field
get_type_as_string	obsoleted/field_sparse.h	/^	std::string get_type_as_string() const$/;"	f	struct:simpla::Field
id_type	obsoleted/field_sparse.h	/^	typedef typename mesh_type::id_type id_type;$/;"	t	struct:simpla::Field
is_divisible	obsoleted/field_sparse.h	/^	bool is_divisible() const$/;"	f	struct:simpla::Field
m_dataset_	obsoleted/field_sparse.h	/^	container_type m_dataset_;$/;"	m	struct:simpla::Field
m_mesh_	obsoleted/field_sparse.h	/^	mesh_type m_mesh_;$/;"	m	struct:simpla::Field
mesh	obsoleted/field_sparse.h	/^	mesh_type const & mesh() const$/;"	f	struct:simpla::Field
mesh_type	obsoleted/field_sparse.h	/^	typedef TM mesh_type;$/;"	t	struct:simpla::Field
operator =	obsoleted/field_sparse.h	/^	inline Field<AssignmentExpression<_impl::_assign, this_type, TR>> operator =($/;"	f	struct:simpla::Field
operator =	obsoleted/field_sparse.h	/^	inline Field<AssignmentExpression<_impl::_assign, this_type, this_type>> operator =($/;"	f	struct:simpla::Field
operator []	obsoleted/field_sparse.h	/^	value_type & operator[](id_type const & s)$/;"	f	struct:simpla::Field
operator []	obsoleted/field_sparse.h	/^	value_type const & operator[](id_type const & s) const$/;"	f	struct:simpla::Field
pull_back	obsoleted/field_sparse.h	/^	template<typename TFun> void pull_back(TFun const &fun)$/;"	f	struct:simpla::Field
scatter	obsoleted/field_sparse.h	/^	void scatter(Args && ... args)$/;"	f	struct:simpla::Field
simpla	obsoleted/field_sparse.h	/^namespace simpla$/;"	n
this_type	obsoleted/field_sparse.h	/^	typedef Field<mesh_type, value_type, _impl::is_associative_container> this_type;$/;"	t	struct:simpla::Field
value_type	obsoleted/field_sparse.h	/^	typedef TV value_type;$/;"	t	struct:simpla::Field
~Field	obsoleted/field_sparse.h	/^	~Field()$/;"	f	struct:simpla::Field
COREField_LOADField_H_	obsoleted/load_field.h	9;"	d
loadField	obsoleted/load_field.h	/^bool loadField(TDict const & dict, TField *f)$/;"	f	namespace:simpla
simpla	obsoleted/load_field.h	/^namespace simpla$/;"	n
TypeParamList	test/field_basic_algebra_test.cpp	/^> TypeParamList;$/;"	t	file:
mesh	test/field_basic_algebra_test.cpp	/^        TestField<TF>::mesh = std::make_shared<typename TestField<TF>::mesh_type>();$/;"	m	class:TestField	file:
mesh_type	test/field_basic_algebra_test.cpp	/^typedef manifold::CartesianManifold mesh_type;$/;"	t	file:
FIELD_BASIC_ALGEBRA_TEST_H_	test/field_basic_algebra_test.h	9;"	d
SetUp	test/field_basic_algebra_test.h	/^    virtual void SetUp()$/;"	f	class:TestField
TYPED_TEST_P	test/field_basic_algebra_test.h	/^TYPED_TEST_P(TestField, assign)$/;"	f
TYPED_TEST_P	test/field_basic_algebra_test.h	/^TYPED_TEST_P(TestField, constant_real)$/;"	f
TYPED_TEST_P	test/field_basic_algebra_test.h	/^TYPED_TEST_P(TestField, index)$/;"	f
TYPED_TEST_P	test/field_basic_algebra_test.h	/^TYPED_TEST_P(TestField, scalarField)$/;"	f
TestField	test/field_basic_algebra_test.h	/^TYPED_TEST_CASE_P(TestField);$/;"	v
TestField	test/field_basic_algebra_test.h	/^class TestField : public testing::Test$/;"	c
default_value	test/field_basic_algebra_test.h	/^    value_type default_value;$/;"	m	class:TestField
field_type	test/field_basic_algebra_test.h	/^    typedef TField field_type;$/;"	t	class:TestField
iform	test/field_basic_algebra_test.h	/^    static constexpr int iform = traits::iform<TField>::value;$/;"	m	class:TestField
mesh	test/field_basic_algebra_test.h	/^    static std::shared_ptr<mesh_type> mesh;$/;"	m	class:TestField
mesh_type	test/field_basic_algebra_test.h	/^    typedef traits::manifold_type_t<field_type> mesh_type;$/;"	t	class:TestField
scalar_type	test/field_basic_algebra_test.h	/^    typedef Real scalar_type;$/;"	t	class:TestField
value_type	test/field_basic_algebra_test.h	/^    typedef traits::value_type_t<field_type> value_type;$/;"	t	class:TestField
CORE_FIELD_VECTOR_CALCULUS_TEST_H_	test/field_diff_calculus_test.h	9;"	d
FETLTest	test/field_diff_calculus_test.h	/^class FETLTest : public testing::TestWithParam<$/;"	c
K_imag	test/field_diff_calculus_test.h	/^    nTuple<scalar_type, 3> K_imag;$/;"	m	class:FETLTest
K_real	test/field_diff_calculus_test.h	/^    nTuple<Real, 3> K_real; \/\/ @NOTE must   k = n TWOPI, period condition$/;"	m	class:FETLTest
PhiAxis	test/field_diff_calculus_test.h	/^static constexpr const int PhiAxis = cs::PhiAxis;$/;"	v
RAxis	test/field_diff_calculus_test.h	/^static constexpr const int RAxis = cs::RAxis;$/;"	v
SetUp	test/field_diff_calculus_test.h	/^    void SetUp()$/;"	f	class:FETLTest
TEST_P	test/field_diff_calculus_test.h	/^TEST_P(FETLTest, curl1)$/;"	f
TEST_P	test/field_diff_calculus_test.h	/^TEST_P(FETLTest, curl2)$/;"	f
TEST_P	test/field_diff_calculus_test.h	/^TEST_P(FETLTest, diverge1)$/;"	f
TEST_P	test/field_diff_calculus_test.h	/^TEST_P(FETLTest, diverge2)$/;"	f
TEST_P	test/field_diff_calculus_test.h	/^TEST_P(FETLTest, grad0)$/;"	f
TEST_P	test/field_diff_calculus_test.h	/^TEST_P(FETLTest, grad3)$/;"	f
TEST_P	test/field_diff_calculus_test.h	/^TEST_P(FETLTest, identity_curl_grad_f0_eq_0)$/;"	f
TEST_P	test/field_diff_calculus_test.h	/^TEST_P(FETLTest, identity_curl_grad_f3_eq_0)$/;"	f
TEST_P	test/field_diff_calculus_test.h	/^TEST_P(FETLTest, identity_div_curl_f1_eq0)$/;"	f
TEST_P	test/field_diff_calculus_test.h	/^TEST_P(FETLTest, identity_div_curl_f2_eq0)$/;"	f
TearDown	test/field_diff_calculus_test.h	/^    void TearDown() { std::shared_ptr<mesh_type>(nullptr).swap(mesh); }$/;"	f	class:FETLTest
ZAxis	test/field_diff_calculus_test.h	/^static constexpr const int ZAxis = cs::ZAxis;$/;"	v
box	test/field_diff_calculus_test.h	/^    box_type box;$/;"	m	class:FETLTest
box_type	test/field_diff_calculus_test.h	/^    typedef typename mesh_type::box_type box_type;$/;"	t	class:FETLTest
cs	test/field_diff_calculus_test.h	/^typedef geometry::traits::coordinate_system_t<mesh_type> cs;$/;"	t
dims	test/field_diff_calculus_test.h	/^    nTuple<size_t, 3> dims;$/;"	m	class:FETLTest
error	test/field_diff_calculus_test.h	/^    Real error;$/;"	m	class:FETLTest
index_tuple	test/field_diff_calculus_test.h	/^    typedef typename mesh_type::index_tuple index_tuple;$/;"	t	class:FETLTest
mesh	test/field_diff_calculus_test.h	/^    std::shared_ptr<mesh_type> mesh;$/;"	m	class:FETLTest
mesh_type	test/field_diff_calculus_test.h	/^typedef manifold::CylindricalManifold mesh_type;$/;"	t
ndims	test/field_diff_calculus_test.h	/^    static constexpr size_t ndims = mesh_type::ndims;$/;"	m	class:FETLTest
one	test/field_diff_calculus_test.h	/^    value_type one;$/;"	m	class:FETLTest
point_type	test/field_diff_calculus_test.h	/^    typedef typename mesh_type::point_type point_type;$/;"	t	class:FETLTest
q	test/field_diff_calculus_test.h	/^    Real q(point_type const &x) const$/;"	f	class:FETLTest
scalar_type	test/field_diff_calculus_test.h	/^    typedef typename mesh_type::scalar_type scalar_type;$/;"	t	class:FETLTest
value_type	test/field_diff_calculus_test.h	/^    typedef Real value_type;$/;"	t	class:FETLTest
xmax	test/field_diff_calculus_test.h	/^    point_type xmin, xmax;$/;"	m	class:FETLTest
xmin	test/field_diff_calculus_test.h	/^    point_type xmin, xmax;$/;"	m	class:FETLTest
~FETLTest	test/field_diff_calculus_test.h	/^    virtual ~FETLTest()$/;"	f	class:FETLTest
FieldTest	test/field_dummy.cpp	/^class FieldTest: public testing::TestWithParam<TM>$/;"	c	file:
SetUp	test/field_dummy.cpp	/^	void SetUp()$/;"	f	class:FieldTest
TearDown	test/field_dummy.cpp	/^	void TearDown()$/;"	f	class:FieldTest
coordinate_tuple	test/field_dummy.cpp	/^	typedef typename mesh_type::coordinate_tuple coordinate_tuple;$/;"	t	class:FieldTest	file:
mesh	test/field_dummy.cpp	/^	mesh_type mesh;$/;"	m	class:FieldTest	file:
mesh_type	test/field_dummy.cpp	/^	typedef TM mesh_type;$/;"	t	class:FieldTest	file:
scalar_type	test/field_dummy.cpp	/^	typedef typename mesh_type::scalar_type scalar_type;$/;"	t	class:FieldTest	file:
value_type	test/field_dummy.cpp	/^	typedef TV value_type;$/;"	t	class:FieldTest	file:
~FieldTest	test/field_dummy.cpp	/^	virtual ~FieldTest()$/;"	f	class:FieldTest
main	test/field_io_test.cpp	/^int main(int argc, char **argv)$/;"	f
FIELD_IO_TEST_H_	test/field_io_test.h	9;"	d
PI	test/field_io_test.h	/^	static constexpr double PI = 3.141592653589793;$/;"	m	class:simpla::TestFieldIO
SetUp	test/field_io_test.h	/^	virtual void SetUp()$/;"	f	class:simpla::TestFieldIO
TYPED_TEST_P	test/field_io_test.h	/^TYPED_TEST_P(TestFieldIO, write)$/;"	f	namespace:simpla
TestFieldIO	test/field_io_test.h	/^class TestFieldIO : public testing::Test$/;"	c	namespace:simpla
coordinate_tuple	test/field_io_test.h	/^	typedef typename mesh_type::coordinate_tuple coordinate_tuple;$/;"	t	class:simpla::TestFieldIO
default_value	test/field_io_test.h	/^	value_type default_value;$/;"	m	class:simpla::TestFieldIO
iterator	test/field_io_test.h	/^	typedef typename mesh_type::iterator iterator;$/;"	t	class:simpla::TestFieldIO
k	test/field_io_test.h	/^	static constexpr nTuple<3, Real> k =$/;"	m	class:simpla::TestFieldIO
mesh	test/field_io_test.h	/^	mesh_type mesh;$/;"	m	class:simpla::TestFieldIO
mesh_type	test/field_io_test.h	/^	typedef typename TParam::mesh_type mesh_type;$/;"	t	class:simpla::TestFieldIO
simpla	test/field_io_test.h	/^namespace simpla$/;"	n
value_type	test/field_io_test.h	/^	typedef typename TParam::value_type value_type;$/;"	t	class:simpla::TestFieldIO
TMESH	test/trash/fetl_Cartesian_kz_test.cpp	13;"	d	file:
TMESH	test/trash/fetl_Cylindrical_kz_test.cpp	19;"	d	file:
TMESH	test/trash/fetl_Cylindrical_test.cpp	12;"	d	file:
FETL_TEST2_H_	test/trash/fetl_test2.h	9;"	d
SetUp	test/trash/fetl_test2.h	/^	virtual void SetUp()$/;"	f	class:TestField
TYPED_TEST_P	test/trash/fetl_test2.h	/^TYPED_TEST_P(TestField, vector_arithmetic)$/;"	f
TestField	test/trash/fetl_test2.h	/^TYPED_TEST_CASE_P(TestField);$/;"	v
TestField	test/trash/fetl_test2.h	/^class TestField: public testing::Test$/;"	c
default_value	test/trash/fetl_test2.h	/^	value_type default_value;$/;"	m	class:TestField
domain	test/trash/fetl_test2.h	/^	domain_type domain;$/;"	m	class:TestField
domain_type	test/trash/fetl_test2.h	/^	typedef typename TField::domain_type domain_type;$/;"	t	class:TestField
field_type	test/trash/fetl_test2.h	/^	typedef Field<domain_type, value_type> field_type;$/;"	t	class:TestField
make_field	test/trash/fetl_test2.h	/^	Field<domain_type, value_type> make_field() const$/;"	f	class:TestField
make_scalarField	test/trash/fetl_test2.h	/^	Field<domain_type, Real> make_scalarField() const$/;"	f	class:TestField
value_type	test/trash/fetl_test2.h	/^	typedef typename TField::value_type value_type;$/;"	t	class:TestField
FETL_TEST3_H_	test/trash/fetl_test3.h	9;"	d
K_imag	test/trash/fetl_test3.h	/^	nTuple<3, scalar_type> K_imag;$/;"	m	class:TestFETL
K_real	test/trash/fetl_test3.h	/^	nTuple<3, Real> K_real; \/\/ @NOTE must   k = n TWOPI, period condition$/;"	m	class:TestFETL
NDIMS	test/trash/fetl_test3.h	/^	static constexpr unsigned int NDIMS = mesh_type::NDIMS;$/;"	m	class:TestFETL
SetDefaultValue	test/trash/fetl_test3.h	/^	void SetDefaultValue(T* v)$/;"	f	class:TestFETL
SetDefaultValue	test/trash/fetl_test3.h	/^	void SetDefaultValue(nTuple<T, N>* v)$/;"	f	class:TestFETL
SetDefaultValue	test/trash/fetl_test3.h	/^	void SetDefaultValue(std::complex<T>* v)$/;"	f	class:TestFETL
SetUp	test/trash/fetl_test3.h	/^	void SetUp()$/;"	f	class:TestFETL
TEST_P	test/trash/fetl_test3.h	/^TEST_P(TestFETL, curl1)$/;"	f
TEST_P	test/trash/fetl_test3.h	/^TEST_P(TestFETL, curl2)$/;"	f
TEST_P	test/trash/fetl_test3.h	/^TEST_P(TestFETL, diverge1)$/;"	f
TEST_P	test/trash/fetl_test3.h	/^TEST_P(TestFETL, diverge2)$/;"	f
TEST_P	test/trash/fetl_test3.h	/^TEST_P(TestFETL, grad0)$/;"	f
TEST_P	test/trash/fetl_test3.h	/^TEST_P(TestFETL, grad3)$/;"	f
TEST_P	test/trash/fetl_test3.h	/^TEST_P(TestFETL, identity_curl_grad_f0_eq_0)$/;"	f
TEST_P	test/trash/fetl_test3.h	/^TEST_P(TestFETL, identity_curl_grad_f3_eq_0)$/;"	f
TEST_P	test/trash/fetl_test3.h	/^TEST_P(TestFETL, identity_div_curl_f1_eq0)$/;"	f
TEST_P	test/trash/fetl_test3.h	/^TEST_P(TestFETL, identity_div_curl_f2_eq0)$/;"	f
TManifold	test/trash/fetl_test3.h	/^		FiniteDiffMehtod, InterpolatorLinear> TManifold;$/;"	t
TestFETL	test/trash/fetl_test3.h	/^class TestFETL: public testing::TestWithParam<$/;"	c
coordinate_tuple	test/trash/fetl_test3.h	/^	typedef typename mesh_type::coordinate_tuple coordinate_tuple;$/;"	t	class:TestFETL
coordinate_tuple	test/trash/fetl_test3.h	/^typedef nTuple<3, Real> coordinate_tuple;$/;"	t
dims	test/trash/fetl_test3.h	/^	nTuple<NDIMS, size_t> dims;$/;"	m	class:TestFETL
iterator	test/trash/fetl_test3.h	/^	typedef typename mesh_type::iterator iterator;$/;"	t	class:TestFETL
manifold	test/trash/fetl_test3.h	/^	mesh_type manifold;$/;"	m	class:TestFETL
mesh_type	test/trash/fetl_test3.h	/^	typedef TManifold mesh_type;$/;"	t	class:TestFETL
one	test/trash/fetl_test3.h	/^	value_type one;$/;"	m	class:TestFETL
scalar_type	test/trash/fetl_test3.h	/^	typedef typename mesh_type::scalar_type scalar_type;$/;"	t	class:TestFETL
value_type	test/trash/fetl_test3.h	/^	typedef Real value_type;$/;"	t	class:TestFETL
xmax	test/trash/fetl_test3.h	/^	nTuple<NDIMS, Real> xmax;$/;"	m	class:TestFETL
xmin	test/trash/fetl_test3.h	/^	nTuple<NDIMS, Real> xmin;$/;"	m	class:TestFETL
~TestFETL	test/trash/fetl_test3.h	/^	virtual ~TestFETL()$/;"	f	class:TestFETL
FETL_TEST4_H_	test/trash/fetl_test4.h	9;"	d
TEST_P	test/trash/fetl_test4.h	/^TEST_P(TestFETL ,vec_zero_form)$/;"	f
TypeParamList	test/trash/field_basic_algebra_Cartesian_test.cpp	/^> TypeParamList;$/;"	t	file:
mesh_type	test/trash/field_basic_algebra_Cartesian_test.cpp	/^		FiniteDiffMethod, InterpolatorLinear> mesh_type;$/;"	t	file:
mesh	test/trash/field_basic_algebra_Cartesian_test.cpp	/^std::shared_ptr<typename TestField<TF>::mesh_type> TestField<TF>::mesh = \/\/$/;"	m	class:TestField	file:
TypeParamList	test/trash/field_basic_algebra_cylindrical_test.cpp	/^> TypeParamList;$/;"	t	file:
mesh_type	test/trash/field_basic_algebra_cylindrical_test.cpp	/^		FiniteDiffMethod, InterpolatorLinear> mesh_type;$/;"	t	file:
mesh	test/trash/field_basic_algebra_cylindrical_test.cpp	/^std::shared_ptr<typename TestField<TF>::mesh_type> TestField<TF>::mesh = \/\/$/;"	m	class:TestField	file:
COREField_TESTField_BASIC_TEST_H_	test/trash/field_basic_test.h	9;"	d
SetUp	test/trash/field_basic_test.h	/^	void SetUp()$/;"	f	class:TestField
TYPED_TEST_P	test/trash/field_basic_test.h	/^TYPED_TEST_P(TestField, assign){$/;"	f
TYPED_TEST_P	test/trash/field_basic_test.h	/^TYPED_TEST_P(TestField, constant_real){$/;"	f
TYPED_TEST_P	test/trash/field_basic_test.h	/^TYPED_TEST_P(TestField, index){$/;"	f
TYPED_TEST_P	test/trash/field_basic_test.h	/^TYPED_TEST_P(TestField, scalarField){$/;"	f
TestField	test/trash/field_basic_test.h	/^TYPED_TEST_CASE_P(TestField);$/;"	v
TestField	test/trash/field_basic_test.h	/^class TestField: public testing::Test$/;"	c
field_type	test/trash/field_basic_test.h	/^	typedef typename TFieldParam::field_type field_type;$/;"	t	class:TestField
mesh	test/trash/field_basic_test.h	/^	mesh_type mesh;$/;"	m	class:TestField
mesh_type	test/trash/field_basic_test.h	/^	typedef typename field_type::mesh_type mesh_type;$/;"	t	class:TestField
value_type	test/trash/field_basic_test.h	/^	typedef typename field_type::value_type value_type;$/;"	t	class:TestField
container_type	test/trash/field_cartesian_map_test.cpp	/^typedef std::unordered_map<typename mesh_type::id_type, double> container_type;$/;"	t	file:
f_type	test/trash/field_cartesian_map_test.cpp	/^typedef Field<mesh_type, container_type> f_type;$/;"	t	file:
geo	test/trash/field_cartesian_map_test.cpp	/^auto geo = CartesianCoordinate<RectMesh, CARTESIAN_ZAXIS>::create($/;"	v
mesh_type	test/trash/field_cartesian_map_test.cpp	/^		FiniteDiffMethod, InterpolatorLinear> mesh_type;$/;"	t	file:
COREFieldField_CONTINUE_H_	test/trash/field_continue.h	9;"	d
Field	test/trash/field_continue.h	/^	Field(mesh_type const & d, Args && ...args)$/;"	f	struct:simpla::Field
Field	test/trash/field_continue.h	/^	Field(this_type & that, Args && ...args)$/;"	f	struct:simpla::Field
Field	test/trash/field_continue.h	/^	Field(this_type const & that)$/;"	f	struct:simpla::Field
Field	test/trash/field_continue.h	/^struct Field<TM, TContainer, _impl::is_sequence_container> : public SpObject$/;"	s	namespace:simpla
allocate	test/trash/field_continue.h	/^	void allocate()$/;"	f	struct:simpla::Field
clear	test/trash/field_continue.h	/^	void clear()$/;"	f	struct:simpla::Field
clone	test/trash/field_continue.h	/^	cloneField_type<TU> clone() const$/;"	f	struct:simpla::Field
container_type	test/trash/field_continue.h	/^	typedef TContainer container_type;$/;"	t	struct:simpla::Field
coordinate_tuple	test/trash/field_continue.h	/^	typedef typename mesh_type::coordinate_tuple coordinate_tuple;$/;"	t	struct:simpla::Field
data_	test/trash/field_continue.h	/^	std::shared_ptr<container_type> data_;$/;"	m	struct:simpla::Field
empty	test/trash/field_continue.h	/^	bool empty() const$/;"	f	struct:simpla::Field
field_value_type	test/trash/field_continue.h	/^	typedef typename mesh_type::template field_value_type<value_type> field_value_type;$/;"	t	struct:simpla::Field
gather	test/trash/field_continue.h	/^	field_value_type gather(coordinate_tuple const& x) const$/;"	f	struct:simpla::Field
get_type_as_string	test/trash/field_continue.h	/^	std::string get_type_as_string() const$/;"	f	struct:simpla::Field
id_type	test/trash/field_continue.h	/^	typedef typename mesh_type::id_type id_type;$/;"	t	struct:simpla::Field
is_divisible	test/trash/field_continue.h	/^	bool is_divisible() const$/;"	f	struct:simpla::Field
mesh	test/trash/field_continue.h	/^	mesh_type const & mesh() const$/;"	f	struct:simpla::Field
mesh_	test/trash/field_continue.h	/^	mesh_type mesh_;$/;"	m	struct:simpla::Field
mesh_type	test/trash/field_continue.h	/^	typedef TM mesh_type;$/;"	t	struct:simpla::Field
operator =	test/trash/field_continue.h	/^	inline Field<AssignmentExpression<_impl::_assign, this_type, TR>> operator =($/;"	f	struct:simpla::Field
operator =	test/trash/field_continue.h	/^	inline Field<AssignmentExpression<_impl::_assign, this_type, this_type>> operator =($/;"	f	struct:simpla::Field
operator []	test/trash/field_continue.h	/^	value_type & operator[](id_type const & s)$/;"	f	struct:simpla::Field
operator []	test/trash/field_continue.h	/^	value_type const & operator[](id_type const & s) const$/;"	f	struct:simpla::Field
pull_back	test/trash/field_continue.h	/^	template<typename TFun> void pull_back(TFun const &fun)$/;"	f	struct:simpla::Field
scatter	test/trash/field_continue.h	/^	void scatter(Args && ... args)$/;"	f	struct:simpla::Field
simpla	test/trash/field_continue.h	/^namespace simpla$/;"	n
this_type	test/trash/field_continue.h	/^	typedef Field<mesh_type, container_type, _impl::is_sequence_container> this_type;$/;"	t	struct:simpla::Field
value_type	test/trash/field_continue.h	/^	typedef typename container_type::value_type value_type;$/;"	t	struct:simpla::Field
~Field	test/trash/field_continue.h	/^	~Field()$/;"	f	struct:simpla::Field
container_type	test/trash/field_simple_mesh_map_test.cpp	/^typedef std::unordered_map<typename SimpleMesh::id_type, double, hash_id> container_type;$/;"	t	file:
hash_id	test/trash/field_simple_mesh_map_test.cpp	/^struct hash_id$/;"	s	file:
mesh_type	test/trash/field_simple_mesh_map_test.cpp	/^typedef SimpleMesh mesh_type;$/;"	t	file:
operator ()	test/trash/field_simple_mesh_map_test.cpp	/^	size_t operator()(typename SimpleMesh::id_type const& s) const$/;"	f	struct:hash_id
TestFieldParam	test/trash/field_simple_mesh_shared_ptr_test.cpp	/^struct TestFieldParam$/;"	s	file:
TypeParamList	test/trash/field_simple_mesh_shared_ptr_test.cpp	/^> TypeParamList;$/;"	t	file:
field_type	test/trash/field_simple_mesh_shared_ptr_test.cpp	/^	typedef TField field_type;$/;"	t	struct:TestFieldParam	file:
field_type	test/trash/field_simple_mesh_shared_ptr_test.cpp	/^typedef Field<SimpleMesh, std::shared_ptr<double>> field_type;$/;"	t	file:
mesh	test/trash/field_simple_mesh_shared_ptr_test.cpp	/^	static SimpleMesh mesh;$/;"	m	struct:TestFieldParam	file:
mesh	test/trash/field_simple_mesh_shared_ptr_test.cpp	/^template<> SimpleMesh TestFieldParam<field_type, 0>::mesh = SimpleMesh();$/;"	m	class:TestFieldParam	file:
mesh	test/trash/field_simple_mesh_shared_ptr_test.cpp	/^template<> SimpleMesh TestFieldParam<field_type, 1>::mesh = SimpleMesh();$/;"	m	class:TestFieldParam	file:
vfield_type	test/trash/field_simple_mesh_shared_ptr_test.cpp	/^typedef Field<SimpleMesh, std::shared_ptr<nTuple<double, 3> > > vfield_type;$/;"	t	file:
m_type	test/trash/field_vector_calculus_Cartesian_complex_test.cpp	/^		FiniteDiffMethod, InterpolatorLinear> m_type;$/;"	t	file:
v_type	test/trash/field_vector_calculus_Cartesian_complex_test.cpp	/^typedef std::complex<Real> v_type;$/;"	t	file:
m_type	test/trash/field_vector_calculus_Cartesian_vec3_test.cpp	/^		FiniteDiffMethod, InterpolatorLinear> m_type;$/;"	t	file:
v_type	test/trash/field_vector_calculus_Cartesian_vec3_test.cpp	/^typedef nTuple<Real, 3> v_type;$/;"	t	file:
m_type	test/trash/field_vector_calculus_cylindrical_test.cpp	/^		FiniteDiffMethod, InterpolatorLinear> m_type;$/;"	t	file:
v_type	test/trash/field_vector_calculus_cylindrical_test.cpp	/^typedef Real v_type;$/;"	t	file:


!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
AMR	core/manifold/obsoleted/amr_policy.h	/^AMR::AMR()$/;"	f	class:simpla::manifold::policy::AMR
AMR	core/manifold/obsoleted/amr_policy.h	/^AMR<TM>::AMR() { }$/;"	f	class:simpla::manifold::policy::AMR
AMR	core/manifold/obsoleted/amr_policy.h	/^class AMR$/;"	c	namespace:simpla::manifold::policy
ANY_H_	core/gtl/any.h	9;"	d
ARRAY_ORDER	core/parallel/obsoleted/blocked_range.h	/^	static constexpr size_t ARRAY_ORDER = C_ORDER;$/;"	m	struct:simpla::iterator
ARRAY_ORDER	core/parallel/obsoleted/blocked_range.h	/^	static constexpr size_t ARRAY_ORDER=FOTRAN_ORDER;$/;"	m	struct:simpla::iterator
ASSERT	core/gtl/utilities/log.h	396;"	d
AUTHOR	core/gtl/utilities/logo.cpp	20;"	d	file:
A_	core/numeric/multi_normal_distribution.h	/^	nTuple<RealType, N, N> A_;$/;"	m	class:simpla::multi_normal_distribution
AbstractTracker	core/gtl/design_pattern/signal.h	/^    struct AbstractTracker$/;"	s	struct:simpla::Signal::Slot
AcceptorBase	core/gtl/design_pattern/visitor.h	/^struct AcceptorBase$/;"	s	namespace:simpla
ArrayOrder	core/gtl/primitives.h	/^enum ArrayOrder$/;"	g	namespace:simpla
ArrayView	core/gtl/array_view.h	/^    ArrayView(int ndims, size_t const *dims)$/;"	f	class:simpla::gtl::ArrayView
ArrayView	core/gtl/array_view.h	/^    ArrayView(this_type &other, tags::split)$/;"	f	class:simpla::gtl::ArrayView
ArrayView	core/gtl/array_view.h	/^    ArrayView(this_type &r, tags::proportional_split &proportion$/;"	f	class:simpla::gtl::ArrayView
ArrayView	core/gtl/array_view.h	/^class ArrayView : public ArrayViewBase$/;"	c	namespace:simpla::gtl
ArrayViewBase	core/gtl/array_view.h	/^    ArrayViewBase(this_type const &other) :$/;"	f	struct:simpla::gtl::ArrayViewBase
ArrayViewBase	core/gtl/array_view.h	/^struct ArrayViewBase$/;"	s	namespace:simpla::gtl
AssignmentExpression	core/gtl/expression_template.h	/^    AssignmentExpression(TL &l, TR const &r) :$/;"	f	struct:simpla::AssignmentExpression
AssignmentExpression	core/gtl/expression_template.h	/^    AssignmentExpression(TOP op, TL &l, TR const &r) :$/;"	f	struct:simpla::AssignmentExpression
AssignmentExpression	core/gtl/expression_template.h	/^    AssignmentExpression(this_type &&that) :$/;"	f	struct:simpla::AssignmentExpression
AssignmentExpression	core/gtl/expression_template.h	/^    AssignmentExpression(this_type const &that) :$/;"	f	struct:simpla::AssignmentExpression
AssignmentExpression	core/gtl/expression_template.h	/^struct AssignmentExpression<TOP, TL, TR>$/;"	s	namespace:simpla
Attribute	core/base/Attribute.h	/^    Attribute(mesh_type &m) : base_type(m), m_data_(nullptr) { }$/;"	f	class:simpla::base::Attribute
Attribute	core/base/Attribute.h	/^    Attribute(mesh_type const &m, Args &&...args) : base_type(m), m_data_(nullptr) { }$/;"	f	class:simpla::base::Attribute
Attribute	core/base/Attribute.h	/^class Attribute :$/;"	c	namespace:simpla::base
AttributeEntity	core/base/Attribute.h	/^    AttributeEntity(AttributeEntity &&other)$/;"	f	class:simpla::base::AttributeEntity
AttributeEntity	core/base/Attribute.h	/^    AttributeEntity(AttributeEntity const &other)$/;"	f	class:simpla::base::AttributeEntity
AttributeEntity	core/base/Attribute.h	/^    AttributeEntity(mesh_type &m) : m_mesh_(&m), m_const_mesh_(&m) { }$/;"	f	class:simpla::base::AttributeEntity
AttributeEntity	core/base/Attribute.h	/^    AttributeEntity(mesh_type const &m) : m_mesh_(nullptr), m_const_mesh_(&m) { }$/;"	f	class:simpla::base::AttributeEntity
AttributeEntity	core/base/Attribute.h	/^class AttributeEntity : public AttributeObject$/;"	c	namespace:simpla::base
AttributeEntity	core/manifold/Manifold.h	/^    typedef base::AttributeEntity<this_type> AttributeEntity;$/;"	t	class:simpla::Manifold
AttributeObject	core/base/Attribute.h	/^    AttributeObject() { }$/;"	f	class:simpla::base::AttributeObject
AttributeObject	core/base/Attribute.h	/^class AttributeObject : public DataObject$/;"	c	namespace:simpla::base
AutoIncrease	core/gtl/utilities/misc_utilities.h	/^inline std::string AutoIncrease(std::function<bool(std::string)> const & fun,$/;"	f	namespace:simpla
B	core/model/GEqdsk.h	/^    inline Vec3 B(Real R, Real Z) const$/;"	f	class:simpla::GEqdsk
B	core/model/GEqdsk.h	/^    inline Vec3 B(point_type const &x) const$/;"	f	class:simpla::GEqdsk
B	scripts/configure/demo2.lua	/^  B=function(x,y,z)$/;"	f
B	scripts/configure/demo_gfile.lua	/^  B=function(x,y,z)$/;"	f
B0	applications/contexts/explicit_em.h	/^    field<nTuple<Real, 3>, VERTEX> B0; \/\/!<background  equilibrium magnetic field J0+curl(B0)=0$/;"	m	struct:simpla::ExplicitEMContext
B0	core/model/GEqdsk.cpp	/^Real GEqdsk::B0() const { return m_pimpl_->m_bcenter_; }$/;"	f	class:simpla::GEqdsk
B0	core/particle/pre_define/PICBoris.h	/^    B_field B0;$/;"	m	struct:simpla::particle::engine::BorisEngine
B0	core/particle/pre_define/PICGyro.h	/^    B_field B0;$/;"	m	struct:simpla::particle::engine::GyroParticleWithCylindricalCoord
B0_type	applications/particle_solver/fluid_cold_engine.h	/^	typedef typename mesh_type:: template field<VERTEX, nTuple<Real, 3> > B0_type;$/;"	t	class:simpla::Particle
B0_type	applications/particle_solver/pic_engine_implicit.h	/^	typedef typename mesh_type:: template field<VERTEX, nTuple<3, Real> > B0_type;$/;"	t	struct:simpla::PICEngineImplicit
B1	applications/contexts/explicit_em.h	/^    field<scalar_type, FACE> B1, dB;$/;"	m	struct:simpla::ExplicitEMContext
B1	core/particle/pre_define/PICGyro.h	/^    B_field B1;$/;"	m	struct:simpla::particle::engine::GyroParticleWithCylindricalCoord
B1_type	applications/particle_solver/fluid_cold_engine.h	/^	typedef typename mesh_type:: template field<VERTEX, nTuple<scalar_type, 3>> B1_type;$/;"	t	class:simpla::Particle
B1_type	applications/particle_solver/pic_engine_implicit.h	/^	typedef typename mesh_type:: template field<VERTEX, nTuple<3, scalar_type>> B1_type;$/;"	t	struct:simpla::PICEngineImplicit
BAD_CAST	core/gtl/utilities/log.h	356;"	d
BB	applications/field_solver/implicitPushE.h	/^    field<Real, VERTEX> BB;$/;"	m	class:simpla::ImplicitPushE
BB	core/particle/pre_define/PICGyro.h	/^    scalar_field BB;$/;"	m	struct:simpla::particle::engine::GyroParticleWithCylindricalCoord
BC_ABSORB_H_	core/particle/obsolete/bc_absorb.h	9;"	d
BC_CYCLIC_H_	core/particle/obsolete/bc_cycle.h	9;"	d
BC_REFLECT_H_	core/particle/obsolete/bc_reflect.h	9;"	d
BOUNDARY	core/model/obsoleted/model.h	/^        BOUNDARY = 1UL << 4,$/;"	e	enum:simpla::Model::__anon9
B_field	core/particle/pre_define/PICBoris.h	/^    typedef traits::field_t<scalar_type, mesh_type, FACE> B_field;$/;"	t	struct:simpla::particle::engine::BorisEngine
B_field	core/particle/pre_define/PICGyro.h	/^    typedef traits::field_t<scalar_type, mesh_type, FACE> B_field;$/;"	t	struct:simpla::particle::engine::GyroParticleWithCylindricalCoord
B_type	applications/contexts/explicit_em.h	/^    typedef decltype(B1) B_type;$/;"	t	struct:simpla::ExplicitEMContext
Base	core/gtl/any.h	/^struct Base$/;"	s	namespace:simpla
BaseName	cpplint.py	/^  def BaseName(self):$/;"	m	class:FileInfo
BasePtr	core/gtl/any.h	/^    typedef std::unique_ptr<Base> BasePtr;$/;"	t	struct:simpla::any
Begin	cpplint.py	/^  def Begin(self, function_name):$/;"	m	class:_FunctionState
BiLinearInterpolation	core/numeric/interpolation.h	/^    BiLinearInterpolation()$/;"	f	class:simpla::BiLinearInterpolation
BiLinearInterpolation	core/numeric/interpolation.h	/^    BiLinearInterpolation(nTuple <size_t, NDIMS> dims,$/;"	f	class:simpla::BiLinearInterpolation
BiLinearInterpolation	core/numeric/interpolation.h	/^    BiLinearInterpolation(nTuple<size_t, NDIMS + 1> dims,$/;"	f	class:simpla::BiLinearInterpolation
BiLinearInterpolation	core/numeric/interpolation.h	/^class BiLinearInterpolation$/;"	c	namespace:simpla
Block	core/manifold/obsoleted/block.h	/^struct Block$/;"	s	namespace:simpla
BlockAttributeNames	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^    std::vector<std::string> BlockAttributeNames;$/;"	m	class:vtkAMRSimPlaReader::pimpl_s	file:
BlockCellDimensions	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^    int BlockCellDimensions[3];$/;"	m	class:vtkAMRSimPlaReaderBlock	file:
BlockFileName	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^    std::string BlockFileName;$/;"	m	class:vtkAMRSimPlaReaderBlock	file:
BlockNodeDimensions	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^    int BlockNodeDimensions[3];$/;"	m	class:vtkAMRSimPlaReaderBlock	file:
BlockRange	core/gtl/range/block_range.h	/^    BlockRange(BlockRange &r, tags::proportional_split &proportion) :$/;"	f	class:simpla::BlockRange
BlockRange	core/gtl/range/block_range.h	/^    BlockRange(BlockRange &r, tags::split) :$/;"	f	class:simpla::BlockRange
BlockRange	core/gtl/range/block_range.h	/^    BlockRange(const_iterator b, const_iterator e, size_type grain_size = 1)$/;"	f	class:simpla::BlockRange
BlockRange	core/gtl/range/block_range.h	/^class BlockRange<Iterator>$/;"	c	namespace:simpla
BlockedRange	core/parallel/obsoleted/blocked_range.h	/^	BlockedRange(BlockedRange<T> &r, split) :$/;"	f	struct:simpla::BlockedRange
BlockedRange	core/parallel/obsoleted/blocked_range.h	/^	BlockedRange(const const_iterator first, const const_iterator last,$/;"	f	struct:simpla::BlockedRange
BlockedRange	core/parallel/obsoleted/blocked_range.h	/^	BlockedRange(this_type const &other) :$/;"	f	struct:simpla::BlockedRange
BlockedRange	core/parallel/obsoleted/blocked_range.h	/^struct BlockedRange<T, 1>$/;"	s	namespace:simpla
Blocks	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^    std::vector<vtkAMRSimPlaReaderBlock> Blocks;$/;"	m	class:vtkAMRSimPlaReader::pimpl_s	file:
BooleanExpression	core/gtl/expression_template.h	/^class BooleanExpression<TOP, TL, TR> : public Expression<TOP, TL, TR>$/;"	c	namespace:simpla
BooleanExpression	core/gtl/expression_template.h	/^class BooleanExpression<TOP, TL> : public Expression<TOP, TL>$/;"	c	namespace:simpla
BorisEngine	core/particle/pre_define/PICBoris.h	/^    BorisEngine(mesh_type &m) : m_mesh_(m) { }$/;"	f	struct:simpla::particle::engine::BorisEngine
BorisEngine	core/particle/pre_define/PICBoris.h	/^struct BorisEngine$/;"	s	namespace:simpla::particle::engine
BorisPusher	core/particle/pre_define/PICBoris.h	/^inline void BorisPusher(Real cmr, Real dt, Vec3 const &B, Vec3 const &E,$/;"	f	namespace:simpla::particle::engine
BoundaryFileName	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^    std::string BoundaryFileName;$/;"	m	class:vtkAMRSimPlaReader::pimpl_s	file:
Box	core/geometry/box.h	/^struct Box$/;"	s	namespace:simpla::geometry::model
ByteType	core/gtl/primitives.h	/^typedef int8_t ByteType; \/\/ int8_t$/;"	t	namespace:simpla
CALCULATE_FVM_H_	core/manifold/policy/FvmStructuredPolicy.h	9;"	d
CALCULUS_H_	core/manifold/Calculus.h	9;"	d
CARTESIAN_XAXIS	core/gtl/primitives.h	/^static constexpr unsigned int CARTESIAN_XAXIS = 0;$/;"	m	namespace:simpla
CARTESIAN_YAXIS	core/gtl/primitives.h	/^static constexpr unsigned int CARTESIAN_YAXIS = 1;$/;"	m	namespace:simpla
CARTESIAN_ZAXIS	core/gtl/primitives.h	/^static constexpr unsigned int CARTESIAN_ZAXIS = 2;$/;"	m	namespace:simpla
CHANGE_INTERFACE	core/gtl/utilities/log.h	328;"	d
CHECK	core/gtl/utilities/log.h	402;"	d
CHECK_BIT	core/gtl/utilities/log.h	435;"	d
CHECK_BOOLEAN	core/gtl/check_concept.h	256;"	d
CHECK_BOOLEAN	core/gtl/concept_check.h	249;"	d
CHECK_HEX	core/gtl/utilities/log.h	438;"	d
CHECK_MEMBER_VALUE	core/gtl/check_concept.h	280;"	d
CHECK_MEMBER_VALUE	core/gtl/concept_check.h	273;"	d
CHOLESKY_H_	core/numeric/cholesky.h	9;"	d
CLIP	core/geometry/obsolete/line_cliping.h	/^	size_t CLIP = 2; \/* segment was clipped *\/$/;"	m	class:simpla::polygon_clip
CMD	core/gtl/utilities/log.h	424;"	d
COLLECTION_TEMPORAL	core/io/XDMFStream.h	/^        UNIFORM = 0, COLLECTION_TEMPORAL = 1, TREE = 2$/;"	e	enum:simpla::io::XDMFStream::__anon7
COMPLEX_OPS_H_	core/gtl/complex.h	9;"	d
COMPLEX_OPS_H_	core/gtl/sp_complex.h	9;"	d
CONATINER_DENSE_H_	core/gtl/containers/container_dense.h	9;"	d
CONSTANTS	core/physics/PhysicalConstants.h	110;"	d
CONSTANT_H_	core/physics/Constants.h	9;"	d
CONTAINER_CACHE_H_	core/gtl/containers/container_cache.h	9;"	d
CONTAINER_CONTAINER_H_	core/gtl/containers/container_container.h	9;"	d
CONTAINER_POOL_H_	core/gtl/containers/container_pool.h	9;"	d
CONTAINER_SAVE_CACHE_H_	core/gtl/containers/container_save_cache.h	9;"	d
CONTAINER_SPARSE_H_	core/gtl/containers/container_sparse.h	9;"	d
CONTAINER_TRAITS_H_	core/gtl/containers/container_traits.h	9;"	d
CONTEXT_BASE_H_	core/task_flow/context_base.h	9;"	d
CONTINUE	core/gtl/utilities/parse_command_line.h	/^	CONTINUE = 0, TERMINATE = 1$/;"	e	enum:simpla::__anon11
COORDINATES_MESH_FACTOR	core/manifold/mesh/MeshIds.h	/^    static constexpr Real COORDINATES_MESH_FACTOR = static_cast<Real>(1UL << MESH_RESOLUTION);$/;"	m	struct:simpla::mesh::MeshEntityIdCoder
COORDINATE_SYSTEM	example/em/demo_em.cpp	34;"	d	file:
COPYRIGHT	core/gtl/utilities/logo.cpp	23;"	d	file:
CORE	core/model/obsoleted/model.h	/^        CORE = 1UL << 3,$/;"	e	enum:simpla::Model::__anon9
COREFieldField_CONSTRAINT_H_	core/field/obsoleted/field_constraint.h	9;"	d
COREFieldField_CONTINUE_H_	core/field/test/trash/field_continue.h	9;"	d
COREFieldField_EXPRESSION_H_	core/field/FieldExpression.h	9;"	d
COREFieldField_FUNCTION_H_	core/field/FieldFunction.h	9;"	d
COREFieldField_SPARSE_H_	core/field/obsoleted/field_sparse.h	9;"	d
COREFieldField_TRAITS_H_	core/field/FieldTraits.h	9;"	d
COREField_LOADField_H_	core/field/obsoleted/load_field.h	9;"	d
COREField_TESTField_BASIC_TEST_H_	core/field/test/trash/field_basic_test.h	9;"	d
CORE_APPLICATION_APPLICATION_H_	core/task_flow/application.h	9;"	d
CORE_APPLICATION_CONTEXT_H_	core/task_flow/context.h	9;"	d
CORE_APPLICATION_TASK_H_	core/task_flow/task.h	9;"	d
CORE_APPLICATION_USE_CASE_H_	core/task_flow/use_case.h	9;"	d
CORE_CONTAINERS_CONTAINER_H_	core/gtl/containers/container.h	9;"	d
CORE_CONTAINERS_SP_ITERATOR_SEQUENCE_H_	core/gtl/iterator/iterator_sequence.h	9;"	d
CORE_CONTAINERS_SP_RANGE_FILTER_H_	core/gtl/iterator/sp_range_filter.h	9;"	d
CORE_DATASET_DATASET_H_	core/data_model/DataSet.h	9;"	d
CORE_DATASET_DATASPACE_H_	core/data_model/DataSpace.h	9;"	d
CORE_DATASET_DATATYPE_EXT_H_	core/data_model/DataTypeExt.h	9;"	d
CORE_DATA_STRUCTURE_ITERATOR_CYCLE_H_	core/gtl/iterator/iterator_cycle.h	9;"	d
CORE_DESIGN_PATTERN_DESIGN_PATTERN_H_	core/gtl/design_pattern/design_pattern.h	9;"	d
CORE_FIELD_COMM_H_	core/field/obsoleted/field_comm.h	8;"	d
CORE_FIELD_VECTOR_CALCULUS_TEST_H_	core/field/test/field_diff_calculus_test.h	9;"	d
CORE_GEOMETRY_ALGORITHM_H_	core/geometry/algorithm.h	9;"	d
CORE_GEOMETRY_BOOST_GEOMETRY_ADAPTED_H_	core/geometry/boost_gemetry_adapted.h	9;"	d
CORE_GEOMETRY_BOX_H_	core/geometry/box.h	9;"	d
CORE_GEOMETRY_CHAINS_H_	core/geometry/chains.h	9;"	d
CORE_GEOMETRY_COORDINATE_SYSTEM_H_	core/geometry/CoordinateSystem.h	9;"	d
CORE_GEOMETRY_CS_CARTESIAN_H_	core/geometry/csCartesian.h	9;"	d
CORE_GEOMETRY_CS_CYLINDRICAL_H_	core/geometry/csCylindrical.h	9;"	d
CORE_GEOMETRY_CUBE_H_	core/geometry/cube.h	9;"	d
CORE_GEOMETRY_CUT_CELL_H_	core/geometry/cut_cell.h	9;"	d
CORE_GEOMETRY_GEOMETRY_H_	core/geometry/geometry.h	9;"	d
CORE_GEOMETRY_GEOMETRY_OBJECT_H_	core/geometry/obsolete/geometry_object.h	9;"	d
CORE_GEOMETRY_GEO_OBJECT_H_	core/geometry/GeoObject.h	9;"	d
CORE_GEOMETRY_IMPLICIT_FUNCTION_H_	core/geometry/implicit_function.h	9;"	d
CORE_GEOMETRY_MODEL_H_	core/geometry/model.h	9;"	d
CORE_GEOMETRY_POLYGON_H_	core/geometry/obsolete/polygon.h	9;"	d
CORE_GEOMETRY_PRIMITIVE_EXT_H_	core/geometry/primitive_ext.h	9;"	d
CORE_GEOMETRY_PRIMITIVE_H_	core/geometry/primitive.h	9;"	d
CORE_GEOMETRY_SELECT_H_	core/geometry/select.h	9;"	d
CORE_GEOMETRY_SIMPLEX_H_	core/geometry/simplex.h	9;"	d
CORE_GPTL_CONCEPT_CHECK_H_	core/gtl/check_concept.h	9;"	d
CORE_GPTL_CONCEPT_CHECK_H_	core/gtl/concept_check.h	9;"	d
CORE_GTL_CACHE_H_	core/gtl/cache.h	9;"	d
CORE_GTL_CONTAINERS_SP_HASH_CONTAINER_H_	core/gtl/containers/sp_hash_container.h	9;"	d
CORE_GTL_CONTAINERS_SP_INDIRECT_CONTAINER_H_	core/gtl/containers/sp_indirect_container.h	9;"	d
CORE_GTL_CONTAINERS_SP_NDARRAY_H_	core/gtl/containers/sp_ndarray.h	9;"	d
CORE_GTL_CONTAINER_SORTED_SET_H_	core/gtl/containers/unordered_set.h	9;"	d
CORE_GTL_ENABLE_CREATE_FROM_THIS_H_	core/gtl/enable_create_from_this.h	9;"	d
CORE_GTL_FUNCTION_CACHE_H_	core/gtl/function_cache.h	9;"	d
CORE_GTL_GTL_H_	core/gtl/gtl.h	9;"	d
CORE_GTL_INTEGER_SEQUENCE_H_	core/gtl/integer_sequence.h	9;"	d
CORE_GTL_ITERATOR_INDIRECT_ITERATOR_H_	core/gtl/iterator/indirect_iterator.h	9;"	d
CORE_GTL_ITERATOR_SP_INDIRECT_ITERATOR_H_	core/gtl/iterator/sp_indirect_iterator.h	9;"	d
CORE_GTL_ITERATOR_SP_ITERATOR_CYCLE_H_	core/gtl/iterator/sp_iterator_cycle.h	9;"	d
CORE_GTL_ITERATOR_SP_ITERATOR_H_	core/gtl/iterator/sp_iterator.h	9;"	d
CORE_GTL_ITERATOR_SP_NTUPLE_RANGE_H_	core/gtl/iterator/sp_ntuple_range.h	9;"	d
CORE_GTL_MACRO_H_	core/gtl/macro.h	9;"	d
CORE_GTL_MPL_H_	core/gtl/mpl.h	9;"	d
CORE_GTL_NTUPLE_EXT_H_	core/gtl/ntuple_ext.h	9;"	d
CORE_GTL_NTUPLE_H_	core/gtl/ntuple.h	11;"	d
CORE_GTL_OPTIONAL_H_	core/gtl/optional.h	9;"	d
CORE_GTL_TYPE_CAST_H_	core/gtl/type_cast.h	9;"	d
CORE_GTL_TYPE_TRAITS_EXT_H_	core/gtl/type_traits_ext.h	9;"	d
CORE_IO_IO_H_	core/io/IO.h	9;"	d
CORE_MANIFOLD_H_	core/manifold/Manifold.h	9;"	d
CORE_MESH_MESH_IDS_H_	core/manifold/mesh/MeshIds.h	9;"	d
CORE_MESH_MESH_TRAITS_H_	core/manifold/ManifoldTraits.h	9;"	d
CORE_MODEL_MODEL_TRAITS_H_	core/model/obsoleted/model_traits.h	9;"	d
CORE_MODEL_SELECT_H_	core/model/obsoleted/select.h	9;"	d
CORE_NUMERIC_HALF_SPLIT_H_	core/numeric/half_split.h	9;"	d
CORE_NUMERIC_LINE_CLIPING_H_	core/geometry/obsolete/line_cliping.h	9;"	d
CORE_NUMERIC_NUMERIC_H_	core/numeric/numeric.h	9;"	d
CORE_NUMERIC_POLYGONS_H_	core/geometry/obsolete/polygons.h	9;"	d
CORE_PARALLEL_BLOCKED_RANGE_H_	core/parallel/obsoleted/blocked_range.h	9;"	d
CORE_PARALLEL_DISTRIBUTED_ARRAY_CPP_	core/parallel/obsoleted/distributed_array.cpp	9;"	d	file:
CORE_PARALLEL_MPI_UPDATE_H_	core/parallel/MPIUpdate.h	9;"	d
CORE_PARALLEL_PARALLEL_DUMMY_H_	core/parallel/ParallelDummy.h	9;"	d
CORE_PARALLEL_SEQ_RANGE_H_	core/parallel/obsoleted/seq_range.h	9;"	d
CORE_PARTICLE_KINETIC_PARTICLE_H_	core/particle/obsolete/kinetic_particle.h	9;"	d
CORE_PARTICLE_PARTICLE_CONTAINER_H_	core/particle/ParticleContainer.h	9;"	d
CORE_PARTICLE_PARTICLE_GENERATOR_H_	core/particle/ParticleGenerator.h	9;"	d
CORE_PARTICLE_PARTICLE_H_	core/particle/Particle.h	9;"	d
CORE_PARTICLE_PROBE_PARTICLE_H_	core/particle/obsolete/probe_particle.h	9;"	d
CORE_PARTICLE_SIMPLE_PARTICLE_GENERATOR_H_	core/particle/pre_define/SimpleParticleGenerator.h	9;"	d
CORE_PARTICLE_SIMPLE_PARTICLE_H_	core/particle/obsolete/simple_particle.h	9;"	d
CORE_PARTICLE_SYNC_PARTICLE_H_	core/particle/obsolete/sync_particle.h	9;"	d
CORE_UTILITIES_CONFIG_PARSER_H_	core/gtl/utilities/config_parser.h	9;"	d
CORE_UTILITIES_LUA_OBJECT_EXT_H_	core/gtl/utilities/lua_object_ext.h	9;"	d
CORE_UTILITIES_LUA_OBJECT_H_	core/gtl/utilities/lua_object.h	11;"	d
CORE_UTILITIES_MEMORY_POOL_H_	core/gtl/utilities/memory_pool.h	10;"	d
CORE_UTILITIES_MISC_UTILITIES_H_	core/gtl/utilities/utilities.h	9;"	d
COUNT_MACRO_ARGS	core/data_model/DataTypeExt.h	29;"	d
COUNT_MACRO_ARGS	core/gtl/macro.h	29;"	d
COUNT_MACRO_ARGS_IMPL	core/data_model/DataTypeExt.h	28;"	d
COUNT_MACRO_ARGS_IMPL	core/gtl/macro.h	28;"	d
COUNT_MACRO_ARGS_IMPL2	core/data_model/DataTypeExt.h	27;"	d
COUNT_MACRO_ARGS_IMPL2	core/gtl/macro.h	27;"	d
CUSTOM	core/model/obsoleted/model.h	/^                CUSTOM = 1UL << 20$/;"	e	enum:simpla::Model::__anon9
CVec3	core/gtl/primitives.h	/^typedef nTuple<Complex, 3> CVec3;$/;"	t	namespace:simpla
C_	core/physics/PhysicalConstants.h	/^    double C_;    \/\/<< electric charge	[coulomb]$/;"	m	class:simpla::PhysicalConstants
C_ORDER	core/gtl/primitives.h	/^    C_ORDER, \/\/ SLOW FIRST$/;"	e	enum:simpla::ArrayOrder
Cache	core/gtl/cache.h	/^	Cache(T const & f, Args ...) :$/;"	f	struct:simpla::Cache
Cache	core/gtl/cache.h	/^	Cache(T& f, Args ...) :$/;"	f	struct:simpla::Cache
Cache	core/gtl/cache.h	/^	Cache(T* f, Args ...) :$/;"	f	struct:simpla::Cache
Cache	core/gtl/cache.h	/^struct Cache$/;"	s	namespace:simpla
Cache	core/gtl/cache.h	/^struct Cache<T const &>$/;"	s	namespace:simpla
Cache	core/gtl/cache.h	/^struct Cache<T*>$/;"	s	namespace:simpla
CacheContainer	core/gtl/containers/container_cache.h	/^	CacheContainer(T const & f, Args ...)$/;"	f	struct:simpla::CacheContainer
CacheContainer	core/gtl/containers/container_cache.h	/^	CacheContainer(T& f, Args ...)$/;"	f	struct:simpla::CacheContainer
CacheContainer	core/gtl/containers/container_cache.h	/^	CacheContainer(T* f, Args ...)$/;"	f	struct:simpla::CacheContainer
CacheContainer	core/gtl/containers/container_cache.h	/^struct CacheContainer$/;"	s	namespace:simpla
CacheContainer	core/gtl/containers/container_cache.h	/^struct CacheContainer<T const &>$/;"	s	namespace:simpla
CacheContainer	core/gtl/containers/container_cache.h	/^struct CacheContainer<T*>$/;"	s	namespace:simpla
CallbackMap	core/gtl/design_pattern/factory.h	/^	typedef std::map<identifier_type, create_fun_callback> CallbackMap;$/;"	t	struct:simpla::Factory
CanonicalizeAlphabeticalOrder	cpplint.py	/^  def CanonicalizeAlphabeticalOrder(self, header_path):$/;"	m	class:_IncludeState
Cartesian	core/geometry/CoordinateSystem.h	/^struct Cartesian$/;"	s	namespace:simpla::geometry::coordinate_system
CartesianCoRect	core/manifold/mesh/CartesianCoRect.h	/^    CartesianCoRect() : block_type() { }$/;"	f	struct:simpla::mesh::CartesianCoRect
CartesianCoRect	core/manifold/mesh/CartesianCoRect.h	/^struct CartesianCoRect : public geometry::CartesianMetric, public MeshBlock$/;"	s	namespace:simpla::mesh
CartesianMetric	core/geometry/csCartesian.h	/^struct CartesianMetric$/;"	s	namespace:simpla::geometry
CartesianXAxis	core/geometry/csCartesian.h	/^    static constexpr int CartesianXAxis = (CartesianZAxis + 1) % 3;$/;"	m	struct:simpla::geometry::CartesianMetric
CartesianXAxis	core/model/GEqdsk.h	/^    static constexpr int CartesianXAxis = (CartesianZAxis + 1) % 3;$/;"	m	class:simpla::GEqdsk
CartesianYAxis	core/geometry/csCartesian.h	/^    static constexpr int CartesianYAxis = (CartesianZAxis + 2) % 3;$/;"	m	struct:simpla::geometry::CartesianMetric
CartesianYAxis	core/model/GEqdsk.h	/^    static constexpr int CartesianYAxis = (CartesianZAxis + 2) % 3;$/;"	m	class:simpla::GEqdsk
CartesianZAxis	core/geometry/csCartesian.h	/^    static constexpr int CartesianZAxis = (I_CARTESIAN_ZAXIS) % 3;$/;"	m	struct:simpla::geometry::CartesianMetric
CartesianZAxis	core/model/GEqdsk.h	/^    static constexpr int CartesianZAxis = 2;$/;"	m	class:simpla::GEqdsk
Chains	core/geometry/chains.h	/^struct Chains<Primitive<1, CS, tags::simplex>, Policies...> : public std::vector<$/;"	s	namespace:simpla::geometry::model
Chains	core/geometry/chains.h	/^struct Chains<TPrimitive, Policies...>$/;"	s	namespace:simpla::geometry::model
Check	cpplint.py	/^  def Check(self, error, filename, linenum):$/;"	m	class:_FunctionState
CheckAttributeNames	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^void vtkAMRSimPlaReader::pimpl_s::CheckAttributeNames()$/;"	f	class:vtkAMRSimPlaReader::pimpl_s
CheckBraces	cpplint.py	/^def CheckBraces(filename, clean_lines, linenum, error):$/;"	f
CheckCStyleCast	cpplint.py	/^def CheckCStyleCast(filename, linenum, line, raw_line, cast_type, pattern,$/;"	f
CheckCheck	cpplint.py	/^def CheckCheck(filename, clean_lines, linenum, error):$/;"	f
CheckComment	cpplint.py	/^def CheckComment(comment, filename, linenum, error):$/;"	f
CheckFileExists	core/gtl/utilities/misc_utilities.h	/^inline bool CheckFileExists(std::string const & name)$/;"	f	namespace:simpla
CheckFileExists	core/io/IOStream.cpp	/^inline bool CheckFileExists(std::string const &name)$/;"	f	namespace:simpla::io
CheckFinished	cpplint.py	/^  def CheckFinished(self, filename, error):$/;"	m	class:_ClassState
CheckForCopyright	cpplint.py	/^def CheckForCopyright(filename, lines, error):$/;"	f
CheckForFunctionLengths	cpplint.py	/^def CheckForFunctionLengths(filename, clean_lines, linenum,$/;"	f
CheckForHeaderGuard	cpplint.py	/^def CheckForHeaderGuard(filename, lines, error):$/;"	f
CheckForIncludeWhatYouUse	cpplint.py	/^def CheckForIncludeWhatYouUse(filename, clean_lines, include_state, error,$/;"	f
CheckForMultilineCommentsAndStrings	cpplint.py	/^def CheckForMultilineCommentsAndStrings(filename, clean_lines, linenum, error):$/;"	f
CheckForNewlineAtEOF	cpplint.py	/^def CheckForNewlineAtEOF(filename, lines, error):$/;"	f
CheckForNonStandardConstructs	cpplint.py	/^def CheckForNonStandardConstructs(filename, clean_lines, linenum,$/;"	f
CheckForUnicodeReplacementCharacters	cpplint.py	/^def CheckForUnicodeReplacementCharacters(filename, lines, error):$/;"	f
CheckIncludeLine	cpplint.py	/^def CheckIncludeLine(filename, clean_lines, linenum, include_state, error):$/;"	f
CheckInvalidIncrement	cpplint.py	/^def CheckInvalidIncrement(filename, clean_lines, linenum, error):$/;"	f
CheckLanguage	cpplint.py	/^def CheckLanguage(filename, clean_lines, linenum, file_extension, include_state,$/;"	f
CheckNextIncludeOrder	cpplint.py	/^  def CheckNextIncludeOrder(self, header_type):$/;"	m	class:_IncludeState
CheckParticleType	plugins/vtk_reader/vtkAMRSimPlaParticlesReader.cpp	/^bool vtkAMRSimPlaParticlesReader::CheckParticleType($/;"	f	class:vtkAMRSimPlaParticlesReader
CheckPosixThreading	cpplint.py	/^def CheckPosixThreading(filename, clean_lines, linenum, error):$/;"	f
CheckSpacing	cpplint.py	/^def CheckSpacing(filename, clean_lines, linenum, error):$/;"	f
CheckSpacingForFunctionCall	cpplint.py	/^def CheckSpacingForFunctionCall(filename, line, linenum, error):$/;"	f
CheckStyle	cpplint.py	/^def CheckStyle(filename, clean_lines, linenum, file_extension, error):$/;"	f
ChildrenIds	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^    std::vector<int> ChildrenIds;$/;"	m	class:vtkAMRSimPlaReaderBlock	file:
CleanseComments	cpplint.py	/^def CleanseComments(line):$/;"	f
CleansedLines	cpplint.py	/^class CleansedLines(object):$/;"	c
CloseExpression	cpplint.py	/^def CloseExpression(clean_lines, linenum, pos):$/;"	f
CoVector	core/geometry/primitive.h	/^struct CoVector$/;"	s	namespace:simpla::geometry::model
CodifferentialDerivative	core/manifold/Calculus.h	/^struct CodifferentialDerivative$/;"	s	namespace:simpla::calculus::tags
Cold plasma	docs/tex/FDTD_Plasma.tex	/^\\end{eqnarray}$/;"	P
Complex	core/gtl/primitives.h	/^typedef std::complex<Real> Complex;$/;"	t	namespace:simpla
ComputeStats	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^void vtkAMRSimPlaReader::ComputeStats(std::vector<int> &numBlocks, double min[3])$/;"	f	class:vtkAMRSimPlaReader
ConfigParser	core/gtl/utilities/config_parser.cpp	/^ConfigParser::ConfigParser()$/;"	f	class:simpla::ConfigParser
ConfigParser	core/gtl/utilities/config_parser.h	/^struct ConfigParser$/;"	s	namespace:simpla
Constant	core/gtl/expression_template.h	/^struct Constant$/;"	s	namespace:simpla
ContainerContainer	core/gtl/containers/container_container.h	/^	ContainerContainer()$/;"	f	class:simpla::ContainerContainer
ContainerContainer	core/gtl/containers/container_container.h	/^	ContainerContainer(allocator_type const & alloc)$/;"	f	class:simpla::ContainerContainer
ContainerContainer	core/gtl/containers/container_container.h	/^class ContainerContainer: public std::map<TKey, InnerContainer>$/;"	c	namespace:simpla
ContainerOutPut1	core/gtl/utilities/pretty_stream.h	/^std::ostream &ContainerOutPut1(std::ostream &os, TI const ib, TI const ie)$/;"	f	namespace:simpla
ContainerOutPut2	core/gtl/utilities/pretty_stream.h	/^std::ostream &ContainerOutPut2(std::ostream &os, TI const &ib, TI const &ie)$/;"	f	namespace:simpla
ContainerOutPut3	core/gtl/utilities/pretty_stream.h	/^std::ostream &ContainerOutPut3(std::ostream &os, TI const &ib, TI const &ie,$/;"	f	namespace:simpla
ContainerPool	core/gtl/containers/container_pool.h	/^template<typename ValueType> struct ContainerPool$/;"	s	namespace:simpla
ContainerSaveCache	core/gtl/containers/container_save_cache.h	/^	ContainerSaveCache(Args&& ... args) :$/;"	f	class:simpla::ContainerSaveCache
ContainerSaveCache	core/gtl/containers/container_save_cache.h	/^class ContainerSaveCache: public std::vector<TV>$/;"	c	namespace:simpla
ContextBase	core/task_flow/context_base.h	/^	ContextBase()$/;"	f	class:simpla::ContextBase
ContextBase	core/task_flow/context_base.h	/^class ContextBase$/;"	c	namespace:simpla
ContextBase	core/task_flow/task_flow_base.h	/^    ContextBase() { };$/;"	f	class:simpla::task_flow::ContextBase
ContextBase	core/task_flow/task_flow_base.h	/^class ContextBase$/;"	c	namespace:simpla::task_flow
ConvertToCGS	plugins/vtk_reader/vtkAMRSimPlaReader.h	/^    int ConvertToCGS;$/;"	m	class:vtkAMRSimPlaReader
Converter	core/gtl/utilities/lua_object_ext.h	/^struct Converter$/;"	s	namespace:simpla::lua
Converter	core/gtl/utilities/lua_object_ext.h	/^struct Converter<Properties>$/;"	s	namespace:simpla::lua
Converter	core/gtl/utilities/lua_object_ext.h	/^struct Converter<std::string>$/;"	s	namespace:simpla::lua
Converter	core/gtl/utilities/lua_object_ext.h	/^template<int N, typename T> struct Converter<nTuple<T, N>>$/;"	s	namespace:simpla::lua
Converter	core/gtl/utilities/lua_object_ext.h	/^template<typename ... T> struct Converter<std::tuple<T...> >$/;"	s	namespace:simpla::lua
Converter	core/gtl/utilities/lua_object_ext.h	/^template<typename T, int N, int ...M> struct Converter<nTuple<T, N, M...>>$/;"	s	namespace:simpla::lua
Converter	core/gtl/utilities/lua_object_ext.h	/^template<typename T1, typename T2> struct Converter<std::map<T1, T2> >$/;"	s	namespace:simpla::lua
Converter	core/gtl/utilities/lua_object_ext.h	/^template<typename T1, typename T2> struct Converter<std::pair<T1, T2> >$/;"	s	namespace:simpla::lua
Converter	core/gtl/utilities/lua_object_ext.h	/^template<typename T> struct Converter<std::complex<T> >$/;"	s	namespace:simpla::lua
Converter	core/gtl/utilities/lua_object_ext.h	/^template<typename T> struct Converter<std::list<T> >$/;"	s	namespace:simpla::lua
Converter	core/gtl/utilities/lua_object_ext.h	/^template<typename T> struct Converter<std::vector<T> >$/;"	s	namespace:simpla::lua
Count	cpplint.py	/^  def Count(self):$/;"	m	class:_FunctionState
CountBits	core/gtl/type_traits_ext.h	/^template<> struct CountBits<0>$/;"	s	namespace:simpla
CountBits	core/gtl/type_traits_ext.h	/^template<unsigned long N> struct CountBits$/;"	s	namespace:simpla
Covec3	core/gtl/primitives.h	/^typedef nTuple<Real, 3> Covec3;$/;"	t	namespace:simpla
Cra	core/geometry/obsolete/line_cliping.h	/^	size_t Cra[15] =$/;"	m	class:simpla::polygon_clip
CreateFactoryFun	applications/contexts/explicit_em.h	/^            std::function<std::shared_ptr<base_type>(Args const &...)>> CreateFactoryFun()$/;"	f	struct:simpla::ExplicitEMContext
Cross	core/manifold/Calculus.h	/^struct Cross$/;"	s	namespace:simpla::calculus::tags
CycleIndex	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^    int CycleIndex;$/;"	m	class:vtkAMRSimPlaReader::pimpl_s	file:
CycleIterator	core/gtl/iterator/sp_iterator_cycle.h	/^	CycleIterator(base_iterator const & b, base_iterator const &e)$/;"	f	struct:simpla::CycleIterator
CycleIterator	core/gtl/iterator/sp_iterator_cycle.h	/^	CycleIterator(base_iterator const &self, base_iterator const & b,$/;"	f	struct:simpla::CycleIterator
CycleIterator	core/gtl/iterator/sp_iterator_cycle.h	/^	CycleIterator(this_type && other)$/;"	f	struct:simpla::CycleIterator
CycleIterator	core/gtl/iterator/sp_iterator_cycle.h	/^	CycleIterator(this_type const & other)$/;"	f	struct:simpla::CycleIterator
CycleIterator	core/gtl/iterator/sp_iterator_cycle.h	/^struct CycleIterator: public TBaseIterator$/;"	s	namespace:simpla
Cylinder	core/geometry/obsolete/geometry_object.h	/^struct Cylinder$/;"	s	namespace:simpla::geometry_object
Cylindrical	core/geometry/CoordinateSystem.h	/^struct Cylindrical$/;"	s	namespace:simpla::geometry::coordinate_system
CylindricalCoRect	core/manifold/mesh/CylindricalCoRect.h	/^    CylindricalCoRect() : block_type() { }$/;"	f	class:simpla::mesh::CylindricalCoRect
CylindricalCoRect	core/manifold/mesh/CylindricalCoRect.h	/^class CylindricalCoRect : public geometry::CylindricalMetric, public MeshBlock$/;"	c	namespace:simpla::mesh
DATA_STREAM_	core/io/HDF5Stream.h	10;"	d
DATA_TYPE_H_	core/data_model/DataType.h	9;"	d
DEADEND	core/gtl/utilities/log.h	339;"	d
DEBUG_SAVE	core/io/IO.h	149;"	d
DECLARE_FUNCTION_PREFIX	core/manifold/policy/FvmStructuredPolicy.h	38;"	d
DECLARE_FUNCTION_PREFIX	core/manifold/policy/FvmStructuredPolicy.h	682;"	d
DECLARE_FUNCTION_PREFIX	core/manifold/policy/LinearInterpolatorPolicy.h	16;"	d
DECLARE_FUNCTION_SUFFIX	core/manifold/policy/FvmStructuredPolicy.h	39;"	d
DECLARE_FUNCTION_SUFFIX	core/manifold/policy/FvmStructuredPolicy.h	683;"	d
DECLARE_FUNCTION_SUFFIX	core/manifold/policy/LinearInterpolatorPolicy.h	17;"	d
DECL_RET_TYPE	core/gtl/macro.h	13;"	d
DEF	applications/field_solver/pml.h	146;"	d
DEF	applications/field_solver/pml.h	163;"	d
DEFAULT_LINE_WIDTH	core/gtl/utilities/log.cpp	/^    static constexpr unsigned int DEFAULT_LINE_WIDTH = 100;$/;"	m	struct:simpla::logger::LoggerStreams	file:
DEFAULT_MAX_BUFFER_DEPTH	core/io/HDF5Stream.cpp	/^    static constexpr size_t DEFAULT_MAX_BUFFER_DEPTH = 100;$/;"	m	struct:simpla::io::HDF5Stream::pimpl_s	file:
DEFINE_EXPRESSOPM_TEMPLATE_BASIC_ALGEBRA	core/gtl/expression_template.h	525;"	d
DEFINE_EXPRESSOPM_TEMPLATE_BASIC_ALGEBRA2	core/gtl/expression_template.h	572;"	d
DEFINE_EXPRESSOPM_TEMPLATE_BOOLEAN_ALGEBRA2	core/gtl/expression_template.h	604;"	d
DEFINE_INVOKE_IF_HAS	core/manifold/obsoleted/amr_policy.h	129;"	d
DEFINE_INVOKE_IF_HAS	core/manifold/obsoleted/amr_policy.h	153;"	d
DEFINE_INVOKE_IF_HAS	core/manifold/obsoleted/patch/mesh_patch.h	160;"	d
DEFINE_INVOKE_IF_HAS	core/manifold/obsoleted/patch/mesh_patch.h	184;"	d
DEFINE_PHYSICAL_CONST	core/physics/PhysicalConstants.h	117;"	d
DEFINE_PROPERTIES	core/gtl/Properties.h	181;"	d
DEFINE_TYPE_ID_NAME	core/gtl/type_traits.h	218;"	d
DEF_ASSIGN_OP	core/gtl/expression_template.h	267;"	d
DEF_ASSIGN_OP	core/gtl/expression_template.h	289;"	d
DEF_BOP	core/gtl/expression_template.h	184;"	d
DEF_BOP	core/gtl/expression_template.h	256;"	d
DEF_COMPLEX_OP	core/gtl/complex.h	17;"	d
DEF_COMPLEX_OP	core/gtl/complex.h	45;"	d
DEF_COMPLEX_OP	core/gtl/sp_complex.h	17;"	d
DEF_COMPLEX_OP	core/gtl/sp_complex.h	45;"	d
DEF_COMPLEX_OP_BUNDLE	core/gtl/complex.h	33;"	d
DEF_COMPLEX_OP_BUNDLE	core/gtl/complex.h	44;"	d
DEF_COMPLEX_OP_BUNDLE	core/gtl/sp_complex.h	33;"	d
DEF_COMPLEX_OP_BUNDLE	core/gtl/sp_complex.h	44;"	d
DEF_LUA_TRANS	core/gtl/utilities/lua_object_ext.h	124;"	d
DEF_LUA_TRANS	core/gtl/utilities/lua_object_ext.h	96;"	d
DEF_NTUPLE_OBJECT	core/geometry/primitive.h	253;"	d
DEF_NTUPLE_OBJECT	core/geometry/primitive.h	97;"	d
DEF_STD_BINARY_FUNCTION	core/gtl/expression_template.h	329;"	d
DEF_STD_BINARY_FUNCTION	core/gtl/expression_template.h	345;"	d
DEF_TYPE_CHECK	core/gtl/utilities/lua_object.cpp	559;"	d	file:
DEF_TYPE_CHECK	core/gtl/utilities/lua_object.cpp	588;"	d	file:
DEF_UNARY_FUNCTION	core/gtl/expression_template.h	347;"	d
DEF_UNARY_FUNCTION	core/gtl/expression_template.h	398;"	d
DEF_UOP	core/gtl/expression_template.h	196;"	d
DEF_UOP	core/gtl/expression_template.h	255;"	d
DEF_XDMF_TYPE_TRAITS	core/io/XDMFIO.h	29;"	d
DEF_XDMF_TYPE_TRAITS	core/io/XDMFIO.h	46;"	d
DI	core/manifold/mesh/MeshIds.h	/^    static constexpr id_type DI(int n, id_type s)$/;"	f	struct:simpla::mesh::MeshEntityIdCoder
DIMENSIONS	core/gtl/test/ntuple_reduce_test.cpp	/^	nTuple<std::size_t, traits::extent<extents>::value> DIMENSIONS;$/;"	m	class:TestNtupleReduce	file:
DISTRIBUTED_ARRAY_H_	core/parallel/obsoleted/distributed_array.h	9;"	d
DONE	core/gtl/utilities/log.h	315;"	d
DOUBLELINE	core/gtl/utilities/log.h	418;"	d
DataArray	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^    vtkDataArray *DataArray;$/;"	m	class:vtkAMRSimPlaReader::pimpl_s	file:
DataObject	core/base/DataObject.h	/^class DataObject : public Object$/;"	c	namespace:simpla::base
DataSet	core/data_model/DataSet.h	/^    DataSet() : data(nullptr) { }$/;"	f	struct:simpla::data_model::DataSet
DataSet	core/data_model/DataSet.h	/^    DataSet(DataSet &&other) :$/;"	f	struct:simpla::data_model::DataSet
DataSet	core/data_model/DataSet.h	/^    DataSet(DataSet const &other) :$/;"	f	struct:simpla::data_model::DataSet
DataSet	core/data_model/DataSet.h	/^struct DataSet : public base::Object$/;"	s	namespace:simpla::data_model
DataSpace	core/data_model/DataSpace.cpp	/^DataSpace::DataSpace() : m_pimpl_{new pimpl_s} { }$/;"	f	class:simpla::data_model::DataSpace
DataSpace	core/data_model/DataSpace.cpp	/^DataSpace::DataSpace(DataSpace &&other) : m_pimpl_(other.m_pimpl_) { }$/;"	f	class:simpla::data_model::DataSpace
DataSpace	core/data_model/DataSpace.cpp	/^DataSpace::DataSpace(const DataSpace &other) :$/;"	f	class:simpla::data_model::DataSpace
DataSpace	core/data_model/DataSpace.cpp	/^DataSpace::DataSpace(int ndims, index_type const *dims) :$/;"	f	class:simpla::data_model::DataSpace
DataSpace	core/data_model/DataSpace.h	/^class DataSpace : public base::Object$/;"	c	namespace:simpla::data_model
DataTime	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^    double DataTime;$/;"	m	class:vtkAMRSimPlaReader::pimpl_s	file:
DataType	core/data_model/DataType.cpp	/^DataType::DataType() :$/;"	f	class:simpla::data_model::DataType
DataType	core/data_model/DataType.cpp	/^DataType::DataType(DataType &&other) :$/;"	f	class:simpla::data_model::DataType
DataType	core/data_model/DataType.cpp	/^DataType::DataType(DataType const &other) :$/;"	f	class:simpla::data_model::DataType
DataType	core/data_model/DataType.cpp	/^DataType::DataType(std::type_index t_index, size_t ele_size_in_byte,$/;"	f	class:simpla::data_model::DataType
DataType	core/data_model/DataType.h	/^struct DataType : public base::Object$/;"	s	namespace:simpla::data_model
DataTypeDesc	applications/particle_solver/pic_engine_deltaf2.h	/^		static std::string DataTypeDesc()$/;"	f	struct:simpla::PICEngineDeltaF::Point_s
DeepCopy	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^void vtkAMRSimPlaReaderBlock::DeepCopy(const vtkAMRSimPlaReaderBlock *other)$/;"	f	class:vtkAMRSimPlaReaderBlock
DefaultValue	applications/particle_solver/pic_engine_deltaf2.h	/^	static Point_s DefaultValue()$/;"	f	struct:simpla::PICEngineDeltaF
DefaultValue	applications/particle_solver/pic_engine_ggauge.h	/^	static Point_s DefaultValue()$/;"	f	class:simpla::PICEngineGGauge
DenseContainer	core/gtl/containers/container_dense.h	/^	DenseContainer(TR const& range, size_t max_hash_value,$/;"	f	class:simpla::DenseContainer
DenseContainer	core/gtl/containers/container_dense.h	/^	DenseContainer(this_type &&rhs) :$/;"	f	class:simpla::DenseContainer
DenseContainer	core/gtl/containers/container_dense.h	/^	DenseContainer(this_type const & rhs) :$/;"	f	class:simpla::DenseContainer
DenseContainer	core/gtl/containers/container_dense.h	/^	DenseContainer(value_type d = value_type()) :$/;"	f	class:simpla::DenseContainer
DenseContainer	core/gtl/containers/container_dense.h	/^class DenseContainer$/;"	c	namespace:simpla
Density 	scripts/configure/disp_relation.lua	/^		Density = function(x)$/;"	f
Derived	core/gtl/any.h	/^    Derived(U &&value) : m_value(std::forward<U>(value)) { }$/;"	f	struct:simpla::Derived
Derived	core/gtl/any.h	/^    Derived(U const &value) : m_value(value) { }$/;"	f	struct:simpla::Derived
Derived	core/gtl/any.h	/^struct Derived : Base$/;"	s	namespace:simpla
DetermineRootBoundingBox	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^void vtkAMRSimPlaReader::pimpl_s::DetermineRootBoundingBox()$/;"	f	class:vtkAMRSimPlaReader::pimpl_s
DictObject	core/gtl/utilities/config_parser.h	/^        DictObject()$/;"	f	struct:simpla::ConfigParser::DictObject
DictObject	core/gtl/utilities/config_parser.h	/^        DictObject(DictObject &&other)$/;"	f	struct:simpla::ConfigParser::DictObject
DictObject	core/gtl/utilities/config_parser.h	/^        DictObject(DictObject const &other)$/;"	f	struct:simpla::ConfigParser::DictObject
DictObject	core/gtl/utilities/config_parser.h	/^        DictObject(lua::LuaObject const &lua_obj)$/;"	f	struct:simpla::ConfigParser::DictObject
DictObject	core/gtl/utilities/config_parser.h	/^        DictObject(std::string const &value)$/;"	f	struct:simpla::ConfigParser::DictObject
DictObject	core/gtl/utilities/config_parser.h	/^    struct DictObject : public lua::LuaObject$/;"	s	struct:simpla::ConfigParser
DirectMap	core/manifold/obsoleted/fiber_bundle.h	/^    DirectMap(mesh_type const &) { }$/;"	f	struct:simpla::manifold::DirectMap
DirectMap	core/manifold/obsoleted/fiber_bundle.h	/^struct DirectMap$/;"	s	namespace:simpla::manifold
DirectoryName	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^    std::string DirectoryName;$/;"	m	class:vtkAMRSimPlaReader::pimpl_s	file:
Distributed	core/parallel/obsoleted/distributed.h	/^	Distributed(MPIComm &comm) : DistributedObject(comm) { };$/;"	f	class:simpla::Distributed
Distributed	core/parallel/obsoleted/distributed.h	/^	Distributed(const this_type &other) : DistributedObject(other), base_type(other) { }$/;"	f	class:simpla::Distributed
Distributed	core/parallel/obsoleted/distributed.h	/^class Distributed<TBase> : public DataSet, public DistributedObject$/;"	c	namespace:simpla
Distributed	core/parallel/obsoleted/distributed_unordered_set.h	/^	Distributed() { };$/;"	f	struct:simpla::Distributed
Distributed	core/parallel/obsoleted/distributed_unordered_set.h	/^	Distributed(this_type const &other) : base_type(other) { };$/;"	f	struct:simpla::Distributed
Distributed	core/parallel/obsoleted/distributed_unordered_set.h	/^struct Distributed<UnorderedSet<TV, Others...>, TRange>$/;"	s	namespace:simpla
DistributedCounter	core/parallel/DistributedCounter.h	/^    DistributedCounter() : m_start_(0), m_end_(0) { }$/;"	f	struct:simpla::parallel::DistributedCounter
DistributedCounter	core/parallel/DistributedCounter.h	/^struct DistributedCounter$/;"	s	namespace:simpla::parallel
DistributedCounter	core/parallel/ParallelRandomGenerator.h	/^    DistributedCounter() : m_start_(0), m_end_(0) { }$/;"	f	struct:simpla::parallel::DistributedCounter
DistributedCounter	core/parallel/ParallelRandomGenerator.h	/^struct DistributedCounter$/;"	s	namespace:simpla::parallel
DistributedObject	core/parallel/DistributedObject.cpp	/^DistributedObject::DistributedObject()$/;"	f	class:simpla::parallel::DistributedObject
DistributedObject	core/parallel/DistributedObject.h	/^struct DistributedObject$/;"	s	namespace:simpla::parallel
DistributedUnorderedSetBase	core/parallel/trash/distributed_unordered_set.cpp	/^DistributedUnorderedSetBase::DistributedUnorderedSetBase() : pimpl_(new pimpl_s)$/;"	f	class:simpla::DistributedUnorderedSetBase
Dot	core/manifold/Calculus.h	/^struct Dot$/;"	s	namespace:simpla::calculus::tags
Double Cross Product Version	docs/tex/FDTD_Plasma.tex	/^\\begin{comment}$/;"	P
E	scripts/configure/cold_plasma.lua	/^   E=function(x,y,z)$/;"	f
E	scripts/configure/demo2.lua	/^  E=function(x,y,z)$/;"	f
E	scripts/configure/icrf.lua	/^   E=function(x,y,z)$/;"	f
E	scripts/configure/test.lua	/^	E=function(x)$/;"	f
E0	applications/contexts/explicit_em.h	/^    field<nTuple<Real, 3>, VERTEX> E0; \/\/!<background  equilibrium electoric field  (B0)=0$/;"	m	struct:simpla::ExplicitEMContext
E0_type	applications/particle_solver/fluid_cold_engine.h	/^	typedef typename mesh_type:: template field<VERTEX, nTuple<Real, 3> > E0_type;$/;"	t	class:simpla::Particle
E0_type	applications/particle_solver/pic_engine_implicit.h	/^	typedef typename mesh_type:: template field<VERTEX, nTuple<3, Real> > E0_type;$/;"	t	struct:simpla::PICEngineImplicit
E1	core/particle/pre_define/PICBoris.h	/^    E_field E1;$/;"	m	struct:simpla::particle::engine::BorisEngine
E1	core/particle/pre_define/PICGyro.h	/^    E_field E1;$/;"	m	struct:simpla::particle::engine::GyroParticleWithCylindricalCoord
E1_type	applications/particle_solver/fluid_cold_engine.h	/^	typedef typename mesh_type:: template field<VERTEX, nTuple<scalar_type, 3>> E1_type;$/;"	t	class:simpla::Particle
E1_type	applications/particle_solver/pic_engine_implicit.h	/^	typedef typename mesh_type:: template field<VERTEX, nTuple<3, scalar_type>> E1_type;$/;"	t	struct:simpla::PICEngineImplicit
EDGE	core/manifold/ManifoldTraits.h	/^    EDGE = 1,$/;"	e	enum:simpla::ManifoldTypeID
EMFluid	core/phy_solver/em_fluid.h	/^    EMFluid(TM &m_p) : m(m_p) { }$/;"	f	class:simpla::phy_solver::EMFluid
EMFluid	core/phy_solver/em_fluid.h	/^class EMFluid$/;"	c	namespace:simpla::phy_solver
EMTokamak	example/em_tokamak/tokamak.cpp	/^    EMTokamak() { }$/;"	f	struct:simpla::EMTokamak
EMTokamak	example/em_tokamak/tokamak.cpp	/^struct EMTokamak$/;"	s	namespace:simpla	file:
ENABLE_IF_DECL_RET_TYPE	core/gtl/macro.h	15;"	d
EPSILON	core/gtl/primitives.h	/^static constexpr Real EPSILON = std::numeric_limits<Real>::epsilon();$/;"	m	namespace:simpla
EPSILON	core/manifold/mesh/MeshIds.h	/^    static constexpr Real EPSILON = 1.0 \/ static_cast<Real>(INDEX_ZERO);$/;"	m	struct:simpla::mesh::MeshEntityIdCoder
EPSILON	core/manifold/mesh/MeshIds.h	/^template<int L> constexpr Real MeshEntityIdCoder<L>::EPSILON;$/;"	m	class:simpla::mesh::MeshEntityIdCoder
EQUATION	core/gtl/test/ntuple_perf_test.cpp	20;"	d	file:
EXAMPLE_USE_CASE_DEMO_PROBE_PARTICLE_H_	example/probe_particle/demo_probe_particle.h	9;"	d
EXAMPLE_USE_CASE_PIC_DEMO_PIC_H_	example/pic/demo_pic.h	9;"	d
EXCEPTION_BAD_ALLOC	core/gtl/utilities/log.h	359;"	d
EXPLICIT_EM_H_	applications/contexts/context_factory.h	9;"	d
EXPLICIT_EM_IMPL_H_	applications/contexts/explicit_em.h	9;"	d
EXPRESSION_TEMPLATE_H_	core/gtl/expression_template.h	9;"	d
E_field	core/particle/pre_define/PICBoris.h	/^    typedef traits::field_t<scalar_type, mesh_type, EDGE> E_field;$/;"	t	struct:simpla::particle::engine::BorisEngine
E_field	core/particle/pre_define/PICGyro.h	/^    typedef traits::field_t<scalar_type, mesh_type, EDGE> E_field;$/;"	t	struct:simpla::particle::engine::GyroParticleWithCylindricalCoord
E_type	applications/contexts/explicit_em.h	/^    typedef decltype(E1) E_type;$/;"	t	struct:simpla::ExplicitEMContext
EmbeddedPolicy	core/manifold/obsoleted/embedded_policy.h	/^    EmbeddedPolicy(geometry_type &geo) : m_geo_(geo) { }$/;"	f	struct:simpla::manifold::policy::EmbeddedPolicy
EmbeddedPolicy	core/manifold/obsoleted/embedded_policy.h	/^struct EmbeddedPolicy<TGeo>$/;"	s	namespace:simpla::manifold::policy
EmptyType	core/gtl/type_traits.h	/^struct EmptyType$/;"	s	namespace:simpla
End	cpplint.py	/^  def End(self):$/;"	m	class:_FunctionState
Error	cpplint.py	/^def Error(filename, linenum, category, confidence, message):$/;"	f
ExcuteCommands	applications/contexts/explicit_em.h	/^    void ExcuteCommands(TBatch const &batch)$/;"	f	struct:simpla::ExplicitEMContext
ExplicitEMContext	applications/contexts/explicit_em.h	/^    ExplicitEMContext(Args &&...args) :$/;"	f	struct:simpla::ExplicitEMContext
ExplicitEMContext	applications/contexts/explicit_em.h	/^ExplicitEMContext<TM>::ExplicitEMContext() :$/;"	f	class:simpla::ExplicitEMContext
ExplicitEMContext	applications/contexts/explicit_em.h	/^struct ExplicitEMContext : public ContextBase$/;"	s	namespace:simpla
Expression	core/gtl/expression_template.h	/^    Expression(Args const &... pargs) :$/;"	f	struct:simpla::Expression
Expression	core/gtl/expression_template.h	/^    Expression(TOP op, Args const &... pargs) :$/;"	f	struct:simpla::Expression
Expression	core/gtl/expression_template.h	/^    Expression(this_type &&that) :$/;"	f	struct:simpla::Expression
Expression	core/gtl/expression_template.h	/^    Expression(this_type const &that) :$/;"	f	struct:simpla::Expression
Expression	core/gtl/expression_template.h	/^struct Expression<TOP, Args...>$/;"	s	namespace:simpla
ExtendedCsCode	core/geometry/obsolete/line_cliping.h	/^	size_t ExtendedCsCode(pnt2d p)$/;"	f	class:simpla::polygon_clip
Extension	cpplint.py	/^  def Extension(self):$/;"	m	class:FileInfo
ExteriorDerivative	core/manifold/Calculus.h	/^struct ExteriorDerivative$/;"	s	namespace:simpla::calculus::tags
FACE	core/manifold/ManifoldTraits.h	/^    FACE = 2,$/;"	e	enum:simpla::ManifoldTypeID
FACTORY_H_	core/gtl/design_pattern/factory.h	9;"	d
FETLTest	core/field/test/field_diff_calculus_test.h	/^class FETLTest : public testing::TestWithParam<$/;"	c
FETL_TEST2_H_	core/field/test/trash/fetl_test2.h	9;"	d
FETL_TEST3_H_	core/field/test/trash/fetl_test3.h	9;"	d
FETL_TEST4_H_	core/field/test/trash/fetl_test4.h	9;"	d
FIELD_BASIC_ALGEBRA_TEST_H_	core/field/test/field_basic_algebra_test.h	9;"	d
FIELD_CONSTANT_H_	core/field/obsoleted/field_constant.h	9;"	d
FIELD_DENSE_H_	core/field/FieldDense.h	9;"	d
FIELD_IO_TEST_H_	core/field/test/field_io_test.h	9;"	d
FIELD_SOLVER_H_	applications/field_solver/field_solver.h	9;"	d
FILE_LINE_STAMP	core/gtl/utilities/log.h	310;"	d
FIND_ROOT_H_	core/numeric/find_root.h	9;"	d
FLUID_COLD_ENGINE_H_	applications/particle_solver/fluid_cold_engine.h	9;"	d
FORTRAN_ORDER	core/gtl/primitives.h	/^    FORTRAN_ORDER \/\/  FAST_FIRST$/;"	e	enum:simpla::ArrayOrder
FULL_DIGITS	core/manifold/mesh/MeshIds.h	/^    static constexpr int FULL_DIGITS = std::numeric_limits<id_type>::digits;$/;"	m	struct:simpla::mesh::MeshEntityIdCoder
FULL_DIGITS	core/manifold/mesh/MeshIds.h	/^template<int L> constexpr int MeshEntityIdCoder<L>::FULL_DIGITS;$/;"	m	class:simpla::mesh::MeshEntityIdCoder
FULL_OVERFLOW_FLAG	core/manifold/mesh/MeshIds.h	/^    static constexpr id_type FULL_OVERFLOW_FLAG = OVERFLOW_FLAG$/;"	m	struct:simpla::mesh::MeshEntityIdCoder
Factory	core/gtl/design_pattern/factory.h	/^	Factory()$/;"	f	struct:simpla::Factory
Factory	core/gtl/design_pattern/factory.h	/^struct Factory$/;"	s	namespace:simpla
FiberBundle	core/manifold/obsoleted/fiber_bundle.h	/^    FiberBundle(mesh_type const &b) : m_map_(b), m_mesh_(b)$/;"	f	class:simpla::manifold::FiberBundle
FiberBundle	core/manifold/obsoleted/fiber_bundle.h	/^    FiberBundle(this_type const &other) : m_map_(other.m_map_), m_mesh_(other.m_mesh_)$/;"	f	class:simpla::manifold::FiberBundle
FiberBundle	core/manifold/obsoleted/fiber_bundle.h	/^class FiberBundle : public PI$/;"	c	namespace:simpla::manifold
FiberBundle	example/pic/demo_pic.h	/^	FiberBundle(base_manifold const &m) : m_mesh_(m)$/;"	f	struct:simpla::FiberBundle
FiberBundle	example/pic/demo_pic.h	/^struct FiberBundle<pic_demo, TBase>$/;"	s	namespace:simpla
Field	core/field/FieldDense.h	/^    Field() : m_data_(nullptr) { }$/;"	f	class:simpla::Field
Field	core/field/FieldDense.h	/^    Field(mesh_type &m, std::string const &name = "")$/;"	f	class:simpla::Field
Field	core/field/FieldDense.h	/^    Field(mesh_type const &m)$/;"	f	class:simpla::Field
Field	core/field/FieldDense.h	/^    Field(std::shared_ptr<attribute_type> d) : m_data_(d) { }$/;"	f	class:simpla::Field
Field	core/field/FieldDense.h	/^    Field(this_type &&other) : m_data_(other.m_data_) { }$/;"	f	class:simpla::Field
Field	core/field/FieldDense.h	/^    Field(this_type const &other) : m_data_(other.m_data_) { }$/;"	f	class:simpla::Field
Field	core/field/FieldDense.h	/^class Field<TV, TMesh, std::integral_constant<int, IFORM>, Policies...>$/;"	c	namespace:simpla
Field	core/field/FieldExpression.h	/^struct Field<AssignmentExpression<TOP, TL, TR> > : public AssignmentExpression<TOP, TL, TR>$/;"	s	namespace:simpla
Field	core/field/FieldExpression.h	/^struct Field<BooleanExpression<T...> > : Expression<T...>$/;"	s	namespace:simpla
Field	core/field/FieldExpression.h	/^struct Field<Expression<T...> > : public Expression<T...>$/;"	s	namespace:simpla
Field	core/field/FieldFunction.h	/^    Field(mesh_type const &m, TF const &fun, TBox const &box) :$/;"	f	class:simpla::Field
Field	core/field/FieldFunction.h	/^    Field(this_type const &other) :$/;"	f	class:simpla::Field
Field	core/field/FieldFunction.h	/^class Field<TV, TMesh, std::integral_constant<int, IFORM>, tags::function, TFun, TBox, Policies...>$/;"	c	namespace:simpla
Field	core/field/obsoleted/field_constant.h	/^	Field(mesh_type const &m, value_type const &f)$/;"	f	class:simpla::Field
Field	core/field/obsoleted/field_constant.h	/^	Field(this_type const &other)$/;"	f	class:simpla::Field
Field	core/field/obsoleted/field_constant.h	/^class Field<TM, TV, _impl::this_is_constant>$/;"	c	namespace:simpla
Field	core/field/obsoleted/field_sparse.h	/^	Field(mesh_type const & d, Args && ... args)$/;"	f	struct:simpla::Field
Field	core/field/obsoleted/field_sparse.h	/^	Field(this_type const & that)$/;"	f	struct:simpla::Field
Field	core/field/obsoleted/field_sparse.h	/^struct Field<TM, TV, _impl::is_associative_container> : public SpObject$/;"	s	namespace:simpla
Field	core/field/test/trash/field_continue.h	/^	Field(mesh_type const & d, Args && ...args)$/;"	f	struct:simpla::Field
Field	core/field/test/trash/field_continue.h	/^	Field(this_type & that, Args && ...args)$/;"	f	struct:simpla::Field
Field	core/field/test/trash/field_continue.h	/^	Field(this_type const & that)$/;"	f	struct:simpla::Field
Field	core/field/test/trash/field_continue.h	/^struct Field<TM, TContainer, _impl::is_sequence_container> : public SpObject$/;"	s	namespace:simpla
FieldAMRPolicy	core/field/obsoleted/field_patch.h	/^class FieldAMRPolicy : public mesh::EnablePatchFromThis<TF>$/;"	c	namespace:simpla
FieldTest	core/field/test/field_dummy.cpp	/^class FieldTest: public testing::TestWithParam<TM>$/;"	c	file:
FileInfo	cpplint.py	/^class FileInfo:$/;"	c
FileName	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^    char *FileName;$/;"	m	class:vtkAMRSimPlaReader::pimpl_s	file:
FilesBelongToSameModule	cpplint.py	/^def FilesBelongToSameModule(filename_cc, filename_h):$/;"	f
FillMetaData	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^int vtkAMRSimPlaReader::FillMetaData()$/;"	f	class:vtkAMRSimPlaReader
FilterRange	core/gtl/iterator/sp_range_filter.h	/^	FilterRange(base_range const & r, TPredFun const & pred) :$/;"	f	struct:simpla::FilterRange
FilterRange	core/gtl/iterator/sp_range_filter.h	/^struct FilterRange<BaseRange> : public BaseRange$/;"	s	namespace:simpla
FindBlockIndex	plugins/vtk_reader/vtkAMRSimPlaParticlesReader.cpp	/^static bool FindBlockIndex(hid_t fileIndx, const int blockIdx, hid_t &rootIndx)$/;"	f	file:
FindNextMultiLineCommentEnd	cpplint.py	/^def FindNextMultiLineCommentEnd(lines, lineix):$/;"	f
FindNextMultiLineCommentStart	cpplint.py	/^def FindNextMultiLineCommentStart(lines, lineix):$/;"	f
FiniteVolume	core/manifold/policy/FvmStructuredPolicy.h	/^    FiniteVolume() { }$/;"	f	struct:simpla::manifold::policy::FiniteVolume
FiniteVolume	core/manifold/policy/FvmStructuredPolicy.h	/^struct FiniteVolume$/;"	s	namespace:simpla::manifold::policy
FlushCache	core/gtl/containers/container_cache.h	/^void FlushCache(T & f, Others & ...others)$/;"	f	namespace:simpla
FlushCache	core/gtl/containers/container_cache.h	/^void FlushCache(T &)$/;"	f	namespace:simpla
FlushCache	core/gtl/containers/container_cache.h	/^void FlushCache(T *f)$/;"	f	namespace:simpla
Foo	example/misc/demo_misc.lua	/^Foo=function(x,y)$/;"	f
FullName	cpplint.py	/^  def FullName(self):$/;"	m	class:FileInfo
Fun	scripts/configure/demo2.lua	/^  Fun=function(x,y,z,t)$/;"	f
Function	core/gtl/function.h	/^    Function(TF const &fun) : m_fun_(fun)$/;"	f	class:simpla::Function
Function	core/gtl/function.h	/^    Function(this_type const &other) :$/;"	f	class:simpla::Function
Function	core/gtl/function.h	/^class Function<TV, TFun>$/;"	c	namespace:simpla
FunctionCache	core/gtl/function_cache.h	/^	FunctionCache(function_type const & f) :$/;"	f	struct:simpla::FunctionCache
FunctionCache	core/gtl/function_cache.h	/^struct FunctionCache$/;"	s	namespace:simpla
FunctionCache	core/gtl/function_cache.h	/^struct FunctionCache<RectValue, TFun, void>$/;"	s	namespace:simpla
GEOMETRY_ALGORITHM_H_	core/geometry/GeoAlgorithm.h	9;"	d
GEQDSK	scripts/PreProcess/input_geqdsk.py	/^class GEQDSK(object):$/;"	c
GEQDSK	scripts/geqdsk.py	/^class GEQDSK:$/;"	c
GEQDSK_H_	core/model/GEqdsk.h	9;"	d
GEqdsk	core/model/GEqdsk.cpp	/^GEqdsk::GEqdsk() : m_pimpl_(new pimpl_s) { }$/;"	f	class:simpla::GEqdsk
GEqdsk	core/model/GEqdsk.h	/^class GEqdsk$/;"	c	namespace:simpla
GLOBAL_CLICK_TOUCH	core/base/LifeClick.h	33;"	d
GLOBAL_COMM	core/parallel/MPIComm.h	97;"	d
GLOBAL_DATA_STREAM	core/io/HDF5Stream.h	119;"	d
GLOBAL_IDX_	core/gtl/utilities/lua_object.h	/^        int GLOBAL_IDX_;$/;"	m	class:simpla::lua::LuaObject::iterator
GLOBAL_REF_IDX_	core/gtl/utilities/lua_object.h	/^    int GLOBAL_REF_IDX_;$/;"	m	class:simpla::lua::LuaObject
GeneralMap	core/manifold/mesh/GeneralMap.h	/^    GeneralMap() { }$/;"	f	struct:simpla::mesh::GeneralMap
GeneralMap	core/manifold/mesh/GeneralMap.h	/^struct GeneralMap$/;"	s	namespace:simpla::mesh
Geo	core/geometry/boost_gemetry_adapted.h	/^	typedef sgm::Primitive<N, CS, TAG> Geo;$/;"	t	struct:boost::geometry::traits::access
Geo	core/geometry/boost_gemetry_adapted.h	/^	typedef sgm::Primitive<N, CS, TAG> Geo;$/;"	t	struct:boost::geometry::traits::indexed_access
GeoObject	core/geometry/GeoObject.h	/^    GeoObject() { }$/;"	f	class:simpla::geometry::GeoObject
GeoObject	core/geometry/GeoObject.h	/^class GeoObject$/;"	c	namespace:simpla::geometry
GetAMRGrid	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^vtkUniformGrid *vtkAMRSimPlaReader::GetAMRGrid(const int blockIdx)$/;"	f	class:vtkAMRSimPlaReader
GetAMRGridData	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^void vtkAMRSimPlaReader::GetAMRGridData($/;"	f	class:vtkAMRSimPlaReader
GetAMRGridPointData	plugins/vtk_reader/vtkAMRSimPlaReader.h	/^    void GetAMRGridPointData($/;"	f	class:vtkAMRSimPlaReader
GetAttributeNames	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^void vtkAMRSimPlaReader::pimpl_s::GetAttributeNames()$/;"	f	class:vtkAMRSimPlaReader::pimpl_s
GetBaseDirectory	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^    std::string GetBaseDirectory(const char *path) { return GetSimPlaDirectory(path); };$/;"	f	class:vtkAMRSimPlaReader::pimpl_s
GetBlockAttribute	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^int vtkAMRSimPlaReader::pimpl_s::GetBlockAttribute($/;"	f	class:vtkAMRSimPlaReader::pimpl_s
GetBlockLevel	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^int vtkAMRSimPlaReader::GetBlockLevel(const int blockIdx)$/;"	f	class:vtkAMRSimPlaReader
GetConversionFactor	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^double vtkAMRSimPlaReader::GetConversionFactor(const std::string name)$/;"	f	class:vtkAMRSimPlaReader
GetDoubleArrayByName	plugins/vtk_reader/vtkAMRSimPlaParticlesReader.cpp	/^static void GetDoubleArrayByName($/;"	f	file:
GetHeaderGuardCPPVariable	cpplint.py	/^def GetHeaderGuardCPPVariable(filename):$/;"	f
GetIndexFromArrayName	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^int vtkAMRSimPlaReader::GetIndexFromArrayName(std::string arrayName)$/;"	f	class:vtkAMRSimPlaReader
GetLevelBasedIds	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^void vtkAMRSimPlaReaderBlock::GetLevelBasedIds$/;"	f	class:vtkAMRSimPlaReaderBlock
GetLineWidth	cpplint.py	/^def GetLineWidth(line):$/;"	f
GetNumberOfBlocks	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^int vtkAMRSimPlaReader::GetNumberOfBlocks()$/;"	f	class:vtkAMRSimPlaReader
GetNumberOfLevels	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^int vtkAMRSimPlaReader::GetNumberOfLevels()$/;"	f	class:vtkAMRSimPlaReader
GetParentWiseIds	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^void vtkAMRSimPlaReaderBlock::GetParentWiseIds$/;"	f	class:vtkAMRSimPlaReaderBlock
GetParticles	plugins/vtk_reader/vtkAMRSimPlaParticlesReader.cpp	/^vtkPolyData *vtkAMRSimPlaParticlesReader::GetParticles($/;"	f	class:vtkAMRSimPlaParticlesReader
GetParticlesTypeArray	plugins/vtk_reader/vtkAMRSimPlaParticlesReader.cpp	/^vtkDataArray *vtkAMRSimPlaParticlesReader::GetParticlesTypeArray($/;"	f	class:vtkAMRSimPlaParticlesReader
GetPreviousNonBlankLine	cpplint.py	/^def GetPreviousNonBlankLine(clean_lines, linenum):$/;"	f
GetSimPlaDirectory	plugins/vtk_reader/vtkAMRSimPlaReader.h	/^static std::string GetSimPlaDirectory(const char *path)$/;"	f
GetSimPlaMajorFileName	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^static std::string GetSimPlaMajorFileName(const char *path)$/;"	f	file:
GetTotalNumberOfParticles	plugins/vtk_reader/vtkAMRSimPlaParticlesReader.cpp	/^int vtkAMRSimPlaParticlesReader::GetTotalNumberOfParticles()$/;"	f	class:vtkAMRSimPlaParticlesReader
GetUpdateTimestep	scripts/PostProcesse/particle_time_scripts.py	/^def GetUpdateTimestep(algorithm):$/;"	f
GetValue	core/gtl/type_traits_ext.h	/^struct GetValue$/;"	s	namespace:simpla::_impl
GuidingCenterEngine	core/particle/pre_define/GuidingCenter.h	/^struct GuidingCenterEngine<geometry::CylindricalMetric>$/;"	s	namespace:simpla::particle::engine
GyroParticleWithCylindricalCoord	core/particle/pre_define/PICGyro.h	/^    GyroParticleWithCylindricalCoord(mesh_type &m) : m_mesh_(m) { }$/;"	f	struct:simpla::particle::engine::GyroParticleWithCylindricalCoord
GyroParticleWithCylindricalCoord	core/particle/pre_define/PICGyro.h	/^struct GyroParticleWithCylindricalCoord$/;"	s	namespace:simpla::particle::engine
H5_ERROR	core/io/HDF5Stream.cpp	28;"	d	file:
H5_USE_16_API	plugins/vtk_reader/vtkAMRSimPlaParticlesReader.cpp	29;"	d	file:
H5_USE_16_API	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	18;"	d	file:
HALFPI	core/physics/Constants.h	/^constexpr double HALFPI = 0.50 * PI;$/;"	v
HAS_CONST_MEMBER_FUNCTION	core/gtl/check_concept.h	122;"	d
HAS_CONST_MEMBER_FUNCTION	core/gtl/concept_check.h	115;"	d
HAS_FUNCTION	core/gtl/check_concept.h	172;"	d
HAS_FUNCTION	core/gtl/concept_check.h	165;"	d
HAS_MEMBER	core/gtl/check_concept.h	25;"	d
HAS_MEMBER	core/gtl/concept_check.h	18;"	d
HAS_MEMBER_FUNCTION	core/gtl/check_concept.h	97;"	d
HAS_MEMBER_FUNCTION	core/gtl/concept_check.h	90;"	d
HAS_OPERATOR	core/gtl/check_concept.h	195;"	d
HAS_OPERATOR	core/gtl/concept_check.h	188;"	d
HAS_PROPERTIES	core/gtl/Properties.h	175;"	d
HAS_PROPERTIES	core/io/IOStream.h	/^    HAS_PROPERTIES;$/;"	m	class:simpla::io::IOStream
HAS_PROPERTIES	core/manifold/Manifold.h	/^    HAS_PROPERTIES;$/;"	m	class:simpla::Manifold
HAS_PROPERTIES	core/manifold/mesh/CoRectMesh.h	/^    HAS_PROPERTIES;$/;"	m	struct:simpla::mesh::Mesh
HAS_PROPERTIES	core/particle/ParticleContainer.h	/^    HAS_PROPERTIES;$/;"	m	struct:simpla::particle::ParticleContainer
HAS_STATIC_MEMBER	core/gtl/check_concept.h	65;"	d
HAS_STATIC_MEMBER	core/gtl/concept_check.h	58;"	d
HAS_STATIC_MEMBER_FUNCTION	core/gtl/check_concept.h	147;"	d
HAS_STATIC_MEMBER_FUNCTION	core/gtl/concept_check.h	140;"	d
HAS_STATIC_TYPE_MEMBER	core/gtl/check_concept.h	81;"	d
HAS_STATIC_TYPE_MEMBER	core/gtl/concept_check.h	74;"	d
HAS_TYPE	core/gtl/check_concept.h	220;"	d
HAS_TYPE	core/gtl/concept_check.h	213;"	d
HAS_TYPE_MEMBER	core/gtl/check_concept.h	41;"	d
HAS_TYPE_MEMBER	core/gtl/concept_check.h	34;"	d
HDF5Stream	core/io/HDF5Stream.cpp	/^HDF5Stream::HDF5Stream() : m_pimpl_(new pimpl_s) { }$/;"	f	class:simpla::io::HDF5Stream
HDF5Stream	core/io/HDF5Stream.h	/^class HDF5Stream : public IOStream$/;"	c	namespace:simpla::io
HEAD_DIGITS	core/manifold/mesh/MeshIds.h	/^    static constexpr int HEAD_DIGITS = (FULL_DIGITS - ID_DIGITS * 3);$/;"	m	struct:simpla::mesh::MeshEntityIdCoder
Hash	core/particle/ParticleContainer.h	/^    struct Hash$/;"	s	struct:simpla::particle::ParticleContainer
HierarchyFileName	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^    std::string HierarchyFileName;$/;"	m	class:vtkAMRSimPlaReader::pimpl_s	file:
HodgeStar	core/manifold/Calculus.h	/^struct HodgeStar$/;"	s	namespace:simpla::calculus::tags
ICDF_DISTRIBUTION_H_	core/numeric/icdf_distribution.h	9;"	d
IDENTIFY	core/gtl/utilities/logo.cpp	17;"	d	file:
ID_DIGITS	core/manifold/mesh/MeshIds.h	/^    static constexpr int ID_DIGITS = 21;$/;"	m	struct:simpla::mesh::MeshEntityIdCoder
ID_DIGITS	core/manifold/mesh/MeshIds.h	/^template<int L> constexpr int MeshEntityIdCoder<L>::ID_DIGITS;$/;"	m	class:simpla::mesh::MeshEntityIdCoder
ID_MASK	core/manifold/mesh/MeshIds.h	/^    static constexpr id_type ID_MASK = (1UL << ID_DIGITS) - 1;$/;"	m	struct:simpla::mesh::MeshEntityIdCoder
ID_MASK	core/manifold/mesh/MeshIds.h	/^template<int L> constexpr typename MeshEntityIdCoder<L>::id_type MeshEntityIdCoder<L>::ID_MASK;$/;"	m	class:simpla::mesh::MeshEntityIdCoder
ID_ZERO	core/manifold/mesh/MeshIds.h	/^    static constexpr id_type ID_ZERO = INDEX_ZERO | (INDEX_ZERO << ID_DIGITS)$/;"	m	struct:simpla::mesh::MeshEntityIdCoder
ID_ZERO	core/manifold/mesh/MeshIds.h	/^template<int L> constexpr typename MeshEntityIdCoder<L>::id_type MeshEntityIdCoder<L>::ID_ZERO;$/;"	m	class:simpla::mesh::MeshEntityIdCoder
IForm	applications/particle_solver/fluid_cold_engine.h	/^	static constexpr std::size_t IForm = VERTEX;$/;"	m	class:simpla::Particle
IMPLICITPUSHE_H_	applications/field_solver/implicitPushE.h	9;"	d
INCLUDE_SINGLETON_HOLDER_H_	core/gtl/design_pattern/singleton_holder.h	10;"	d
INDEX_ZERO	core/manifold/mesh/MeshIds.h	/^    static constexpr id_type INDEX_ZERO = (1UL) << (ID_DIGITS - 2);$/;"	m	struct:simpla::mesh::MeshEntityIdCoder
INDEX_ZERO	core/manifold/mesh/MeshIds.h	/^template<int L> constexpr typename MeshEntityIdCoder<L>::id_type MeshEntityIdCoder<L>::INDEX_ZERO;$/;"	m	class:simpla::mesh::MeshEntityIdCoder
INFORM	core/gtl/utilities/log.h	320;"	d
INFORM2	core/gtl/utilities/log.h	416;"	d
INIFITY	core/gtl/primitives.h	/^static constexpr Real INIFITY = std::numeric_limits<Real>::infinity();$/;"	m	namespace:simpla
INPUT_VALUE	core/model/GEqdsk.cpp	157;"	d	file:
INPUT_VALUE	core/model/GEqdsk.cpp	182;"	d	file:
INSIDE	core/model/Constraint.h	/^    INSIDE = 1, OUTSIDE = 2, ON_SURFACE = 4$/;"	e	enum:simpla::model::__anon10
INTEGRATION_H_	core/numeric/integration.h	9;"	d
INTERPOLATION_H_	core/numeric/interpolation.h	9;"	d
INVERSE_FUNCTION_H_	core/numeric/inverse_function.h	9;"	d
IOPolicy	core/manifold/policy/IOPolicy.h	/^    IOPolicy(IOPolicy const &other) : m_geo_(other.m_geo_) { }$/;"	f	struct:simpla::manifold::policy::IOPolicy
IOPolicy	core/manifold/policy/IOPolicy.h	/^    IOPolicy(geometry_type &geo) : m_geo_(geo) { }$/;"	f	struct:simpla::manifold::policy::IOPolicy
IOPolicy	core/manifold/policy/IOPolicy.h	/^struct IOPolicy<TGeo> : public io::XDMFStream$/;"	s	namespace:simpla::manifold::policy
IOStream	core/io/IOStream.cpp	/^IOStream::IOStream()$/;"	f	class:simpla::io::IOStream
IOStream	core/io/IOStream.h	/^class IOStream : public base::Object$/;"	c	namespace:simpla::io
ITERATOR_CACHED_H_	core/gtl/iterator/sp_iterator_cached.h	9;"	d
ITERATOR_SHARED_CONTAINER_H_	core/gtl/iterator/sp_iterator_shared_container.h	9;"	d
IVec3	core/gtl/primitives.h	/^typedef nTuple<Integral, 3> IVec3;$/;"	t	namespace:simpla
I_CARTESIAN_ZAXIS	core/geometry/csCartesian.h	/^    static constexpr int I_CARTESIAN_ZAXIS = 2;$/;"	m	struct:simpla::geometry::CartesianMetric
Identity	core/gtl/expression_template.h	/^struct Identity$/;"	s	namespace:simpla
ImplicitFunction	core/geometry/implicit_function.h	/^	ImplicitFunction(function_type const &fun) :$/;"	f	class:simpla::ImplicitFunction
ImplicitFunction	core/geometry/implicit_function.h	/^class ImplicitFunction<TF>$/;"	c	namespace:simpla
ImplicitFunction	core/geometry/implicit_function.h	/^struct ImplicitFunction<Expression<_impl::logical_and, TL, TR>> : public Expression<$/;"	s	namespace:simpla
ImplicitFunction	core/geometry/implicit_function.h	/^struct ImplicitFunction<Expression<_impl::logical_not, TL, std::nullptr_t>> : public Expression<$/;"	s	namespace:simpla
ImplicitFunction	core/geometry/implicit_function.h	/^struct ImplicitFunction<Expression<_impl::logical_or, TL, TR>> : public Expression<$/;"	s	namespace:simpla
ImplicitFunction	core/geometry/implicit_function.h	/^struct ImplicitFunction<Expression<_impl::minus, TL, TR>> : public Expression<$/;"	s	namespace:simpla
ImplicitFunction	core/geometry/implicit_function.h	/^struct ImplicitFunction<Expression<_impl::negate, TL, std::nullptr_t>> : public Expression<$/;"	s	namespace:simpla
ImplicitFunction	core/geometry/implicit_function.h	/^struct ImplicitFunction<Expression<_impl::plus, TL, TR>> : public Expression<$/;"	s	namespace:simpla
ImplicitFunction	core/geometry/obsolete/geometry_object.h	/^	ImplicitFunction(nTuple<Real, 3> const & x0, Real radius)$/;"	f	struct:simpla::geometry_object::ImplicitFunction
ImplicitFunction	core/geometry/obsolete/geometry_object.h	/^struct ImplicitFunction<Sphere>$/;"	s	namespace:simpla::geometry_object
ImplicitPushE	applications/field_solver/implicitPushE.h	/^    ImplicitPushE(std::shared_ptr<mesh_type> const &m, Others const &...) :$/;"	f	class:simpla::ImplicitPushE
ImplicitPushE	applications/field_solver/implicitPushE.h	/^class ImplicitPushE$/;"	c	namespace:simpla
IncrementErrorCount	cpplint.py	/^  def IncrementErrorCount(self, category):$/;"	m	class:_CppLintState
Index	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^    int Index;$/;"	m	class:vtkAMRSimPlaReaderBlock	file:
Infinity	core/gtl/expression_template.h	/^struct Infinity$/;"	s	namespace:simpla
Init	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^void vtkAMRSimPlaReader::pimpl_s::Init()$/;"	f	class:vtkAMRSimPlaReader::pimpl_s
Init	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^void vtkAMRSimPlaReaderBlock::Init()$/;"	f	class:vtkAMRSimPlaReaderBlock
InitB0	scripts/configure/cold_plasma.lua	/^InitB0=function(x,y,z)$/;"	f
InitB0	scripts/configure/demo2.lua	/^InitB0=function(x,y,z)$/;"	f
InitB0	scripts/configure/demo_gfile.lua	/^InitB0=function(x,y,z)$/;"	f
InitB0	scripts/configure/icrf.lua	/^InitB0=function(x,y,z)$/;"	f
InitB0 	scripts/configure/test.lua	/^InitB0 = function(x)$/;"	f
InitN0	scripts/configure/cold_plasma.lua	/^InitN0=function(x,y,z)$/;"	f
InitN0	scripts/configure/demo2.lua	/^InitN0=function(x,y,z)      $/;"	f
InitN0	scripts/configure/demo2.lua	/^InitN0=function(x,y,z)$/;"	f
InitN0	scripts/configure/demo_gfile.lua	/^InitN0=function(x,y,z)      $/;"	f
InitN0	scripts/configure/demo_gfile.lua	/^InitN0=function(x,y,z)$/;"	f
InitN0	scripts/configure/icrf.lua	/^InitN0=function(x,y,z)$/;"	f
InitN0 	scripts/configure/test.lua	/^InitN0 = function(x)$/;"	f
InitPECboundary	applications/contexts/explicit_em.h	/^void ExplicitEMContext<TM>::InitPECboundary()$/;"	f	class:simpla::ExplicitEMContext
InsertDataItem	core/io/XDMFIO.cpp	/^void InsertDataItem(XdmfDataItem *dataitem, int rank, XdmfInt64 const *dims, DataType const &dtype,$/;"	f	namespace:simpla::io
InsertDataItem	core/io/XDMFIO.h	/^InsertDataItem(XdmfDataItem *dataitem, int rank, XdmfInt64 const *dims,$/;"	f	namespace:simpla::io
InsertDataItem	core/io/XDMFIO.h	/^InsertDataItem(XdmfDataItem *dataitem, size_t num, T *data,$/;"	f	namespace:simpla::io
InsertDataItemWithFun	core/io/XDMFIO.h	/^InsertDataItemWithFun(XdmfDataItem *dataitem, unsigned int rank,$/;"	f	namespace:simpla::io
Integral	core/gtl/primitives.h	/^typedef long Integral;$/;"	t	namespace:simpla
Integrate	core/numeric/integration.h	/^Integrate(std::map<TX, TY> const & xy)$/;"	f	namespace:simpla
InteriorProduct	core/manifold/Calculus.h	/^struct InteriorProduct$/;"	s	namespace:simpla::calculus::tags
Interpolation	core/numeric/interpolation.h	/^    Interpolation(Args &&...args) :$/;"	f	class:simpla::Interpolation
Interpolation	core/numeric/interpolation.h	/^    Interpolation(TC const &y, Args &&...args) :$/;"	f	class:simpla::Interpolation
Interpolation	core/numeric/interpolation.h	/^    Interpolation(std::shared_ptr<container_type> y, Args &&...args) :$/;"	f	class:simpla::Interpolation
Interpolation	core/numeric/interpolation.h	/^class Interpolation$/;"	c	namespace:simpla
Inverse	core/numeric/inverse_function.h	/^std::map<TY, TX> Inverse(std::map<TX, TY> const & xy)$/;"	f	namespace:simpla
IsBlankLine	cpplint.py	/^def IsBlankLine(line):$/;"	f
IsCppString	cpplint.py	/^def IsCppString(line):$/;"	f
IsErrorSuppressedByNolint	cpplint.py	/^def IsErrorSuppressedByNolint(category, linenum):$/;"	f
IsInAlphabeticalOrder	cpplint.py	/^  def IsInAlphabeticalOrder(self, header_path):$/;"	m	class:_IncludeState
IsReady	plugins/vtk_reader/vtkAMRSimPlaReader.h	/^    bool IsReady;$/;"	m	class:vtkAMRSimPlaReader
IsSource	cpplint.py	/^  def IsSource(self):$/;"	m	class:FileInfo
Iterator	core/gtl/iterator/sp_iterator_index_base.h	/^	Iterator()$/;"	f	class:simpla::Iterator
Iterator	core/gtl/iterator/sp_iterator_index_base.h	/^class Iterator<T*, std::nullptr_t, std::nullptr_t> : public std::iterator<std::bidirectional_iterator_tag, T>$/;"	c	namespace:simpla
Iterator	core/gtl/iterator/sp_iterator_mapped.h	/^	Iterator( key_iterator const & ib, key_iterator const& ,storage_type d)$/;"	f	struct:simpla::Iterator
Iterator	core/gtl/iterator/sp_iterator_mapped.h	/^	Iterator() :$/;"	f	struct:simpla::Iterator
Iterator	core/gtl/iterator/sp_iterator_mapped.h	/^	Iterator()$/;"	f	struct:simpla::Iterator
Iterator	core/gtl/iterator/sp_iterator_mapped.h	/^	Iterator(key_iterator const & ib, key_iterator ie, storage_type d) :$/;"	f	struct:simpla::Iterator
Iterator	core/gtl/iterator/sp_iterator_mapped.h	/^	Iterator(this_type const & other) :$/;"	f	struct:simpla::Iterator
Iterator	core/gtl/iterator/sp_iterator_mapped.h	/^	Iterator(this_type const & other)$/;"	f	struct:simpla::Iterator
Iterator	core/gtl/iterator/sp_iterator_mapped.h	/^struct Iterator<TIterator, TContainer, _iterator_policy_mapped, IsReference>$/;"	s	namespace:simpla
Iterator	core/gtl/iterator/sp_iterator_mapped.h	/^struct Iterator<TIterator, std::map<TKey, TMapped>, _iterator_policy_mapped,$/;"	s	namespace:simpla
IteratorConvert	core/gtl/iterator/sp_iterator_shared_container.h	/^struct IteratorConvert<T**, T*>$/;"	s	namespace:simpla::_impl
IteratorConvert	core/gtl/iterator/sp_iterator_shared_container.h	/^struct IteratorConvert<T, T>$/;"	s	namespace:simpla::_impl
IteratorSequence	core/gtl/iterator/iterator_sequence.h	/^	IteratorSequence()$/;"	f	class:simpla::IteratorSequence
IteratorSequence	core/gtl/iterator/iterator_sequence.h	/^	IteratorSequence(value_type const & ib) :$/;"	f	class:simpla::IteratorSequence
IteratorSequence	core/gtl/iterator/iterator_sequence.h	/^class IteratorSequence$/;"	c	namespace:simpla
J	applications/particle_solver/fluid_cold_engine.h	/^	J_type J;$/;"	m	class:simpla::Particle
J1	applications/contexts/explicit_em.h	/^    field<scalar_type, EDGE> J1; \/\/!< current density$/;"	m	struct:simpla::ExplicitEMContext
J1	core/phy_solver/em_fluid.h	/^        traits::field_t<vector_type, mesh_type, VERTEX> J1;$/;"	m	struct:simpla::phy_solver::EMFluid::fluid_s
J1	example/em_tokamak/tokamak.cpp	/^        traits::field_t<vector_type, mesh_type, VERTEX> J1;$/;"	m	struct:simpla::EMTokamak::fluid_s	file:
JSrc	scripts/configure/3D.lua	/^function JSrc(t)             $/;"	f
JT	core/model/GEqdsk.h	/^    inline Real JT(Real R, Real Z) const$/;"	f	class:simpla::GEqdsk
JT	core/model/GEqdsk.h	/^    inline Real JT(point_type const &x) const$/;"	f	class:simpla::GEqdsk
J_at_the_center	applications/particle_solver/pic_engine_deltaf.h	/^	int J_at_the_center;$/;"	m	struct:simpla::ParticleEngine
J_src	core/phy_solver/em_fluid.h	/^    model::IdSet<mesh_type> J_src;$/;"	m	class:simpla::phy_solver::EMFluid
J_src	example/em_tokamak/tokamak.cpp	/^    model::IdSet<mesh_type> J_src;$/;"	m	struct:simpla::EMTokamak	file:
J_src_fun	core/phy_solver/em_fluid.h	/^    std::function<Vec3(Real, point_type const &)> J_src_fun;$/;"	m	class:simpla::phy_solver::EMFluid
J_src_fun	example/em_tokamak/tokamak.cpp	/^    std::function<Vec3(Real, point_type const &)> J_src_fun;$/;"	m	struct:simpla::EMTokamak	file:
J_type	applications/contexts/explicit_em.h	/^    typedef decltype(J1) J_type;$/;"	t	struct:simpla::ExplicitEMContext
J_type	applications/field_solver/implicitPushE.h	/^    typedef field<nTuple<scalar_type, 3>, VERTEX> J_type;$/;"	t	class:simpla::ImplicitPushE
J_type	applications/particle_solver/fluid_cold_engine.h	/^	typedef typename mesh_type:: template field<VERTEX, nTuple<scalar_type, 3>> J_type;$/;"	t	class:simpla::Particle
J_type	applications/particle_solver/pic_engine_implicit.h	/^	typedef typename mesh_type:: template field<VERTEX, nTuple<3, scalar_type>> J_type;$/;"	t	struct:simpla::PICEngineImplicit
Jext	applications/contexts/explicit_em.h	/^    field<Real, EDGE> Jext; \/\/!< external current$/;"	m	struct:simpla::ExplicitEMContext
KINETIC_PARTICLE_TEST_H_	core/particle/test/kinetic_particle_test.h	9;"	d
KSP_CG_H_	core/numeric/ksp_cg.h	9;"	d
K_	core/physics/PhysicalConstants.h	/^    double K_;    \/\/<< temperature [kelvin]$/;"	m	class:simpla::PhysicalConstants
K_imag	core/field/test/field_diff_calculus_test.h	/^    nTuple<scalar_type, 3> K_imag;$/;"	m	class:FETLTest
K_imag	core/field/test/trash/fetl_test3.h	/^	nTuple<3, scalar_type> K_imag;$/;"	m	class:TestFETL
K_real	core/field/test/field_diff_calculus_test.h	/^    nTuple<Real, 3> K_real; \/\/ @NOTE must   k = n TWOPI, period condition$/;"	m	class:FETLTest
K_real	core/field/test/trash/fetl_test3.h	/^	nTuple<3, Real> K_real; \/\/ @NOTE must   k = n TWOPI, period condition$/;"	m	class:TestFETL
KineticParticle	core/particle/obsolete/kinetic_particle.h	/^KineticParticle<Engine, TDomain>::KineticParticle(domain_type const &pdomain,$/;"	f	class:KineticParticle
KineticParticle	core/particle/obsolete/kinetic_particle.h	/^struct KineticParticle : public Particle<TDomain, Engine>$/;"	s
LEFT_COLUMN	core/gtl/utilities/log.h	414;"	d
LIMITER	core/model/obsoleted/model.h	/^        LIMITER = 1UL << 5,$/;"	e	enum:simpla::Model::__anon9
LOAD_MODEL_H_	core/geometry/obsolete/load_model.h	9;"	d
LOAD_PARTICLE_H_	core/particle/obsolete/load_particle.h	9;"	d
LOGGER	core/gtl/utilities/log.h	342;"	d
LOGIC_ERROR	core/gtl/utilities/log.h	354;"	d
LOG_CMD	core/gtl/utilities/log.h	426;"	d
LOG_CMD1	core/gtl/utilities/log.h	430;"	d
LOG_CMD2	core/gtl/utilities/log.h	432;"	d
LOG_DEBUG	core/gtl/utilities/log.h	/^    LOG_DEBUG = -30           \/\/!< LOG_DEBUG$/;"	e	enum:simpla::logger::tags
LOG_ERROR	core/gtl/utilities/log.h	/^    LOG_ERROR = -2,           \/\/!< LOG_ERROR$/;"	e	enum:simpla::logger::tags
LOG_ERROR_BAD_CAST	core/gtl/utilities/log.h	/^    LOG_ERROR_BAD_CAST = -11,   \/\/!< LOG_ERROR_RUNTIME$/;"	e	enum:simpla::logger::tags
LOG_ERROR_LOGICAL	core/gtl/utilities/log.h	/^    LOG_ERROR_LOGICAL = -13,   \/\/!< LOG_ERROR_RUNTIME$/;"	e	enum:simpla::logger::tags
LOG_ERROR_OUT_OF_RANGE	core/gtl/utilities/log.h	/^    LOG_ERROR_OUT_OF_RANGE = -12,   \/\/!< LOG_ERROR_RUNTIME$/;"	e	enum:simpla::logger::tags
LOG_ERROR_RUNTIME	core/gtl/utilities/log.h	/^    LOG_ERROR_RUNTIME = -10,   \/\/!< LOG_ERROR_RUNTIME$/;"	e	enum:simpla::logger::tags
LOG_FORCE_OUTPUT	core/gtl/utilities/log.h	/^    LOG_FORCE_OUTPUT = -10000, \/\/!< LOG_FORCE_OUTPUT$/;"	e	enum:simpla::logger::tags
LOG_H_	core/gtl/utilities/log.h	18;"	d
LOG_INFORM	core/gtl/utilities/log.h	/^    LOG_INFORM = 0,           \/\/!< LOG_INFORM$/;"	e	enum:simpla::logger::tags
LOG_LOG	core/gtl/utilities/log.h	/^    LOG_LOG = 1,              \/\/!< LOG_LOG$/;"	e	enum:simpla::logger::tags
LOG_LOGIC_ERROR	core/gtl/utilities/log.h	/^    LOG_LOGIC_ERROR = -3,     \/\/!< LOG_LOGIC_ERROR$/;"	e	enum:simpla::logger::tags
LOG_MESSAGE	core/gtl/utilities/log.h	/^    LOG_MESSAGE = -20,        \/\/!< LOG_MESSAGE$/;"	e	enum:simpla::logger::tags
LOG_OUT_RANGE_ERROR	core/gtl/utilities/log.h	/^    LOG_OUT_RANGE_ERROR = -4, \/\/!< LOG_OUT_RANGE_ERROR$/;"	e	enum:simpla::logger::tags
LOG_VERBOSE	core/gtl/utilities/log.h	/^    LOG_VERBOSE = 10,         \/\/!< LOG_VERBOSE$/;"	e	enum:simpla::logger::tags
LOG_WARNING	core/gtl/utilities/log.h	/^    LOG_WARNING = -1,         \/\/!< LOG_WARNING$/;"	e	enum:simpla::logger::tags
LUA_ERROR	core/gtl/utilities/lua_object.h	49;"	d
L_	core/gtl/utilities/lua_object.h	/^        LuaState L_;$/;"	m	class:simpla::lua::LuaObject::iterator
L_	core/gtl/utilities/lua_object.h	/^    LuaState L_;$/;"	m	class:simpla::lua::LuaObject
Level	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^    int Level;$/;"	m	class:vtkAMRSimPlaReaderBlock	file:
LifeClick	core/base/LifeClick.h	/^struct LifeClick$/;"	s	namespace:simpla::base
LinearInterpolation	core/numeric/interpolation.h	/^struct LinearInterpolation$/;"	s	namespace:simpla
LinearInterpolator	core/manifold/policy/LinearInterpolatorPolicy.h	/^    LinearInterpolator() { }$/;"	f	struct:simpla::manifold::policy::LinearInterpolator
LinearInterpolator	core/manifold/policy/LinearInterpolatorPolicy.h	/^struct LinearInterpolator$/;"	s	namespace:simpla::manifold::policy
LinearMap	core/manifold/mesh/LinearMap.h	/^    LinearMap() { }$/;"	f	struct:simpla::mesh::LinearMap
LinearMap	core/manifold/mesh/LinearMap.h	/^struct LinearMap$/;"	s	namespace:simpla::mesh
LoadAttribute	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^int vtkAMRSimPlaReader::pimpl_s::LoadAttribute(const char *atribute, int blockIdx)$/;"	f	class:vtkAMRSimPlaReader::pimpl_s
Logger	core/gtl/utilities/log.cpp	/^Logger::Logger() : base_type(), m_level_(0), current_line_char_count_(0), endl_(true) { }$/;"	f	class:simpla::logger::Logger
Logger	core/gtl/utilities/log.cpp	/^Logger::Logger(int lv)$/;"	f	class:simpla::logger::Logger
Logger	core/gtl/utilities/log.h	/^class Logger : public std::ostringstream$/;"	c	namespace:simpla::logger
LoggerStreamManipulator	core/gtl/utilities/log.h	/^    typedef Logger &(*LoggerStreamManipulator)(Logger &);$/;"	t	class:simpla::logger::Logger
LoggerStreams	core/gtl/utilities/log.cpp	/^    LoggerStreams(int level = LOG_INFORM)$/;"	f	struct:simpla::logger::LoggerStreams
LoggerStreams	core/gtl/utilities/log.cpp	/^struct LoggerStreams \/\/: public SingletonHolder<LoggerStreams>$/;"	s	namespace:simpla::logger	file:
LuaObject	core/gtl/utilities/lua_object.cpp	/^LuaObject::LuaObject() : self_(0), GLOBAL_REF_IDX_(0) { }$/;"	f	class:simpla::lua::LuaObject
LuaObject	core/gtl/utilities/lua_object.cpp	/^LuaObject::LuaObject(LuaObject &&r) :$/;"	f	class:simpla::lua::LuaObject
LuaObject	core/gtl/utilities/lua_object.cpp	/^LuaObject::LuaObject(LuaObject const &other)$/;"	f	class:simpla::lua::LuaObject
LuaObject	core/gtl/utilities/lua_object.cpp	/^LuaObject::LuaObject(std::shared_ptr<LuaState::lua_s> const &l, int G, int s, std::string const &path) :$/;"	f	class:simpla::lua::LuaObject
LuaObject	core/gtl/utilities/lua_object.h	/^class LuaObject$/;"	c	namespace:simpla::lua
LuaState	core/gtl/utilities/lua_object.h	/^        LuaState() : m_l_(nullptr) { }$/;"	f	struct:simpla::lua::LuaObject::LuaState
LuaState	core/gtl/utilities/lua_object.h	/^        LuaState(LuaState const &other) : m_l_(other.m_l_) { }$/;"	f	struct:simpla::lua::LuaObject::LuaState
LuaState	core/gtl/utilities/lua_object.h	/^        LuaState(std::shared_ptr<lua_s> const &other) : m_l_(other) { }$/;"	f	struct:simpla::lua::LuaObject::LuaState
LuaState	core/gtl/utilities/lua_object.h	/^    struct LuaState$/;"	s	class:simpla::lua::LuaObject
MAKE_ERROR_MSG	core/gtl/utilities/log.h	311;"	d
MAXBIT	core/numeric/sobol_engine.h	/^	static const  unsigned int  MAXBIT = sizeof(result_type) * 8;$/;"	m	class:simpla::sobol_engine
MAXDIM	core/numeric/sobol_engine.h	/^	static const  unsigned int  MAXDIM = 6;$/;"	m	class:simpla::sobol_engine
MAXSIZE	core/geometry/obsolete/line_cliping.h	/^	size_t MAXSIZE = 1000; \/* maximum size of pnt2d array *\/$/;"	m	class:simpla::polygon_clip
MAX_BLOCK_SIZE	core/gtl/utilities/memory_pool.cpp	/^    static constexpr size_t MAX_BLOCK_SIZE = 4 * ONE_GIGA; \/\/std::numeric_limits<size_t>::max();$/;"	m	struct:simpla::MemoryPool::pimpl_s	file:
MAX_NDIMS_OF_ARRAY	core/gtl/primitives.h	/^static constexpr unsigned int MAX_NDIMS_OF_ARRAY = 8;$/;"	m	namespace:simpla
MAX_NUM_OF_ADJACENT_CELL	core/manifold/mesh/MeshIds.h	/^    static constexpr int MAX_NUM_OF_ADJACENT_CELL = 12;$/;"	m	struct:simpla::mesh::MeshEntityIdCoder
MAX_NUM_OF_MEDIA_TYPE	core/model/obsoleted/model.h	/^    static constexpr int MAX_NUM_OF_MEDIA_TYPE = std::numeric_limits<tag_type>::digits;$/;"	m	class:simpla::Model
MAX_NUM_OF_NEIGHBOURS	core/manifold/mesh/MeshIds.h	/^    static constexpr int MAX_NUM_OF_NEIGHBOURS = 12;$/;"	m	struct:simpla::mesh::MeshEntityIdCoder
MAX_NUM_OF_VERTEX	core/manifold/obsoleted/block.h	/^    static constexpr int MAX_NUM_OF_VERTEX = 8;$/;"	m	struct:simpla::Block
MESH_COORDINATES_FACTOR	core/manifold/mesh/MeshIds.h	/^    static constexpr Real MESH_COORDINATES_FACTOR = 1.0 \/ COORDINATES_MESH_FACTOR;$/;"	m	struct:simpla::mesh::MeshEntityIdCoder
MESH_RESOLUTION	core/manifold/mesh/MeshIds.h	/^    static constexpr int MESH_RESOLUTION = 1;$/;"	m	struct:simpla::mesh::MeshEntityIdCoder
MESH_RESOLUTION	core/manifold/mesh/MeshIds.h	/^template<int L> constexpr int MeshEntityIdCoder<L>::MESH_RESOLUTION;$/;"	m	class:simpla::mesh::MeshEntityIdCoder
MESSAGE	core/gtl/utilities/log.h	344;"	d
MIN_BLOCK_SIZE	core/gtl/utilities/memory_pool.cpp	/^    static constexpr size_t MIN_BLOCK_SIZE = 256;$/;"	m	struct:simpla::MemoryPool::pimpl_s	file:
MODEL_H_	core/model/obsoleted/model.h	9;"	d
MPIComm	core/parallel/MPIComm.cpp	/^MPIComm::MPIComm()$/;"	f	class:simpla::parallel::MPIComm
MPIComm	core/parallel/MPIComm.cpp	/^MPIComm::MPIComm(int argc, char **argv)$/;"	f	class:simpla::parallel::MPIComm
MPIComm	core/parallel/MPIComm.h	/^class MPIComm$/;"	c	namespace:simpla::parallel
MPIDataType	core/parallel/MPIDataType.cpp	/^MPIDataType::MPIDataType()$/;"	f	class:simpla::MPIDataType
MPIDataType	core/parallel/MPIDataType.cpp	/^MPIDataType::MPIDataType(MPIDataType const &other)$/;"	f	class:simpla::MPIDataType
MPIDataType	core/parallel/MPIDataType.h	/^struct MPIDataType$/;"	s	namespace:simpla
MPI_AUX_FUNCTIONS_H_	core/parallel/MPIAuxFunctions.h	9;"	d
MPI_COMM_H_	core/parallel/MPIComm.h	9;"	d
MPI_DATATYPE_H_	core/parallel/MPIDataType.h	9;"	d
MPI_ERROR	core/parallel/MPIComm.h	99;"	d
MULTI_NORMAL_DISTRIBUTION_H_	core/numeric/multi_normal_distribution.h	9;"	d
MULTI_THREAD_OPENMP_H_	core/parallel/obsoleted/multi_thread_openmp.h	9;"	d
MULTI_THREAD_STD_THREAD_H_	core/parallel/obsoleted/multi_thread_std_thread.h	9;"	d
MULTI_THREAD_TBB_H_	core/parallel/obsoleted/multi_thread_tbb.h	9;"	d
M_Clip	core/geometry/obsolete/line_cliping.h	/^	void M_Clip(pnt2ds &inpts, size_t numin, pnt2ds & outpts, size_t &numout)$/;"	f	class:simpla::polygon_clip
MagneticFLux	core/geometry/CoordinateSystem.h	/^struct MagneticFLux$/;"	s	namespace:simpla::geometry::coordinate_system
MajorFileName	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^    std::string MajorFileName;$/;"	m	class:vtkAMRSimPlaReader::pimpl_s	file:
MakeICDF	core/numeric/icdf_distribution.h	/^inline TIntepolation MakeICDF(std::map<double, double> const &fun)$/;"	f	namespace:simpla
Manifold	core/manifold/Manifold.h	/^    Manifold() : Policies<mesh_type>(dynamic_cast<mesh_type &>(*this))... { }$/;"	f	class:simpla::Manifold
Manifold	core/manifold/Manifold.h	/^class Manifold$/;"	c	namespace:simpla
Manifold	core/manifold/obsoleted/ebmesh.h	/^struct Manifold<TMesh, tags::embedded> : public TMesh$/;"	s	namespace:simpla
ManifoldTypeID	core/manifold/ManifoldTraits.h	/^enum ManifoldTypeID$/;"	g	namespace:simpla
MapTo	core/manifold/Calculus.h	/^struct MapTo$/;"	s	namespace:simpla::calculus::tags
Match	cpplint.py	/^def Match(pattern, s):$/;"	f
MaxBounds	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^    double MaxBounds[3];$/;"	m	class:vtkAMRSimPlaReaderBlock	file:
MaxLevelBasedIds	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^    int MaxLevelBasedIds[3];$/;"	m	class:vtkAMRSimPlaReaderBlock	file:
MaxParentWiseIds	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^    int MaxParentWiseIds[3];$/;"	m	class:vtkAMRSimPlaReaderBlock	file:
Maxwell s equations}
MemoryPool	core/gtl/utilities/memory_pool.cpp	/^MemoryPool::MemoryPool() :$/;"	f	class:simpla::MemoryPool
MemoryPool	core/gtl/utilities/memory_pool.h	/^class MemoryPool$/;"	c	namespace:simpla
Mesh	core/manifold/mesh/CoRectMesh.h	/^    Mesh() : block_type() { }$/;"	f	struct:simpla::mesh::Mesh
Mesh	core/manifold/mesh/CoRectMesh.h	/^struct Mesh<TMetric, tags::corect_linear> : public TMetric, public MeshBlock$/;"	s	namespace:simpla::mesh
Mesh	core/manifold/mesh/RectMesh.h	/^    Mesh() : block_type() { }$/;"	f	struct:simpla::mesh::Mesh
Mesh	core/manifold/mesh/RectMesh.h	/^struct Mesh<TMetric, tags::rect_linear> : public TMetric, public MeshBlock$/;"	s	namespace:simpla::mesh
MeshBlock	core/manifold/mesh/MeshBlock.cpp	/^MeshBlock::MeshBlock() { }$/;"	f	class:simpla::mesh::MeshBlock
MeshBlock	core/manifold/mesh/MeshBlock.h	/^struct MeshBlock : public MeshIDs, public base::Object$/;"	s	namespace:simpla::mesh
MeshCoarsen	core/manifold/obsoleted/mesh_graph.h	/^struct MeshCoarsen : public MeshMapEdge$/;"	s	namespace:simpla::mesh
MeshIDs	core/manifold/mesh/MeshIds.h	/^typedef MeshEntityIdCoder<4> MeshIDs;$/;"	t	namespace:simpla::mesh
MeshEntityIdCoder	core/manifold/mesh/MeshIds.h	/^struct MeshEntityIdCoder$/;"	s	namespace:simpla::mesh
MeshMapEdge	core/manifold/obsoleted/mesh_graph.h	/^struct MeshMapEdge$/;"	s	namespace:simpla::mesh
MeshPatch	core/manifold/obsoleted/patch/mesh_patch.h	/^MeshPatch<TM>::MeshPatch() { }$/;"	f	class:simpla::mesh::MeshPatch
MeshPatch	core/manifold/obsoleted/patch/mesh_patch.h	/^class MeshPatch$/;"	c	namespace:simpla::mesh
MeshRefinement	core/manifold/obsoleted/mesh_graph.h	/^struct MeshRefinement : public MeshMapEdge$/;"	s	namespace:simpla::mesh
MeshTransform	core/manifold/obsoleted/mesh_graph.h	/^struct MeshTransform : public MeshMapEdge$/;"	s	namespace:simpla::mesh
Metric	core/geometry/csCylindrical.h	/^struct Metric<coordinate_system::template Cylindrical<IPhiAxis> >$/;"	s	namespace:simpla::geometry
MinBounds	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^    double MinBounds[3];$/;"	m	class:vtkAMRSimPlaReaderBlock	file:
MinLevelBasedIds	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^    int MinLevelBasedIds[3];$/;"	m	class:vtkAMRSimPlaReaderBlock	file:
MinParentWiseIds	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^    int MinParentWiseIds[3];$/;"	m	class:vtkAMRSimPlaReaderBlock	file:
Model	core/model/obsoleted/model.h	/^    Model(Block const &geo)$/;"	f	class:simpla::Model
Model	core/model/obsoleted/model.h	/^class Model$/;"	c	namespace:simpla
MultiDimesionInterpolation	core/numeric/interpolation.h	/^    MultiDimesionInterpolation(Args &&...args) :$/;"	f	class:simpla::MultiDimesionInterpolation
MultiDimesionInterpolation	core/numeric/interpolation.h	/^    MultiDimesionInterpolation(std::shared_ptr<value_type> y, Args &&...args) :$/;"	f	class:simpla::MultiDimesionInterpolation
MultiDimesionInterpolation	core/numeric/interpolation.h	/^class MultiDimesionInterpolation : public TInterpolator$/;"	c	namespace:simpla
NDIMS	applications/fokker_planck/lhw.cpp	/^static constexpr std::size_t   NDIMS = 3;$/;"	v	file:
NDIMS	core/field/test/trash/fetl_test3.h	/^	static constexpr unsigned int NDIMS = manifold_type::NDIMS;$/;"	m	class:TestFETL
NDIMS	core/numeric/interpolation.h	/^        NDIMS = 2$/;"	e	enum:simpla::BiLinearInterpolation::__anon4
NDIMS	core/numeric/interpolation.h	/^        NDIMS = 2$/;"	e	enum:simpla::MultiDimesionInterpolation::__anon3
NDIMS	core/parallel/MPIComm.cpp	/^constexpr int MPIComm::NDIMS;$/;"	m	class:simpla::parallel::MPIComm	file:
NDIMS	core/parallel/MPIComm.h	/^    static constexpr int NDIMS = 3;$/;"	m	class:simpla::parallel::MPIComm
NDIMS	core/parallel/test/distributed_array_test.cpp	/^	static constexpr unsigned int NDIMS = 3;$/;"	m	class:TestDistArray	file:
NEED_OPTIMIZATION	core/gtl/utilities/log.h	322;"	d
NONE	core/model/obsoleted/model.h	/^        NONE = 0,$/;"	e	enum:simpla::Model::__anon9
NORMAL_DISTRIBUTION_ICDF_H_	core/numeric/normal_distribution_icdf.h	9;"	d
NOSEGM	core/geometry/obsolete/line_cliping.h	/^	size_t NOSEGM = 0; \/* segment was rejected *\/$/;"	m	class:simpla::polygon_clip
NOTHING_TODO	core/gtl/utilities/log.h	336;"	d
NOT_ZERO	core/manifold/mesh/MeshBlock.cpp	196;"	d	file:
NOT_ZERO	core/manifold/mesh/MeshBlock.cpp	251;"	d	file:
NO_HAED	core/manifold/mesh/MeshIds.h	/^    static constexpr id_type NO_HAED = (1UL << (ID_DIGITS * 3)) - 1;$/;"	m	struct:simpla::mesh::MeshEntityIdCoder
NUM_OF_NODE_ID	core/manifold/mesh/MeshIds.h	/^    static constexpr int NUM_OF_NODE_ID = 8;$/;"	m	struct:simpla::mesh::MeshEntityIdCoder
NUM_OF_SEED_PER_SAMPLE	core/particle/ParticleGenerator.h	/^    static constexpr int NUM_OF_SEED_PER_SAMPLE = 6;$/;"	m	struct:simpla::particle::ParticleGenerator
Next	core/gtl/utilities/lua_object.cpp	/^LuaObject::iterator &LuaObject::iterator::Next()$/;"	f	class:simpla::lua::LuaObject::iterator
NextCell	core/parallel/obsoleted/blocked_range.h	/^	void NextCell()$/;"	f	struct:simpla::iterator
NoExtension	cpplint.py	/^  def NoExtension(self):$/;"	m	class:FileInfo
NullType	core/gtl/type_traits.h	/^typedef std::nullptr_t NullType;$/;"	t	namespace:simpla
NumLines	cpplint.py	/^  def NumLines(self):$/;"	m	class:CleansedLines
NumberOfBlocks	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^    int NumberOfBlocks;$/;"	m	class:vtkAMRSimPlaReader::pimpl_s	file:
NumberOfDimensions	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^    int NumberOfDimensions;$/;"	m	class:vtkAMRSimPlaReader::pimpl_s	file:
NumberOfDimensions	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^    int NumberOfDimensions;$/;"	m	class:vtkAMRSimPlaReaderBlock	file:
NumberOfLevels	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^    int NumberOfLevels;$/;"	m	class:vtkAMRSimPlaReader::pimpl_s	file:
NumberOfMultiBlocks	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^    int NumberOfMultiBlocks;$/;"	m	class:vtkAMRSimPlaReader::pimpl_s	file:
NumberOfParticles	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^    int NumberOfParticles;$/;"	m	class:vtkAMRSimPlaReaderBlock	file:
OBSOLETE	core/gtl/utilities/log.h	325;"	d
ONEHALFPI	core/physics/Constants.h	/^constexpr double ONEHALFPI = 1.50 * PI;$/;"	v
ONE_GIGA	core/gtl/utilities/memory_pool.cpp	/^    static constexpr size_t ONE_GIGA = 1024l * 1024l * 1024l;$/;"	m	struct:simpla::MemoryPool::pimpl_s	file:
ON_SURFACE	core/model/Constraint.h	/^    INSIDE = 1, OUTSIDE = 2, ON_SURFACE = 4$/;"	e	enum:simpla::model::__anon10
OUTSIDE	core/model/Constraint.h	/^    INSIDE = 1, OUTSIDE = 2, ON_SURFACE = 4$/;"	e	enum:simpla::model::__anon10
OUT_OF_RANGE	core/gtl/utilities/log.h	358;"	d
OVERFLOW_FLAG	core/manifold/mesh/MeshIds.h	/^    static constexpr id_type OVERFLOW_FLAG = (1UL) << (ID_DIGITS - 1);$/;"	m	struct:simpla::mesh::MeshEntityIdCoder
OVERFLOW_FLAG	core/manifold/mesh/MeshIds.h	/^template<int L> constexpr typename MeshEntityIdCoder<L>::id_type MeshEntityIdCoder<L>::OVERFLOW_FLAG;$/;"	m	class:simpla::mesh::MeshEntityIdCoder
Object	core/base/Object.cpp	/^Object::Object() { this->touch(); };$/;"	f	class:simpla::base::Object
Object	core/base/Object.cpp	/^Object::Object(Object &&other) : m_click_(other.m_click_) { };$/;"	f	class:simpla::base::Object
Object	core/base/Object.cpp	/^Object::Object(Object const &) { this->touch(); };$/;"	f	class:simpla::base::Object
Object	core/base/Object.h	/^class Object$/;"	c	namespace:simpla::base
Object	example/model/demo_model.lua	/^Object=function(v)$/;"	f
Object 	example/em/demo_em.lua	/^        Object = function(v)$/;"	f
Object 	example/em/em.lua	/^        Object = function(v)$/;"	f
Object 	example/em_tokamak/tokamak.lua	/^        Object = function(v)$/;"	f
Observable	core/gtl/design_pattern/observer.h	/^	Observable()$/;"	f	struct:simpla::Observable
Observable	core/gtl/design_pattern/observer.h	/^struct Observable<Signature> : public std::enable_shared_from_this<Observable<Signature>>$/;"	s	namespace:simpla
Observer	core/gtl/design_pattern/observer.h	/^	Observer()$/;"	f	struct:simpla::Observer
Observer	core/gtl/design_pattern/observer.h	/^struct Observer<void(Args...)>$/;"	s	namespace:simpla
One	core/gtl/expression_template.h	/^struct One$/;"	s	namespace:simpla
Operation	scripts/configure/test.lua	/^		Operation= function(t,x,f )$/;"	f
Operation	scripts/demo.lua	/^		Operation= function(t,x,f )$/;"	f
Operation	scripts/demo.lua	/^Operation= function(t,x,f )$/;"	f
PAGE_MASK	core/gtl/containers/container_pool.h	/^	static constexpr size_t PAGE_MASK = (1 << PAGE_SIZE_DIGITS) - 1;$/;"	m	struct:simpla::ContainerPool
PAGE_SIZE	core/gtl/containers/container_pool.h	/^	static constexpr size_t PAGE_SIZE = 1 << PAGE_SIZE_DIGITS;$/;"	m	struct:simpla::ContainerPool
PAGE_SIZE_DIGITS	core/gtl/containers/container_pool.h	/^	static constexpr size_t PAGE_SIZE_DIGITS = 10;$/;"	m	struct:simpla::ContainerPool
PARALLEL_H_	core/parallel/Parallel.h	9;"	d
PARALLEL_TBB_H_	core/parallel/ParallelTbb.h	9;"	d
PARSER_CONFIGURE_H_	core/gtl/utilities/parser_configure.h	9;"	d
PARSER_WARNING	core/gtl/utilities/log.h	387;"	d
PARSE_COMMAND_LINE_H_	core/gtl/utilities/parse_command_line.h	9;"	d
PARTICLE_CONSTRAINT_H_	core/particle/ParticleConstraint.h	9;"	d
PARTICLE_ENGINE_H_	core/particle/ParticleEngine.h	9;"	d
PHYSICAL_CONSTANTS_H_	core/physics/PhysicalConstants.h	9;"	d
PI	core/field/test/field_io_test.h	/^	static constexpr double PI = 3.141592653589793;$/;"	m	class:simpla::TestFieldIO
PI	core/physics/Constants.h	/^constexpr double PI = 3.1415926535897932384626433;$/;"	v
PICDeltaF	applications/fokker_planck/lhw.cpp	/^	PICDeltaF()$/;"	f	struct:PICDeltaF
PICDeltaF	applications/fokker_planck/lhw.cpp	/^struct PICDeltaF$/;"	s	file:
PICDeltaF	applications/particle_solver/pic_engine_deltaf.h	/^typedef ParticleEngine<PolicyPICDeltaF> PICDeltaF;$/;"	t	namespace:simpla
PICDemo	core/particle/test/particle_generator_test.cpp	/^struct PICDemo$/;"	s	namespace:simpla	file:
PICEngineDeltaF	applications/particle_solver/pic_engine_deltaf2.h	/^	PICEngineDeltaF(mesh_type const &pmesh)$/;"	f	struct:simpla::PICEngineDeltaF
PICEngineDeltaF	applications/particle_solver/pic_engine_deltaf2.h	/^struct PICEngineDeltaF$/;"	s	namespace:simpla
PICEngineFullF	applications/particle_solver/pic_engine_fullf.h	/^	PICEngineFullF(Real m = 1.0, Real q = 1.0)$/;"	f	class:simpla::PICEngineFullF
PICEngineFullF	applications/particle_solver/pic_engine_fullf.h	/^class PICEngineFullF$/;"	c	namespace:simpla
PICEngineGGauge	applications/particle_solver/pic_engine_ggauge.h	/^	PICEngineGGauge(mesh_type const &m)$/;"	f	class:simpla::PICEngineGGauge
PICEngineGGauge	applications/particle_solver/pic_engine_ggauge.h	/^	PICEngineGGauge(mesh_type const &m, Others && ...others)$/;"	f	class:simpla::PICEngineGGauge
PICEngineGGauge	applications/particle_solver/pic_engine_ggauge.h	/^class PICEngineGGauge$/;"	c	namespace:simpla
PICEngineImplicit	applications/particle_solver/pic_engine_implicit.h	/^	PICEngineImplicit(mesh_type const &m) :$/;"	f	struct:simpla::PICEngineImplicit
PICEngineImplicit	applications/particle_solver/pic_engine_implicit.h	/^	PICEngineImplicit(mesh_type const &pmesh, Others && ...others) :$/;"	f	struct:simpla::PICEngineImplicit
PICEngineImplicit	applications/particle_solver/pic_engine_implicit.h	/^template<typename TM, typename TInterpolator = Interpolator<TM, std::nullptr_t>> struct PICEngineImplicit$/;"	s	namespace:simpla
PIC_ENGINE_DELTAF_H_	applications/particle_solver/pic_engine_deltaf.h	9;"	d
PIC_ENGINE_DELTAF_H_	applications/particle_solver/pic_engine_deltaf2.h	9;"	d
PIC_ENGINE_FULLF_H_	applications/particle_solver/pic_engine_fullf.h	9;"	d
PIC_ENGINE_GGAUGE_H_	applications/particle_solver/pic_engine_ggauge.h	9;"	d
PIC_ENGINE_IMPLICIT_H_	applications/particle_solver/pic_engine_implicit.h	9;"	d
PLASMA	core/model/obsoleted/model.h	/^        PLASMA = 1UL << 2,$/;"	e	enum:simpla::Model::__anon9
PML	applications/field_solver/pml.h	/^PML<TM>::PML(mesh_type const & mesh, Args && ...args) :$/;"	f	class:simpla::PML
PML	applications/field_solver/pml.h	/^class PML$/;"	c	namespace:simpla
PRETTY_STREAM_H_	core/gtl/utilities/pretty_stream.h	9;"	d
PRIMARY_ID_MASK	core/manifold/mesh/MeshIds.h	/^    static constexpr id_type PRIMARY_ID_MASK = PRIMARY_ID_MASK_$/;"	m	struct:simpla::mesh::MeshEntityIdCoder
PRIMARY_ID_MASK_	core/manifold/mesh/MeshIds.h	/^    static constexpr id_type PRIMARY_ID_MASK_ = ID_MASK & (~SUB_ID_MASK);$/;"	m	struct:simpla::mesh::MeshEntityIdCoder
PRIMITIVES_H_	core/gtl/primitives.h	9;"	d
PROPERTIES_H_	core/gtl/Properties.h	9;"	d
ParallelPolicy	core/manifold/policy/ParallelPolicy.h	/^    ParallelPolicy(mesh_type &geo) : m_mesh_(geo) { }$/;"	f	struct:simpla::manifold::policy::ParallelPolicy
ParallelPolicy	core/manifold/policy/ParallelPolicy.h	/^struct ParallelPolicy$/;"	s	namespace:simpla::manifold::policy
ParamList	core/geometry/test/geometry_test.cpp	/^		std::integral_constant<size_t, VOLUME> > ParamList;$/;"	t	file:
ParamList	core/model/test/model_test.cpp	/^		std::integral_constant<size_t, VOLUME> > ParamList;$/;"	t	file:
ParentId	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^    int ParentId;$/;"	m	class:vtkAMRSimPlaReaderBlock	file:
ParseArguments	cpplint.py	/^def ParseArguments(args):$/;"	f
ParseCFactor	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^void vtkAMRSimPlaReader::ParseCFactor($/;"	f	class:vtkAMRSimPlaReader
ParseConversionFactors	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^void vtkAMRSimPlaReader::ParseConversionFactors()$/;"	f	class:vtkAMRSimPlaReader
ParseLabel	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^void vtkAMRSimPlaReader::ParseLabel($/;"	f	class:vtkAMRSimPlaReader
ParseNolintSuppressions	cpplint.py	/^def ParseNolintSuppressions(filename, raw_line, linenum, error):$/;"	f
ParserConfigure	core/gtl/utilities/parser_configure.h	/^ParserConfigure<TDict>::ParserConfigure()$/;"	f	class:simpla::ParserConfigure
ParserConfigure	core/gtl/utilities/parser_configure.h	/^class ParserConfigure$/;"	c	namespace:simpla
Particle	applications/particle_solver/fluid_cold_engine.h	/^Particle<TM, ColdFluid, PolicyFluidParticle>::Particle(TDict const & dict,$/;"	f	class:simpla::Particle
Particle	applications/particle_solver/fluid_cold_engine.h	/^class Particle<TM, ColdFluid, PolicyFluidParticle>$/;"	c	namespace:simpla
Particle	core/particle/Particle.h	/^    Particle(mesh_type &m, std::string const &s_name) : m_data_(new container_type(m, s_name))$/;"	f	struct:simpla::particle::Particle
Particle	core/particle/Particle.h	/^    Particle(this_type &&other) : m_data_(other.m_data_) { };$/;"	f	struct:simpla::particle::Particle
Particle	core/particle/Particle.h	/^    Particle(this_type const &other) : m_data_(other.m_data_) { };$/;"	f	struct:simpla::particle::Particle
Particle	core/particle/Particle.h	/^struct Particle<P, M> : public ParticleBase$/;"	s	namespace:simpla::particle
ParticleAttributeNames	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^    std::vector<std::string> ParticleAttributeNames;$/;"	m	class:vtkAMRSimPlaReader::pimpl_s	file:
ParticleBase	core/particle/Particle.h	/^    ParticleBase() { }$/;"	f	struct:simpla::particle::ParticleBase
ParticleBase	core/particle/Particle.h	/^struct ParticleBase : public base::DataObject$/;"	s	namespace:simpla::particle
ParticleContainer	core/particle/ParticleContainer.h	/^ParticleContainer<P, M>::ParticleContainer(mesh_type &m, std::string const &s_name)$/;"	f	class:simpla::particle::ParticleContainer
ParticleContainer	core/particle/ParticleContainer.h	/^struct ParticleContainer<ParticleEngine, M> :$/;"	s	namespace:simpla::particle
ParticleEngine	applications/particle_solver/pic_engine_deltaf.h	/^	ParticleEngine()$/;"	f	struct:simpla::ParticleEngine
ParticleEngine	applications/particle_solver/pic_engine_deltaf.h	/^struct ParticleEngine<PolicyPICDeltaF>$/;"	s	namespace:simpla
ParticleFileName	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^    std::string ParticleFileName;$/;"	m	class:vtkAMRSimPlaReaderBlock	file:
ParticleGenerator	core/particle/ParticleGenerator.h	/^    ParticleGenerator() { }$/;"	f	struct:simpla::particle::ParticleGenerator
ParticleGenerator	core/particle/ParticleGenerator.h	/^    ParticleGenerator(TSeed const &seed) : m_seed_(seed) { }$/;"	f	struct:simpla::particle::ParticleGenerator
ParticleGenerator	core/particle/ParticleGenerator.h	/^struct ParticleGenerator : public parallel::DistributedCounter$/;"	s	namespace:simpla::particle
ParticleGeneratorPerCell	core/particle/ParticleGenerator.h	/^    ParticleGeneratorPerCell(particle_type const &e, size_t num_per_cell, Args &&...args)$/;"	f	class:simpla::particle::ParticleGeneratorPerCell
ParticleGeneratorPerCell	core/particle/ParticleGenerator.h	/^class ParticleGeneratorPerCell$/;"	c	namespace:simpla::particle
ParticleProxy	core/particle/ParticleProxy.h	/^    ParticleProxy(std::shared_ptr<particle_type> p) : m_self_(p) { }$/;"	f	class:simpla::particle::ParticleProxy
ParticleProxy	core/particle/ParticleProxy.h	/^    ParticleProxy(this_type const &other) : m_self_(other.m_self_) { }$/;"	f	class:simpla::particle::ParticleProxy
ParticleProxy	core/particle/ParticleProxy.h	/^class ParticleProxy<TP, TE, TB, TJ, TRho> : public ParticleProxyBase<TE, TB, TJ, TRho>$/;"	c	namespace:simpla::particle
ParticleProxyBase	core/particle/ParticleProxy.h	/^    ParticleProxyBase() { }$/;"	f	struct:simpla::particle::ParticleProxyBase
ParticleProxyBase	core/particle/ParticleProxy.h	/^struct ParticleProxyBase<TE, TB, TJ, TRho>$/;"	s	namespace:simpla::particle
ParticleType	plugins/vtk_reader/vtkAMRSimPlaParticlesReader.h	/^    int ParticleType;$/;"	m	class:vtkAMRSimPlaParticlesReader
Patch	core/base/Patch.h	/^    Patch() { }$/;"	f	class:simpla::base::Patch
Patch	core/base/Patch.h	/^class Patch$/;"	c	namespace:simpla::base
PatchPolicy	core/manifold/obsoleted/patch/mesh_patch.h	/^class PatchPolicy : public PatchEntity$/;"	c	namespace:simpla::mesh
PhiAxis	core/field/test/field_diff_calculus_test.h	/^static constexpr const int PhiAxis = cs::PhiAxis;$/;"	v
PhiAxis	core/geometry/CoordinateSystem.h	/^    static constexpr int PhiAxis = (IPhiAxis) % 3;$/;"	m	struct:simpla::geometry::coordinate_system::Cylindrical
PhiAxis	core/geometry/csCylindrical.h	/^    static constexpr int PhiAxis = cs::PhiAxis;$/;"	m	struct:simpla::geometry::Metric
PhiAxis	core/model/GEqdsk.cpp	/^constexpr int GEqdsk::PhiAxis;$/;"	m	class:simpla::GEqdsk	file:
PhiAxis	core/model/GEqdsk.h	/^    static constexpr int PhiAxis = 2;$/;"	m	class:simpla::GEqdsk
PhiAxis	example/em/em.cpp	/^static constexpr const int PhiAxis = cs::PhiAxis;$/;"	v	file:
PhysicalConstants	core/physics/PhysicalConstants.cpp	/^PhysicalConstants::PhysicalConstants(std::string type)$/;"	f	class:simpla::PhysicalConstants
PhysicalConstants	core/physics/PhysicalConstants.h	/^class PhysicalConstants$/;"	c	namespace:simpla
Point_s	applications/fokker_planck/lhw.cpp	/^	struct Point_s$/;"	s	struct:PICDeltaF	file:
Point_s	applications/particle_solver/pic_engine_deltaf2.h	/^	struct Point_s$/;"	s	struct:simpla::PICEngineDeltaF
Point_s	applications/particle_solver/pic_engine_fullf.h	/^	struct Point_s$/;"	s	class:simpla::PICEngineFullF
Point_s	applications/particle_solver/pic_engine_ggauge.h	/^	struct Point_s$/;"	s	class:simpla::PICEngineGGauge
Point_s	applications/particle_solver/pic_engine_implicit.h	/^	struct Point_s$/;"	s	struct:simpla::PICEngineImplicit
Point_s	core/particle/obsolete/kinetic_particle.h	/^    typedef typename engine_type::Point_s Point_s;$/;"	t	struct:KineticParticle
Point_s	core/particle/obsolete/probe_particle.h	/^    typedef typename engine_type::Point_s Point_s;$/;"	t	struct:simpla::ProbeParticle
Point_s	core/particle/test/kinetic_particle_test.cpp	/^	typedef typename engine_type::Point_s Point_s;$/;"	t	class:TestKineticParticle	file:
PointerTo	core/gtl/type_traits_ext.h	/^template<typename T> inline T* PointerTo(T & v)$/;"	f	namespace:simpla
PointerTo	core/gtl/type_traits_ext.h	/^template<typename T> inline T* PointerTo(T * v)$/;"	f	namespace:simpla
Polar	core/geometry/CoordinateSystem.h	/^struct Polar$/;"	s	namespace:simpla::geometry::coordinate_system
PolyGon	core/geometry/obsolete/polygon.h	/^struct PolyGon: public std::list<coordinate_tuple>$/;"	s	namespace:simpla
Polygon	core/geometry/model.h	/^struct Polygon$/;"	s	namespace:simpla::geometry::model
Polygon	core/geometry/polygon.h	/^    Polygon() { }$/;"	f	struct:simpla::geometry::Polygon
Polygon	core/geometry/polygon.h	/^struct Polygon<2> : public GeoObject$/;"	s	namespace:simpla::geometry
PreviousCell	core/parallel/obsoleted/blocked_range.h	/^	void PreviousCell()$/;"	f	struct:simpla::iterator
Primitive	core/geometry/model.h	/^struct Primitive<3, CS, tags::box>$/;"	s	namespace:simpla::geometry::model
Primitive	core/geometry/model.h	/^struct Primitive<3, CS, tags::circle>$/;"	s	namespace:simpla::geometry::model
Primitive	core/geometry/model.h	/^struct Primitive<3, CS, tags::cone>$/;"	s	namespace:simpla::geometry::model
Primitive	core/geometry/model.h	/^struct Primitive<3, CS, tags::cylinder>$/;"	s	namespace:simpla::geometry::model
Primitive	core/geometry/model.h	/^struct Primitive<3, CS, tags::sphere>$/;"	s	namespace:simpla::geometry::model
Primitive	core/geometry/model.h	/^struct Primitive<3, CS, tags::torus>$/;"	s	namespace:simpla::geometry::model
Primitive	core/geometry/primitive.h	/^struct Primitive<0, CoordinateSystem>$/;"	s	namespace:simpla::geometry::model
Primitive	core/geometry/primitive.h	/^struct Primitive<Dimension, CoordinateSystem, Tag>$/;"	s	namespace:simpla::geometry::model
PrintCategories	cpplint.py	/^def PrintCategories():$/;"	f
PrintErrorCounts	cpplint.py	/^  def PrintErrorCounts(self):$/;"	m	class:_CppLintState
PrintSelf	plugins/vtk_reader/vtkAMRSimPlaParticlesReader.cpp	/^void vtkAMRSimPlaParticlesReader::PrintSelf($/;"	f	class:vtkAMRSimPlaParticlesReader
PrintSelf	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^void vtkAMRSimPlaReader::PrintSelf(std::ostream &os, vtkIndent indent)$/;"	f	class:vtkAMRSimPlaReader
PrintUsage	cpplint.py	/^def PrintUsage(message):$/;"	f
ProbeDemo	example/probe_particle/demo_probe_particle.h	/^	ProbeDemo() :$/;"	f	struct:simpla::ProbeDemo
ProbeDemo	example/probe_particle/demo_probe_particle.h	/^struct ProbeDemo$/;"	s	namespace:simpla
ProbeParticle	core/particle/obsolete/probe_particle.h	/^ProbeParticle<Engine>::ProbeParticle()$/;"	f	class:simpla::ProbeParticle
ProbeParticle	core/particle/obsolete/probe_particle.h	/^ProbeParticle<Engine>::ProbeParticle(ProbeParticle const &)$/;"	f	class:simpla::ProbeParticle
ProbeParticle	core/particle/obsolete/probe_particle.h	/^ProbeParticle<Engine>::ProbeParticle(ProbeParticle<Engine> &other, split) :$/;"	f	class:simpla::ProbeParticle
ProbeParticle	core/particle/obsolete/probe_particle.h	/^struct ProbeParticle : public SpObject,$/;"	s	namespace:simpla
ProcessFile	cpplint.py	/^def ProcessFile(filename, vlevel):$/;"	f
ProcessFileData	cpplint.py	/^def ProcessFileData(filename, file_extension, lines, error):$/;"	f
ProcessLine	cpplint.py	/^def ProcessLine(filename, file_extension,$/;"	f
Properties	core/gtl/Properties.h	/^    Properties() { }$/;"	f	class:simpla::Properties
Properties	core/gtl/Properties.h	/^    Properties(this_type const &other) : any(dynamic_cast<any const &>(other)), map_type(other) { }$/;"	f	class:simpla::Properties
Properties	core/gtl/Properties.h	/^    template<typename T> Properties(T const &v) : any(v) { }$/;"	f	class:simpla::Properties
Properties	core/gtl/Properties.h	/^class Properties$/;"	c	namespace:simpla
RAxis	core/field/test/field_diff_calculus_test.h	/^static constexpr const int RAxis = cs::RAxis;$/;"	v
RAxis	core/geometry/CoordinateSystem.h	/^    static constexpr int RAxis = (PhiAxis + 1) % 3;$/;"	m	struct:simpla::geometry::coordinate_system::Cylindrical
RAxis	core/geometry/csCylindrical.h	/^    static constexpr int RAxis = cs::RAxis;$/;"	m	struct:simpla::geometry::Metric
RAxis	core/model/GEqdsk.cpp	/^constexpr int GEqdsk::RAxis;$/;"	m	class:simpla::GEqdsk	file:
RAxis	core/model/GEqdsk.h	/^    static constexpr int RAxis = (PhiAxis + 1) % 3;$/;"	m	class:simpla::GEqdsk
RAxis	example/em/em.cpp	/^static constexpr const int RAxis = cs::RAxis;$/;"	v	file:
RBF	core/manifold/policy/LinearInterpolatorPolicy.h	/^    Real RBF(M const &m, typename M::point_type const &x0, typename M::point_type const &x1,$/;"	f	struct:simpla::manifold::policy::LinearInterpolator
RBF	core/manifold/policy/LinearInterpolatorPolicy.h	/^    Real RBF(M const &m, typename M::point_type const &x0,$/;"	f	struct:simpla::manifold::policy::LinearInterpolator
RECTANGLE_DISTRIBUTION_H_	core/numeric/rectangle_distribution.h	9;"	d
REDUCE_CHECK	core/gtl/utilities/log.h	410;"	d
REGISTER_PARTICLE_H_	applications/particle_solver/register_particle.h	9;"	d
RIGHT_COLUMN	core/gtl/utilities/log.h	413;"	d
RUNTIME_ERROR	core/gtl/utilities/log.h	352;"	d
RVec3	core/gtl/primitives.h	/^typedef nTuple<Real, 3> RVec3;$/;"	t	namespace:simpla
Range	core/gtl/iterator/range.h	/^    Range() : m_begin_(), m_end_(m_begin_), m_grain_size_(0) { }$/;"	f	class:simpla::Range
Range	core/gtl/iterator/range.h	/^    Range(Range &other, TSplit const &)$/;"	f	class:simpla::Range
Range	core/gtl/iterator/range.h	/^    Range(T0 const &b, T1 const &e, ptrdiff_t grain_size = 1)$/;"	f	class:simpla::Range
Range	core/gtl/iterator/range.h	/^    Range(const_iterator const &b, const_iterator const &e, ptrdiff_t grain_size = 1)$/;"	f	class:simpla::Range
Range	core/gtl/iterator/range.h	/^    Range(this_type &r, parallel::tags::proportional_split &proportion) :$/;"	f	class:simpla::Range
Range	core/gtl/iterator/range.h	/^class Range<Iterator>$/;"	c	namespace:simpla
ReadBlockStructures	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^void vtkAMRSimPlaReader::pimpl_s::ReadBlockStructures()$/;"	f	class:vtkAMRSimPlaReader::pimpl_s
ReadGeneralParameters	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^void vtkAMRSimPlaReader::pimpl_s::ReadGeneralParameters()$/;"	f	class:vtkAMRSimPlaReader::pimpl_s
ReadMetaData	plugins/vtk_reader/vtkAMRSimPlaParticlesReader.cpp	/^void vtkAMRSimPlaParticlesReader::ReadMetaData()$/;"	f	class:vtkAMRSimPlaParticlesReader
ReadMetaData	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^void vtkAMRSimPlaReader::ReadMetaData()$/;"	f	class:vtkAMRSimPlaReader
ReadMetaData	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^void vtkAMRSimPlaReader::pimpl_s::ReadMetaData()$/;"	f	class:vtkAMRSimPlaReader::pimpl_s
ReadParticles	plugins/vtk_reader/vtkAMRSimPlaParticlesReader.cpp	/^vtkPolyData *vtkAMRSimPlaParticlesReader::ReadParticles(const int blkidx)$/;"	f	class:vtkAMRSimPlaParticlesReader
Real	core/gtl/primitives.h	/^typedef double Real;$/;"	t	namespace:simpla
ReferenceBlock	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^    int ReferenceBlock;$/;"	m	class:vtkAMRSimPlaReader::pimpl_s	file:
RefreshCache	core/gtl/containers/container_cache.h	/^void RefreshCache(TIndexType s, CacheContainer<T> & c)$/;"	f	namespace:simpla
RefreshCache	core/gtl/containers/container_cache.h	/^void RefreshCache(TIndexType s, T & f, Others & ...others)$/;"	f	namespace:simpla
RefreshCache	core/gtl/containers/container_cache.h	/^void RefreshCache(TIndexType s, T &)$/;"	f	namespace:simpla
RefreshCache	core/gtl/containers/container_cache.h	/^void RefreshCache(TIndexType s, T *)$/;"	f	namespace:simpla
RegisterAllParticles	applications/particle_solver/register_particle.h	/^Factory<std::string, ParticleBase, Args ...> RegisterAllParticles()$/;"	f	namespace:simpla
RegisterContext	applications/contexts/context_factory.h	/^context_factory RegisterContext()$/;"	f	namespace:simpla
RegisterEMContextCartesian	applications/contexts/context_cartesian.cpp	/^void RegisterEMContextCartesian($/;"	f	namespace:simpla
RegisterEMContextCylindrical	applications/contexts/context_cylindrical.cpp	/^void RegisterEMContextCylindrical($/;"	f	namespace:simpla
ReleaseDataArray	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^void vtkAMRSimPlaReader::pimpl_s::ReleaseDataArray()$/;"	f	class:vtkAMRSimPlaReader::pimpl_s
RemoveMultiLineComments	cpplint.py	/^def RemoveMultiLineComments(filename, lines, error):$/;"	f
RemoveMultiLineCommentsFromRange	cpplint.py	/^def RemoveMultiLineCommentsFromRange(lines, begin, end):$/;"	f
ReplaceableCheck	cpplint.py	/^def ReplaceableCheck(operator, macro, line):$/;"	f
RepositoryName	cpplint.py	/^  def RepositoryName(self):$/;"	m	class:FileInfo
Reset	core/numeric/simplex_distribution.h	/^	inline void Reset(Args ... args)$/;"	f	class:simpla::simplex_distribution
ResetErrorCounts	cpplint.py	/^  def ResetErrorCounts(self):$/;"	m	class:_CppLintState
ResetNolintSuppressions	cpplint.py	/^def ResetNolintSuppressions():$/;"	f
RevolvePolygon	core/model/obsoleted/revolve_polygon.h	/^struct RevolvePolygon : public ModelBase$/;"	s	namespace:simpla
Ring	core/geometry/obsolete/geometry_object.h	/^struct Ring$/;"	s	namespace:simpla::geometry_object
SAMRObjectBase	core/manifold/obsoleted/samr_object.h	/^class SAMRObjectBase$/;"	c	namespace:simpla::mesh
SAVE	core/io/IO.h	144;"	d
SAVE_APPEND	core/io/IO.h	145;"	d
SAVE_RECORD	core/io/IO.h	146;"	d
SEGM	core/geometry/obsolete/line_cliping.h	/^	size_t SEGM = 1; \/* segment is at least partially visible *\/$/;"	m	class:simpla::polygon_clip
SEPERATOR	core/gtl/utilities/log.h	422;"	d
SHOW	core/gtl/utilities/log.h	403;"	d
SHOW_BIT	core/gtl/utilities/log.h	436;"	d
SHOW_ERROR	core/gtl/utilities/log.h	348;"	d
SHOW_HEX	core/gtl/utilities/log.h	404;"	d
SHOW_WARNING	core/gtl/utilities/log.h	350;"	d
SIMPLA_AMR_H	core/manifold/obsoleted/amr_policy.h	8;"	d
SIMPLA_ARRAY_VIEW_H	core/gtl/array_view.h	8;"	d
SIMPLA_ATTRIBUTE_H	core/base/Attribute.h	8;"	d
SIMPLA_BLOCK_H	core/manifold/mesh/MeshBlock.h	8;"	d
SIMPLA_BLOCK_H	core/manifold/obsoleted/block.h	8;"	d
SIMPLA_BLOCK_ITERATOR_H	core/gtl/iterator/block_iterator.h	8;"	d
SIMPLA_BLOCK_RANGE_H	core/gtl/range/block_range.h	8;"	d
SIMPLA_CARTESIANCORECT_H	core/manifold/mesh/CartesianCoRect.h	8;"	d
SIMPLA_COLLISION_PIC_H	example/pic/collision_pic.h	8;"	d
SIMPLA_COMPOUND_DISTRIBUTION_H	core/numeric/compound_distribution.h	8;"	d
SIMPLA_CONCURRENT_UNORDERED_MULTISET_H	core/parallel/concurrent_unordered_multiset.h	8;"	d
SIMPLA_CONSTRAINT_H	core/model/Constraint.h	8;"	d
SIMPLA_CORECTMESH_H	core/manifold/mesh/CoRectMesh.h	9;"	d
SIMPLA_CYLINDRICALRECTMESH_H	core/manifold/mesh/CylindricalCoRect.h	8;"	d
SIMPLA_DATAVIEW_H	core/data_model/data_view.h	8;"	d
SIMPLA_DATA_OBJECT_H	core/base/DataObject.h	8;"	d
SIMPLA_DEFS_H_	core/sp_config.h	9;"	d
SIMPLA_DISALLOW_ASSIGN	core/gtl/macro.h	46;"	d
SIMPLA_DISALLOW_COPY_AND_ASSIGN	core/gtl/macro.h	48;"	d
SIMPLA_DISTRIBUTEDCOUNTER_H	core/parallel/DistributedCounter.h	8;"	d
SIMPLA_DISTRIBUTED_COMM_H	core/parallel/obsoleted/distributed_comm.h	8;"	d
SIMPLA_DISTRIBUTED_H	core/parallel/obsoleted/distributed.h	8;"	d
SIMPLA_DISTRIBUTED_OBJECT_H	core/parallel/DistributedObject.h	8;"	d
SIMPLA_DISTRIBUTED_UNORDERED_SET_H	core/parallel/obsoleted/distributed_unordered_set.h	8;"	d
SIMPLA_DUMMY_H	core/dummy.h	6;"	d
SIMPLA_EBMESH_H_H	core/manifold/obsoleted/ebmesh.h	8;"	d
SIMPLA_EMBEDDED_POLICY_H	core/manifold/obsoleted/embedded_policy.h	8;"	d
SIMPLA_EM_CYLINDRICAL_H	example/em/em.h	8;"	d
SIMPLA_EM_FLUID_H	core/phy_solver/em_fluid.h	8;"	d
SIMPLA_EM_PLASMA_H	example/em_tokamak/tokamak.h	8;"	d
SIMPLA_FIBER_BUNDLE_H	core/manifold/obsoleted/fiber_bundle.h	8;"	d
SIMPLA_FIELD_H	core/field/Field.h	8;"	d
SIMPLA_FIELD_PATCH_H	core/field/obsoleted/field_patch.h	8;"	d
SIMPLA_FUNCTION_H	core/gtl/function.h	8;"	d
SIMPLA_GTL_DESIGN_PATTERN_OBSERVER_H	core/gtl/design_pattern/observer.h	6;"	d
SIMPLA_GTL_DESIGN_PATTERN_STRATEGY_H	core/gtl/design_pattern/strategy.h	7;"	d
SIMPLA_GUIDINGCENTER_H	core/particle/pre_define/GuidingCenter.h	8;"	d
SIMPLA_IOSTREAM_H	core/io/IOStream.h	8;"	d
SIMPLA_IO_EXT_H	core/io/IOExt.h	8;"	d
SIMPLA_IO_POLICY_H	core/manifold/policy/IOPolicy.h	8;"	d
SIMPLA_ITERATOR_PROXY_H	core/gtl/containers/iterator_proxy.h	8;"	d
SIMPLA_ITERATOR_TEST_H	core/gtl/test/iterator_test.h	8;"	d
SIMPLA_LIFECLICK_H	core/base/LifeClick.h	8;"	d
SIMPLA_LINEAR_H	core/manifold/policy/LinearInterpolatorPolicy.h	8;"	d
SIMPLA_LINEAR_MAP_H	core/manifold/mesh/LinearMap.h	8;"	d
SIMPLA_LOGO	core/gtl/utilities/logo.cpp	/^static const char SIMPLA_LOGO[] = "\\n"$/;"	m	namespace:simpla	file:
SIMPLA_MAP_GENERAL_H	core/manifold/mesh/GeneralMap.h	8;"	d
SIMPLA_MESH_GRAPH_H	core/manifold/obsoleted/mesh_graph.h	8;"	d
SIMPLA_MESH_H	core/manifold/mesh/Mesh.h	8;"	d
SIMPLA_MESH_IDS_TEST_CPP_H	core/manifold/test/mesh_ids_test.h	8;"	d
SIMPLA_MESH_LAYOUT_H	core/manifold/obsoleted/mesh_layout.h	8;"	d
SIMPLA_MESH_MAP_H	core/manifold/obsoleted/mesh_map.h	8;"	d
SIMPLA_MESH_PATCH_H	core/manifold/obsoleted/patch/mesh_patch.h	8;"	d
SIMPLA_MESH_SNAP_H	core/model/obsoleted/mesh_snap.h	8;"	d
SIMPLA_MOCK_H	core/manifold/pre_define/mock.h	8;"	d
SIMPLA_OBJECT_H	core/base/Object.h	8;"	d
SIMPLA_PARALLELRANDOMGENERATOR_H	core/parallel/ParallelRandomGenerator.h	8;"	d
SIMPLA_PARALLEL_OPEMMP_H_H	core/parallel/obsoleted/parallel_opemmp.h.h	8;"	d
SIMPLA_PARALLEL_POLICY_H	core/manifold/policy/ParallelPolicy.h	8;"	d
SIMPLA_PARALLEL_TRAITS_H	core/parallel/obsoleted/parallel_traits.h	8;"	d
SIMPLA_PARTICLEFACTORY_H	core/particle/ParticleFactory.h	8;"	d
SIMPLA_PARTICLETRACKER_H	core/particle/ParticleTracker.h	8;"	d
SIMPLA_PARTICLE_PROXY_H	core/particle/ParticleProxy.h	8;"	d
SIMPLA_PATCH_H	core/base/Patch.h	8;"	d
SIMPLA_PIC_BORIS_H	core/particle/pre_define/PICBoris.h	8;"	d
SIMPLA_PIC_GYRO_H	core/particle/pre_define/PICGyro.h	8;"	d
SIMPLA_POLYGON_H	core/geometry/polygon.h	8;"	d
SIMPLA_PREDEFINE_H	core/manifold/pre_define/PreDefine.h	8;"	d
SIMPLA_RANGE_H	core/gtl/iterator/range.h	8;"	d
SIMPLA_RECT_MESH_H	core/manifold/mesh/RectMesh.h	8;"	d
SIMPLA_REVOLVE_POLYGON_H	core/model/obsoleted/revolve_polygon.h	8;"	d
SIMPLA_RIEMANNIAN_MESH_H	core/manifold/pre_define/riemannian.h	8;"	d
SIMPLA_SAMR_OBJECT_H	core/manifold/obsoleted/samr_object.h	8;"	d
SIMPLA_SCHEDULE_H	core/task_flow/schedule.h	6;"	d
SIMPLA_SIGNAL_H	core/gtl/design_pattern/signal.h	7;"	d
SIMPLA_SIMPLA_LIB_CPP_H	core/gtl/utilities/logo.h	8;"	d
SIMPLA_STORAGE_POLICY_H	core/manifold/policy/StoragePolicy.h	8;"	d
SIMPLA_TASK_CLASS_NAME_	core/task_flow/task.h	83;"	d
SIMPLA_TASK_FLOW_BASE_H	core/task_flow/task_flow_base.h	8;"	d
SIMPLA_TASK_FLOW_H	core/task_flow/task_flow.h	8;"	d
SIMPLA_TIME_INTEGRATOR_H	core/manifold/obsoleted/time_integrator_policy.h	6;"	d
SIMPLA_TOPOLOGY_H_H	core/manifold/mesh/MeshCommon.h	8;"	d
SIMPLA_TRANS_REVOLVE_H	core/model/obsoleted/trans_revolve.h	8;"	d
SIMPLA_UNORDERED_SET_H	core/gtl/containers/UnorderedSet.h	8;"	d
SIMPLA_VTK_STREAM_H	core/io/vtkStream.h	8;"	d
SIMPLA_WRITEBUFFER_H	core/io/WriteBuffer.h	8;"	d
SIMPLA_XDMF_STREAM_H	core/io/XDMFStream.h	8;"	d
SIMPLA_XDMF_STREAM_SAMR_H	core/io/xdmf_stream_samr.h	8;"	d
SIMPLEX_DISTRIBUTION_H_	core/numeric/simplex_distribution.h	9;"	d
SINGLELINE	core/gtl/utilities/log.h	420;"	d
SI_Avogadro_constant	core/physics/Constants.h	/^constexpr double SI_Avogadro_constant = 6.02214129e23; \/*4.4e-8*\/$/;"	v
SI_Boltzmann_constant	core/physics/Constants.h	/^constexpr double SI_Boltzmann_constant = 1.3806488e-23; \/*9.1e-7*\/$/;"	v
SI_Faraday_constant	core/physics/Constants.h	/^constexpr double SI_Faraday_constant = 96485.3365; \/*2.2e-10*\/$/;"	v
SI_Rydberg_constant	core/physics/Constants.h	/^constexpr double SI_Rydberg_constant = 10973731.568539; \/*5e-12*\/$/;"	v
SI_atomic_mass_unit	core/physics/Constants.h	/^constexpr double SI_atomic_mass_unit = 1.660538921e-27; \/*4.4e-8*\/$/;"	v
SI_electron_charge_mass_ratio	core/physics/Constants.h	/^constexpr double SI_electron_charge_mass_ratio = 1.7588e11;$/;"	v
SI_electron_mass	core/physics/Constants.h	/^constexpr double SI_electron_mass = 9.10938291e-31; \/*4.4e-8*\/$/;"	v
SI_electron_volt	core/physics/Constants.h	/^constexpr double SI_electron_volt = 1.602176565e-19; \/*2.2e-8*\/$/;"	v
SI_elementary_charge	core/physics/Constants.h	/^constexpr double SI_elementary_charge = 1.60217656e-19; \/*2.2e-8*\/$/;"	v
SI_fine_structure_constant	core/physics/Constants.h	/^constexpr double SI_fine_structure_constant = 7.2973525698e-3; \/*3.23-10*\/$/;"	v
SI_gravitational_constant	core/physics/Constants.h	/^constexpr double SI_gravitational_constant = 6.67384e-11; \/*1.2e-4*\/$/;"	v
SI_permeability_of_free_space	core/physics/Constants.h	/^constexpr double SI_permeability_of_free_space = 4.0e-7 * PI;$/;"	v
SI_permittivity_of_free_space	core/physics/Constants.h	/^constexpr double SI_permittivity_of_free_space = 1.0$/;"	v
SI_plank_constant	core/physics/Constants.h	/^constexpr double SI_plank_constant = 6.62606957e-34;$/;"	v
SI_plank_constant_bar	core/physics/Constants.h	/^constexpr double SI_plank_constant_bar = 1.054571726e-34;$/;"	v
SI_proton_electron_mass_ratio	core/physics/Constants.h	/^constexpr double SI_proton_electron_mass_ratio = 1836.15267245;$/;"	v
SI_proton_mass	core/physics/Constants.h	/^constexpr double SI_proton_mass = 1.672621777e-27;$/;"	v
SI_speed_of_light	core/physics/Constants.h	/^constexpr double SI_speed_of_light = 299792458.0;$/;"	v
SOBOL_ENGINE_H_	core/numeric/sobol_engine.h	9;"	d
SP_APP	core/task_flow/application.h	57;"	d
SP_APP	example/em/demo_em.cpp	/^SP_APP(em, " Maxwell Eqs.")$/;"	f
SP_APP	example/em/em.cpp	/^SP_APP(em, " Maxwell Eqs.")$/;"	f
SP_APP	example/pic/collision_pic.cpp	/^SP_APP(pic, "PIC width collision ")$/;"	f
SP_APPEND	core/io/IOStream.h	/^    SP_APPEND = 1UL << 2,$/;"	e	enum:simpla::io::__anon5
SP_BUFFER	core/io/IOStream.h	/^    SP_BUFFER = (1UL << 3),$/;"	e	enum:simpla::io::__anon5
SP_DEFINE_PROPERTIES	core/particle/ParticleEngine.h	375;"	d
SP_DEFINE_STRUCT	core/data_model/DataTypeExt.h	104;"	d
SP_DEFINE_STRUCT_DESC	core/data_model/DataTypeExt.h	102;"	d
SP_DEFINE_STRUCT_DESC_CHOOSE_HELPER	core/data_model/DataTypeExt.h	101;"	d
SP_DEFINE_STRUCT_DESC_CHOOSE_HELPER1	core/data_model/DataTypeExt.h	100;"	d
SP_DEFINE_STRUCT_DESC_HELPER10	core/data_model/DataTypeExt.h	87;"	d
SP_DEFINE_STRUCT_DESC_HELPER12	core/data_model/DataTypeExt.h	89;"	d
SP_DEFINE_STRUCT_DESC_HELPER14	core/data_model/DataTypeExt.h	91;"	d
SP_DEFINE_STRUCT_DESC_HELPER16	core/data_model/DataTypeExt.h	93;"	d
SP_DEFINE_STRUCT_DESC_HELPER18	core/data_model/DataTypeExt.h	95;"	d
SP_DEFINE_STRUCT_DESC_HELPER2	core/data_model/DataTypeExt.h	80;"	d
SP_DEFINE_STRUCT_DESC_HELPER20	core/data_model/DataTypeExt.h	97;"	d
SP_DEFINE_STRUCT_DESC_HELPER4	core/data_model/DataTypeExt.h	81;"	d
SP_DEFINE_STRUCT_DESC_HELPER6	core/data_model/DataTypeExt.h	83;"	d
SP_DEFINE_STRUCT_DESC_HELPER8	core/data_model/DataTypeExt.h	85;"	d
SP_DEFINE_STRUCT_MEMBER	core/data_model/DataTypeExt.h	56;"	d
SP_DEFINE_STRUCT_MEMBER_CHOOSE_HELPER	core/data_model/DataTypeExt.h	55;"	d
SP_DEFINE_STRUCT_MEMBER_CHOOSE_HELPER1	core/data_model/DataTypeExt.h	54;"	d
SP_DEFINE_STRUCT_MEMBER_HELPER10	core/data_model/DataTypeExt.h	40;"	d
SP_DEFINE_STRUCT_MEMBER_HELPER12	core/data_model/DataTypeExt.h	42;"	d
SP_DEFINE_STRUCT_MEMBER_HELPER14	core/data_model/DataTypeExt.h	44;"	d
SP_DEFINE_STRUCT_MEMBER_HELPER16	core/data_model/DataTypeExt.h	46;"	d
SP_DEFINE_STRUCT_MEMBER_HELPER18	core/data_model/DataTypeExt.h	48;"	d
SP_DEFINE_STRUCT_MEMBER_HELPER2	core/data_model/DataTypeExt.h	32;"	d
SP_DEFINE_STRUCT_MEMBER_HELPER20	core/data_model/DataTypeExt.h	50;"	d
SP_DEFINE_STRUCT_MEMBER_HELPER4	core/data_model/DataTypeExt.h	34;"	d
SP_DEFINE_STRUCT_MEMBER_HELPER6	core/data_model/DataTypeExt.h	36;"	d
SP_DEFINE_STRUCT_MEMBER_HELPER8	core/data_model/DataTypeExt.h	38;"	d
SP_DEF_BINOPField_NTUPLE	core/field/FieldExpression.h	135;"	d
SP_DEF_BINOPField_NTUPLE	core/field/FieldExpression.h	162;"	d
SP_ITERATOR_FILTER_H_	core/gtl/iterator/sp_iterator_filter.h	9;"	d
SP_ITERATOR_H_	core/gtl/iterator/iterator.h	9;"	d
SP_ITERATOR_INDEX_BASE_H_	core/gtl/iterator/sp_iterator_index_base.h	9;"	d
SP_ITERATOR_MAPPED_H_	core/gtl/iterator/sp_iterator_mapped.h	9;"	d
SP_NEW	core/io/IOStream.h	/^    SP_NEW = 1UL << 1,$/;"	e	enum:simpla::io::__anon5
SP_OBJECT_HEAD	core/base/Object.h	129;"	d
SP_PARTICLE_LOAD_DICT	core/particle/ParticleEngine.h	298;"	d
SP_PARTICLE_LOAD_DICT_CHOOSE_HELPER	core/particle/ParticleEngine.h	297;"	d
SP_PARTICLE_LOAD_DICT_CHOOSE_HELPER1	core/particle/ParticleEngine.h	296;"	d
SP_PARTICLE_LOAD_DICT_HELPER10	core/particle/ParticleEngine.h	285;"	d
SP_PARTICLE_LOAD_DICT_HELPER12	core/particle/ParticleEngine.h	287;"	d
SP_PARTICLE_LOAD_DICT_HELPER14	core/particle/ParticleEngine.h	289;"	d
SP_PARTICLE_LOAD_DICT_HELPER16	core/particle/ParticleEngine.h	291;"	d
SP_PARTICLE_LOAD_DICT_HELPER18	core/particle/ParticleEngine.h	293;"	d
SP_PARTICLE_LOAD_DICT_HELPER2	core/particle/ParticleEngine.h	278;"	d
SP_PARTICLE_LOAD_DICT_HELPER4	core/particle/ParticleEngine.h	279;"	d
SP_PARTICLE_LOAD_DICT_HELPER6	core/particle/ParticleEngine.h	281;"	d
SP_PARTICLE_LOAD_DICT_HELPER8	core/particle/ParticleEngine.h	283;"	d
SP_PARTICLE_UPDATE_PROP	core/particle/ParticleEngine.h	320;"	d
SP_PARTICLE_UPDATE_PROP_CHOOSE_HELPER	core/particle/ParticleEngine.h	319;"	d
SP_PARTICLE_UPDATE_PROP_CHOOSE_HELPER1	core/particle/ParticleEngine.h	318;"	d
SP_PARTICLE_UPDATE_PROP_HELPER10	core/particle/ParticleEngine.h	307;"	d
SP_PARTICLE_UPDATE_PROP_HELPER12	core/particle/ParticleEngine.h	309;"	d
SP_PARTICLE_UPDATE_PROP_HELPER14	core/particle/ParticleEngine.h	311;"	d
SP_PARTICLE_UPDATE_PROP_HELPER16	core/particle/ParticleEngine.h	313;"	d
SP_PARTICLE_UPDATE_PROP_HELPER18	core/particle/ParticleEngine.h	315;"	d
SP_PARTICLE_UPDATE_PROP_HELPER2	core/particle/ParticleEngine.h	300;"	d
SP_PARTICLE_UPDATE_PROP_HELPER4	core/particle/ParticleEngine.h	301;"	d
SP_PARTICLE_UPDATE_PROP_HELPER6	core/particle/ParticleEngine.h	303;"	d
SP_PARTICLE_UPDATE_PROP_HELPER8	core/particle/ParticleEngine.h	305;"	d
SP_PROPERTIES_DEFINE_MEMBER	core/particle/ParticleEngine.h	167;"	d
SP_PROPERTIES_DEFINE_MEMBER_CHOOSE_HELPER	core/particle/ParticleEngine.h	166;"	d
SP_PROPERTIES_DEFINE_MEMBER_CHOOSE_HELPER1	core/particle/ParticleEngine.h	165;"	d
SP_PROPERTIES_DEFINE_MEMBER_HELPER10	core/particle/ParticleEngine.h	154;"	d
SP_PROPERTIES_DEFINE_MEMBER_HELPER12	core/particle/ParticleEngine.h	156;"	d
SP_PROPERTIES_DEFINE_MEMBER_HELPER14	core/particle/ParticleEngine.h	158;"	d
SP_PROPERTIES_DEFINE_MEMBER_HELPER16	core/particle/ParticleEngine.h	160;"	d
SP_PROPERTIES_DEFINE_MEMBER_HELPER18	core/particle/ParticleEngine.h	162;"	d
SP_PROPERTIES_DEFINE_MEMBER_HELPER2	core/particle/ParticleEngine.h	143;"	d
SP_PROPERTIES_DEFINE_MEMBER_HELPER4	core/particle/ParticleEngine.h	148;"	d
SP_PROPERTIES_DEFINE_MEMBER_HELPER6	core/particle/ParticleEngine.h	150;"	d
SP_PROPERTIES_DEFINE_MEMBER_HELPER8	core/particle/ParticleEngine.h	152;"	d
SP_RECORD	core/io/IOStream.h	/^    SP_RECORD = (1UL << 4)$/;"	e	enum:simpla::io::__anon5
SP_TYPE_TRAITS_H_	core/gtl/type_traits.h	9;"	d
SUB_ID_MASK	core/manifold/mesh/MeshIds.h	/^    static constexpr id_type SUB_ID_MASK = ((1UL << MESH_RESOLUTION) - 1);$/;"	m	struct:simpla::mesh::MeshEntityIdCoder
SURFACE_H_	core/geometry/obsolete/surface.h	9;"	d
Scatter	applications/particle_solver/pic_engine_deltaf2.h	/^	inline typename std::enable_if<!isnTuple<TV>::value, void>::type Scatter(Point_s const &p,$/;"	f	struct:simpla::PICEngineDeltaF
Scatter	applications/particle_solver/pic_engine_deltaf2.h	/^	inline void Scatter(Point_s const &p, Field<mesh_type, IFORM, TV>* J, Others const &... others) const$/;"	f	struct:simpla::PICEngineDeltaF
Scatter	applications/particle_solver/pic_engine_ggauge.h	/^	void Scatter(Point_s const & p, TJ * J, Args const & ...) const$/;"	f	class:simpla::PICEngineGGauge
Scatter	applications/particle_solver/pic_engine_implicit.h	/^	void Scatter(Point_s const & p, J_type * J) const$/;"	f	struct:simpla::PICEngineImplicit
Scatter	applications/particle_solver/pic_engine_implicit.h	/^	void Scatter(Point_s const & p, rho_type * n) const$/;"	f	struct:simpla::PICEngineImplicit
ScatterJ	applications/particle_solver/pic_engine_fullf.h	/^	void ScatterJ(Point_s const & p, TJ * J) const$/;"	f	class:simpla::PICEngineFullF
ScatterRho	applications/particle_solver/pic_engine_fullf.h	/^	void ScatterRho(Point_s const & p, TJ * rho) const$/;"	f	class:simpla::PICEngineFullF
Search	cpplint.py	/^def Search(pattern, s):$/;"	f
Second Version	docs/tex/FDTD_Plasma.tex	/^\\end{comment}$/;"	P
Select	scripts/configure/cold_plasma.lua	/^     Select=function(x,y,z)$/;"	f
Select	scripts/configure/demo2.lua	/^     Select=function(x,y,z)$/;"	f
Select	scripts/configure/icrf.lua	/^     Select=function(x,y,z)$/;"	f
Select	scripts/configure/test.lua	/^Select=function(x,y,z)$/;"	f
Select	scripts/demo.lua	/^		Select=function(x)$/;"	f
Serialize	core/gtl/utilities/lua_object.cpp	/^std::basic_ostream<char> &LuaObject::Serialize(std::basic_ostream<char> &os)$/;"	f	class:simpla::lua::LuaObject
SetBaseUnit	core/physics/PhysicalConstants.cpp	/^void PhysicalConstants::SetBaseUnit(std::string const &type, double pm, double ps, double pkg, double pC, double pK,$/;"	f	class:simpla::PhysicalConstants
SetCountingStyle	cpplint.py	/^  def SetCountingStyle(self, counting_style):$/;"	m	class:_CppLintState
SetDefaultValue	core/field/test/trash/fetl_test3.h	/^	void SetDefaultValue(T* v)$/;"	f	class:TestFETL
SetDefaultValue	core/field/test/trash/fetl_test3.h	/^	void SetDefaultValue(nTuple<T, N>* v)$/;"	f	class:TestFETL
SetDefaultValue	core/field/test/trash/fetl_test3.h	/^	void SetDefaultValue(std::complex<T>* v)$/;"	f	class:TestFETL
SetFileName	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^    void SetFileName(char *fileName) { this->FileName = fileName; }$/;"	f	class:vtkAMRSimPlaReader::pimpl_s
SetFileName	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^void vtkAMRSimPlaReader::SetFileName(const char *fileName)$/;"	f	class:vtkAMRSimPlaReader
SetFilters	cpplint.py	/^  def SetFilters(self, filters):$/;"	m	class:_CppLintState
SetOutputFormat	cpplint.py	/^  def SetOutputFormat(self, output_format):$/;"	m	class:_CppLintState
SetOutputTimesteps	scripts/PostProcesse/particle_time_scripts.py	/^def SetOutputTimesteps(algorithm, timesteps):$/;"	f
SetUp	core/field/test/field_basic_algebra_test.h	/^    virtual void SetUp()$/;"	f	class:TestField
SetUp	core/field/test/field_diff_calculus_test.h	/^    void SetUp()$/;"	f	class:FETLTest
SetUp	core/field/test/field_dummy.cpp	/^	void SetUp()$/;"	f	class:FieldTest
SetUp	core/field/test/field_io_test.h	/^	virtual void SetUp()$/;"	f	class:simpla::TestFieldIO
SetUp	core/field/test/trash/fetl_test2.h	/^	virtual void SetUp()$/;"	f	class:TestField
SetUp	core/field/test/trash/fetl_test3.h	/^	void SetUp()$/;"	f	class:TestFETL
SetUp	core/field/test/trash/field_basic_test.h	/^	void SetUp()$/;"	f	class:TestField
SetUp	core/geometry/test/geometry_test.cpp	/^	virtual void SetUp()$/;"	f	class:TestModel
SetUp	core/gtl/test/ntuple_perf_test.cpp	/^	virtual void SetUp()$/;"	f	class:nTuplePerf1	file:
SetUp	core/gtl/test/ntuple_perf_test.cpp	/^	virtual void SetUp()$/;"	f	class:nTuplePerf2	file:
SetUp	core/gtl/test/ntuple_reduce_test.cpp	/^	virtual void SetUp()$/;"	f	class:TestNtupleReduce
SetUp	core/gtl/test/sp_iterator_test.cpp	/^	virtual void SetUp()$/;"	f	class:TestIterator
SetUp	core/model/test/model_test.cpp	/^	virtual void SetUp()$/;"	f	class:TestModel
SetUp	core/parallel/test/distributed_array_test.cpp	/^	virtual void SetUp()$/;"	f	class:TestDistArray
SetUp	core/particle/test/kinetic_particle_test.cpp	/^	virtual void SetUp()$/;"	f	class:TestKineticParticle
SetUp	core/particle/test/kinetic_particle_test.h	/^	virtual void SetUp()$/;"	f	class:TestKineticParticle
SetUpDataArraySelections	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^void vtkAMRSimPlaReader::SetUpDataArraySelections()$/;"	f	class:vtkAMRSimPlaReader
SetVerboseLevel	cpplint.py	/^  def SetVerboseLevel(self, level):$/;"	m	class:_CppLintState
SetupParticleDataSelections	plugins/vtk_reader/vtkAMRSimPlaParticlesReader.cpp	/^void vtkAMRSimPlaParticlesReader::SetupParticleDataSelections()$/;"	f	class:vtkAMRSimPlaParticlesReader
ShowBit	core/gtl/utilities/log.h	/^inline std::string ShowBit(unsigned long s)$/;"	f	namespace:simpla::logger
ShowCopyRight	core/gtl/utilities/logo.cpp	/^std::string ShowCopyRight()$/;"	f	namespace:simpla
ShowLogo	core/gtl/utilities/logo.cpp	/^std::string ShowLogo()$/;"	f	namespace:simpla
ShowVersion	core/gtl/utilities/logo.cpp	/^std::string ShowVersion()$/;"	f	namespace:simpla
Signal	core/gtl/design_pattern/signal.h	/^struct Signal<TResult(Args...)>$/;"	s	namespace:simpla
SimpleParticleEngine	core/particle/obsolete/simple_particle.h	/^	SimpleParticleEngine()$/;"	f	struct:simpla::SimpleParticleEngine
SimpleParticleEngine	core/particle/obsolete/simple_particle.h	/^struct SimpleParticleEngine$/;"	s	namespace:simpla
SingletonHolder	core/gtl/design_pattern/singleton_holder.h	/^	SingletonHolder()$/;"	f	class:simpla::SingletonHolder
SingletonHolder	core/gtl/design_pattern/singleton_holder.h	/^class SingletonHolder$/;"	c	namespace:simpla
Slot	core/gtl/design_pattern/signal.h	/^    Slot(Slot &&other) :$/;"	f	struct:simpla::Signal::Slot
Slot	core/gtl/design_pattern/signal.h	/^    Slot(Slot const &other) :$/;"	f	struct:simpla::Signal::Slot
Slot	core/gtl/design_pattern/signal.h	/^    Slot(TFun const &fun) : m_tracker_(nullptr)$/;"	f	struct:simpla::Signal::Slot
Slot	core/gtl/design_pattern/signal.h	/^    Slot(callback_type const &callback) :$/;"	f	struct:simpla::Signal::Slot
Slot	core/gtl/design_pattern/signal.h	/^    Slot(std::shared_ptr<T> &o_ptr, TRes2 (T::*pfun)(Args ...))$/;"	f	struct:simpla::Signal::Slot
Slot	core/gtl/design_pattern/signal.h	/^struct Signal<TResult(Args...)>::Slot$/;"	s	class:simpla::Signal
SpApp	core/task_flow/application.h	/^    SpApp()$/;"	f	struct:simpla::SpApp
SpApp	core/task_flow/application.h	/^struct SpApp$/;"	s	namespace:simpla
SpAppList	core/task_flow/application.h	/^struct SpAppList : public std::map<std::string, std::shared_ptr<SpApp>>$/;"	s	namespace:simpla
SpHashContainer	core/gtl/containers/sp_hash_container.h	/^	SpHashContainer()$/;"	f	struct:simpla::SpHashContainer
SpHashContainer	core/gtl/containers/sp_hash_container.h	/^	SpHashContainer(hash_function const & fun, size_t max_hash = 0)$/;"	f	struct:simpla::SpHashContainer
SpHashContainer	core/gtl/containers/sp_hash_container.h	/^	SpHashContainer(this_type && other)$/;"	f	struct:simpla::SpHashContainer
SpHashContainer	core/gtl/containers/sp_hash_container.h	/^	SpHashContainer(this_type const & other)$/;"	f	struct:simpla::SpHashContainer
SpHashContainer	core/gtl/containers/sp_hash_container.h	/^struct SpHashContainer$/;"	s	namespace:simpla
SparseContainer	core/gtl/containers/container_sparse.h	/^    SparseContainer() :$/;"	f	class:simpla::SparseContainer
SparseContainer	core/gtl/containers/container_sparse.h	/^    SparseContainer(TR const &, size_t max_hash_value, THash const &, Others &&... others) :$/;"	f	class:simpla::SparseContainer
SparseContainer	core/gtl/containers/container_sparse.h	/^    SparseContainer(TR const &, size_t max_hash_value, THash const &, value_type d, Others &&... others) :$/;"	f	class:simpla::SparseContainer
SparseContainer	core/gtl/containers/container_sparse.h	/^    SparseContainer(this_type &&rhs) :$/;"	f	class:simpla::SparseContainer
SparseContainer	core/gtl/containers/container_sparse.h	/^    SparseContainer(this_type const &rhs) :$/;"	f	class:simpla::SparseContainer
SparseContainer	core/gtl/containers/container_sparse.h	/^    SparseContainer(value_type d) :$/;"	f	class:simpla::SparseContainer
SparseContainer	core/gtl/containers/container_sparse.h	/^class SparseContainer : public std::map<TI, TV>$/;"	c	namespace:simpla
Sphere	core/geometry/obsolete/geometry_object.h	/^struct Sphere$/;"	s	namespace:simpla::geometry_object
Spherical	core/geometry/CoordinateSystem.h	/^struct Spherical$/;"	s	namespace:simpla::geometry::coordinate_system
Split	cpplint.py	/^  def Split(self):$/;"	m	class:FileInfo
SquareMap	core/manifold/mesh/GeneralMap.h	/^    SquareMap() { }$/;"	f	struct:simpla::mesh::SquareMap
SquareMap	core/manifold/mesh/GeneralMap.h	/^struct SquareMap$/;"	s	namespace:simpla::mesh
StandardEndLine	core/gtl/utilities/log.h	/^    typedef StdCoutType &(*StandardEndLine)(StdCoutType &);$/;"	t	class:simpla::logger::Logger
StdCoutType	core/gtl/utilities/log.h	/^    typedef std::basic_ostream<char, std::char_traits<char> > StdCoutType;$/;"	t	class:simpla::logger::Logger
StoragePolicy	core/manifold/policy/StoragePolicy.h	/^    StoragePolicy(geometry_type &geo) : m_geo_(geo) { }$/;"	f	struct:simpla::manifold::policy::StoragePolicy
StoragePolicy	core/manifold/policy/StoragePolicy.h	/^struct StoragePolicy$/;"	s	namespace:simpla::manifold::policy
StorageSharedContainer	core/gtl/iterator/sp_iterator_shared_container.h	/^struct StorageSharedContainer<T*>$/;"	s	namespace:simpla::_impl
StorageSharedContainer	core/gtl/iterator/sp_iterator_shared_container.h	/^template<typename T> struct StorageSharedContainer$/;"	s	namespace:simpla::_impl
SubdivisionRatio	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^    double SubdivisionRatio[3];$/;"	m	class:vtkAMRSimPlaReaderBlock	file:
Surface	core/geometry/model.h	/^struct Surface$/;"	s	namespace:simpla::geometry::model
Surface	core/geometry/obsolete/surface.h	/^	Surface(mesh_type const & m)$/;"	f	class:simpla::Surface
Surface	core/geometry/obsolete/surface.h	/^class Surface: public std::map<typename TM::id_type, std::tuple<Real, Vec3>>$/;"	c	namespace:simpla
T	applications/fokker_planck/lhw.cpp	/^	Real T;$/;"	m	struct:PICDeltaF	file:
T0	applications/particle_solver/pic_engine_deltaf2.h	/^	Field<mesh_type, VERTEX, Real> T0;$/;"	m	struct:simpla::PICEngineDeltaF
TAG_CELL	core/io/XDMFStream.h	/^        TAG_NODE = 0, TAG_EDGE = 1, TAG_FACE = 2, TAG_CELL = 3$/;"	e	enum:simpla::io::XDMFStream::__anon6
TAG_EDGE	core/io/XDMFStream.h	/^        TAG_NODE = 0, TAG_EDGE = 1, TAG_FACE = 2, TAG_CELL = 3$/;"	e	enum:simpla::io::XDMFStream::__anon6
TAG_EDGE0	core/manifold/mesh/MeshIds.h	/^        TAG_EDGE0 = 1,$/;"	e	enum:simpla::mesh::MeshEntityIdCoder::node_id_tag
TAG_EDGE1	core/manifold/mesh/MeshIds.h	/^        TAG_EDGE1 = 2,$/;"	e	enum:simpla::mesh::MeshEntityIdCoder::node_id_tag
TAG_EDGE2	core/manifold/mesh/MeshIds.h	/^        TAG_EDGE2 = 4,$/;"	e	enum:simpla::mesh::MeshEntityIdCoder::node_id_tag
TAG_FACE	core/io/XDMFStream.h	/^        TAG_NODE = 0, TAG_EDGE = 1, TAG_FACE = 2, TAG_CELL = 3$/;"	e	enum:simpla::io::XDMFStream::__anon6
TAG_FACE0	core/manifold/mesh/MeshIds.h	/^        TAG_FACE0 = 6,$/;"	e	enum:simpla::mesh::MeshEntityIdCoder::node_id_tag
TAG_FACE1	core/manifold/mesh/MeshIds.h	/^        TAG_FACE1 = 5,$/;"	e	enum:simpla::mesh::MeshEntityIdCoder::node_id_tag
TAG_FACE2	core/manifold/mesh/MeshIds.h	/^        TAG_FACE2 = 3,$/;"	e	enum:simpla::mesh::MeshEntityIdCoder::node_id_tag
TAG_NODE	core/io/XDMFStream.h	/^        TAG_NODE = 0, TAG_EDGE = 1, TAG_FACE = 2, TAG_CELL = 3$/;"	e	enum:simpla::io::XDMFStream::__anon6
TAG_VERTEX	core/manifold/mesh/MeshIds.h	/^        TAG_VERTEX = 0,$/;"	e	enum:simpla::mesh::MeshEntityIdCoder::node_id_tag
TAG_VOLUME	core/manifold/mesh/MeshIds.h	/^        TAG_VOLUME = 7$/;"	e	enum:simpla::mesh::MeshEntityIdCoder::node_id_tag
TASK	core/task_flow/task.h	85;"	d
TB	core/phy_solver/em_fluid.h	/^    typedef traits::field_t<scalar_type, mesh_type, FACE> TB;$/;"	t	class:simpla::phy_solver::EMFluid
TB	example/em_tokamak/tokamak.cpp	/^    typedef traits::field_t<scalar_type, mesh_type, FACE> TB;$/;"	t	struct:simpla::EMTokamak	file:
TE	core/phy_solver/em_fluid.h	/^    typedef traits::field_t<scalar_type, mesh_type, EDGE> TE;$/;"	t	class:simpla::phy_solver::EMFluid
TE	example/em_tokamak/tokamak.cpp	/^    typedef traits::field_t<scalar_type, mesh_type, EDGE> TE;$/;"	t	struct:simpla::EMTokamak	file:
TEMPLATE_DISPATCH	core/gtl/macro.h	32;"	d
TEMPLATE_DISPATCH_DEFAULT	core/gtl/macro.h	41;"	d
TERMINATE	core/gtl/utilities/parse_command_line.h	/^	CONTINUE = 0, TERMINATE = 1$/;"	e	enum:simpla::__anon11
TEST	core/geometry/test/metric_test.cpp	/^TEST(MetricTest, volume)$/;"	f
TEST	core/gtl/test/properties_test.cpp	/^TEST(properties,set)$/;"	f
TEST	core/io/test/data_stream_test.cpp	/^TEST(datastream,write)$/;"	f
TEST	core/manifold/test/geometry_test.cpp	/^TEST(GeometryTest, RectMesh)$/;"	f
TEST	core/manifold/test/mesh_ids_test.cpp	/^TEST(GeometryTest, MeshIDs)$/;"	f
TEST	core/manifold/test/mesh_patch_test.cpp	/^TEST(MeshMultiBlock, RectMesh)$/;"	f
TEST_F	core/particle/test/kinetic_particle_test.cpp	/^TEST_F(TestKineticParticle,insert)$/;"	f
TEST_P	core/field/test/field_diff_calculus_test.h	/^TEST_P(FETLTest, curl1)$/;"	f
TEST_P	core/field/test/field_diff_calculus_test.h	/^TEST_P(FETLTest, curl2)$/;"	f
TEST_P	core/field/test/field_diff_calculus_test.h	/^TEST_P(FETLTest, diverge1)$/;"	f
TEST_P	core/field/test/field_diff_calculus_test.h	/^TEST_P(FETLTest, diverge2)$/;"	f
TEST_P	core/field/test/field_diff_calculus_test.h	/^TEST_P(FETLTest, grad0)$/;"	f
TEST_P	core/field/test/field_diff_calculus_test.h	/^TEST_P(FETLTest, grad3)$/;"	f
TEST_P	core/field/test/field_diff_calculus_test.h	/^TEST_P(FETLTest, identity_curl_grad_f0_eq_0)$/;"	f
TEST_P	core/field/test/field_diff_calculus_test.h	/^TEST_P(FETLTest, identity_curl_grad_f3_eq_0)$/;"	f
TEST_P	core/field/test/field_diff_calculus_test.h	/^TEST_P(FETLTest, identity_div_curl_f1_eq0)$/;"	f
TEST_P	core/field/test/field_diff_calculus_test.h	/^TEST_P(FETLTest, identity_div_curl_f2_eq0)$/;"	f
TEST_P	core/field/test/trash/fetl_test3.h	/^TEST_P(TestFETL, curl1)$/;"	f
TEST_P	core/field/test/trash/fetl_test3.h	/^TEST_P(TestFETL, curl2)$/;"	f
TEST_P	core/field/test/trash/fetl_test3.h	/^TEST_P(TestFETL, diverge1)$/;"	f
TEST_P	core/field/test/trash/fetl_test3.h	/^TEST_P(TestFETL, diverge2)$/;"	f
TEST_P	core/field/test/trash/fetl_test3.h	/^TEST_P(TestFETL, grad0)$/;"	f
TEST_P	core/field/test/trash/fetl_test3.h	/^TEST_P(TestFETL, grad3)$/;"	f
TEST_P	core/field/test/trash/fetl_test3.h	/^TEST_P(TestFETL, identity_curl_grad_f0_eq_0)$/;"	f
TEST_P	core/field/test/trash/fetl_test3.h	/^TEST_P(TestFETL, identity_curl_grad_f3_eq_0)$/;"	f
TEST_P	core/field/test/trash/fetl_test3.h	/^TEST_P(TestFETL, identity_div_curl_f1_eq0)$/;"	f
TEST_P	core/field/test/trash/fetl_test3.h	/^TEST_P(TestFETL, identity_div_curl_f2_eq0)$/;"	f
TEST_P	core/field/test/trash/fetl_test4.h	/^TEST_P(TestFETL ,vec_zero_form)$/;"	f
TEST_P	core/gtl/test/sp_iterator_test.cpp	/^TEST_P(TestIterator,Add)$/;"	f
TEST_P	core/parallel/test/distributed_array_test.cpp	/^TEST_P(TestDistArray, updateGhost)$/;"	f
TEST_P	core/parallel/test/distributed_array_test.cpp	/^TEST_P(TestDistArray, updateGhostVec)$/;"	f
TEST_P	core/particle/test/kinetic_particle_test.h	/^TEST_P(TestKineticParticle, scatter_n)$/;"	f
TEST_P	core/particle/test/kinetic_particle_test.h	/^TEST_P(TestKineticParticle,Add)$/;"	f
THROW_EXCEPTION	core/gtl/utilities/log.h	362;"	d
THROW_EXCEPTION_BAD_ALLOC	core/gtl/utilities/log.h	377;"	d
THROW_EXCEPTION_BAD_CAST	core/gtl/utilities/log.h	381;"	d
THROW_EXCEPTION_LOGIC_ERROR	core/gtl/utilities/log.h	369;"	d
THROW_EXCEPTION_OUT_OF_RANGE	core/gtl/utilities/log.h	372;"	d
THROW_EXCEPTION_PARSER_ERROR	core/gtl/utilities/log.h	385;"	d
THROW_EXCEPTION_RUNTIME_ERROR	core/gtl/utilities/log.h	366;"	d
TJ	core/phy_solver/em_fluid.h	/^    typedef traits::field_t<scalar_type, mesh_type, EDGE> TJ;$/;"	t	class:simpla::phy_solver::EMFluid
TJ	example/em_tokamak/tokamak.cpp	/^    typedef traits::field_t<scalar_type, mesh_type, EDGE> TJ;$/;"	t	struct:simpla::EMTokamak	file:
TJv	core/phy_solver/em_fluid.h	/^    typedef traits::field_t<vector_type, mesh_type, VERTEX> TJv;$/;"	t	class:simpla::phy_solver::EMFluid
TJv	example/em_tokamak/tokamak.cpp	/^    typedef traits::field_t<vector_type, mesh_type, VERTEX> TJv;$/;"	t	struct:simpla::EMTokamak	file:
TMESH	core/field/test/trash/fetl_Cartesian_kz_test.cpp	13;"	d	file:
TMESH	core/field/test/trash/fetl_Cylindrical_kz_test.cpp	19;"	d	file:
TMESH	core/field/test/trash/fetl_Cylindrical_test.cpp	12;"	d	file:
TManifold	core/field/test/trash/fetl_test3.h	/^		FiniteDiffMehtod, InterpolatorLinear> TManifold;$/;"	t
TManifold	core/particle/test/particle_test.cpp	/^typedef Manifold<CartesianCoordinate<RectMesh> > TManifold;$/;"	t	file:
TManifold	core/particle/test/probe_particle_test.cpp	/^typedef Manifold<CartesianCoordinate<RectMesh> > TManifold;$/;"	t	file:
TParticles	applications/contexts/explicit_em.h	/^    typedef std::map<std::string, std::shared_ptr<ParticleBase> > TParticles;$/;"	t	struct:simpla::ExplicitEMContext
TREE	core/io/XDMFStream.h	/^        UNIFORM = 0, COLLECTION_TEMPORAL = 1, TREE = 2$/;"	e	enum:simpla::io::XDMFStream::__anon7
TRY_IT	core/gtl/utilities/log.h	390;"	d
TRY_IT1	core/gtl/utilities/log.h	392;"	d
TRho	core/phy_solver/em_fluid.h	/^    typedef traits::field_t<scalar_type, mesh_type, VERTEX> TRho;$/;"	t	class:simpla::phy_solver::EMFluid
TRho	example/em_tokamak/tokamak.cpp	/^    typedef traits::field_t<scalar_type, mesh_type, VERTEX> TRho;$/;"	t	struct:simpla::EMTokamak	file:
TWOBITS	core/geometry/obsolete/line_cliping.h	/^	size_t TWOBITS = 10; \/* flag for 2-bit code *\/$/;"	m	class:simpla::polygon_clip
TWOPI	core/physics/Constants.h	/^constexpr double TWOPI = 2.0 * PI;$/;"	v
TYPED_TEST	core/gtl/test/ntuple_perf_test.cpp	/^TYPED_TEST(nTuplePerf1, performancenTuple){$/;"	f
TYPED_TEST	core/gtl/test/ntuple_perf_test.cpp	/^TYPED_TEST(nTuplePerf1,performance_raw_array){$/;"	f
TYPED_TEST	core/gtl/test/ntuple_perf_test.cpp	/^TYPED_TEST(nTuplePerf2, performancenTuple){$/;"	f
TYPED_TEST	core/gtl/test/ntuple_perf_test.cpp	/^TYPED_TEST(nTuplePerf2,performance_raw_array){$/;"	f
TYPED_TEST	core/gtl/test/ntuple_reduce_test.cpp	/^TYPED_TEST(TestNtupleReduce , reduce){$/;"	f
TYPED_TEST	core/gtl/test/ntuple_reduce_test.cpp	/^TYPED_TEST(TestNtupleReduce, equation ){$/;"	f
TYPED_TEST	core/gtl/test/ntuple_reduce_test.cpp	/^TYPED_TEST(TestNtupleReduce, inner_product){$/;"	f
TYPED_TEST_P	core/field/test/field_basic_algebra_test.h	/^TYPED_TEST_P(TestField, assign)$/;"	f
TYPED_TEST_P	core/field/test/field_basic_algebra_test.h	/^TYPED_TEST_P(TestField, constant_real)$/;"	f
TYPED_TEST_P	core/field/test/field_basic_algebra_test.h	/^TYPED_TEST_P(TestField, index)$/;"	f
TYPED_TEST_P	core/field/test/field_basic_algebra_test.h	/^TYPED_TEST_P(TestField, scalarField)$/;"	f
TYPED_TEST_P	core/field/test/field_io_test.h	/^TYPED_TEST_P(TestFieldIO, write)$/;"	f	namespace:simpla
TYPED_TEST_P	core/field/test/trash/fetl_test2.h	/^TYPED_TEST_P(TestField, vector_arithmetic)$/;"	f
TYPED_TEST_P	core/field/test/trash/field_basic_test.h	/^TYPED_TEST_P(TestField, assign){$/;"	f
TYPED_TEST_P	core/field/test/trash/field_basic_test.h	/^TYPED_TEST_P(TestField, constant_real){$/;"	f
TYPED_TEST_P	core/field/test/trash/field_basic_test.h	/^TYPED_TEST_P(TestField, index){$/;"	f
TYPED_TEST_P	core/field/test/trash/field_basic_test.h	/^TYPED_TEST_P(TestField, scalarField){$/;"	f
TYPED_TEST_P	core/geometry/test/geometry_test.cpp	/^TYPED_TEST_P(TestModel,SelectByMaterial ){$/;"	f
TYPED_TEST_P	core/geometry/test/geometry_test.cpp	/^TYPED_TEST_P(TestModel,SelectByNGP){$/;"	f
TYPED_TEST_P	core/geometry/test/geometry_test.cpp	/^TYPED_TEST_P(TestModel,SelectByPolylines ){$/;"	f
TYPED_TEST_P	core/geometry/test/geometry_test.cpp	/^TYPED_TEST_P(TestModel,SelectByRectangle ){$/;"	f
TYPED_TEST_P	core/model/test/model_test.cpp	/^TYPED_TEST_P(TestModel,SelectByMaterial ){$/;"	f
TYPED_TEST_P	core/model/test/model_test.cpp	/^TYPED_TEST_P(TestModel,SelectByNGP){$/;"	f
TYPED_TEST_P	core/model/test/model_test.cpp	/^TYPED_TEST_P(TestModel,SelectByPolylines ){$/;"	f
TYPED_TEST_P	core/model/test/model_test.cpp	/^TYPED_TEST_P(TestModel,SelectByRectangle ){$/;"	f
T_	applications/particle_solver/pic_engine_ggauge.h	/^	Real cmr_, T_, vT_;$/;"	m	class:simpla::PICEngineGGauge
Task	core/task_flow/task.h	/^    Task() { };$/;"	f	class:simpla::task_flow::Task
Task	core/task_flow/task.h	/^class Task : public TaskBase$/;"	c	namespace:simpla::task_flow
Task	core/task_flow/task_flow.h	/^struct Task$/;"	s
TaskBase	core/task_flow/task_flow_base.h	/^struct TaskBase$/;"	s	namespace:simpla::task_flow
TaskRegistry	core/task_flow/task.h	/^struct TaskRegistry$/;"	s	namespace:simpla::task_flow::_impl
Tcc	core/geometry/obsolete/line_cliping.h	/^	size_t Tcc[15] =$/;"	m	class:simpla::polygon_clip
TearDown	core/field/test/field_diff_calculus_test.h	/^    void TearDown() { std::shared_ptr<mesh_type>(nullptr).swap(mesh); }$/;"	f	class:FETLTest
TearDown	core/field/test/field_dummy.cpp	/^	void TearDown()$/;"	f	class:FieldTest
Tensor	core/geometry/primitive.h	/^struct Tensor$/;"	s	namespace:simpla::geometry::model
TestDistArray	core/parallel/test/distributed_array_test.cpp	/^class TestDistArray: public testing::TestWithParam<nTuple<size_t, 3> >$/;"	c	file:
TestFETL	core/field/test/trash/fetl_test3.h	/^class TestFETL: public testing::TestWithParam<$/;"	c
TestField	core/field/test/field_basic_algebra_test.h	/^TYPED_TEST_CASE_P(TestField);$/;"	v
TestField	core/field/test/field_basic_algebra_test.h	/^class TestField : public testing::Test$/;"	c
TestField	core/field/test/trash/fetl_test2.h	/^TYPED_TEST_CASE_P(TestField);$/;"	v
TestField	core/field/test/trash/fetl_test2.h	/^class TestField: public testing::Test$/;"	c
TestField	core/field/test/trash/field_basic_test.h	/^TYPED_TEST_CASE_P(TestField);$/;"	v
TestField	core/field/test/trash/field_basic_test.h	/^class TestField: public testing::Test$/;"	c
TestFieldIO	core/field/test/field_io_test.h	/^class TestFieldIO : public testing::Test$/;"	c	namespace:simpla
TestFieldParam	core/field/test/trash/field_simple_mesh_shared_ptr_test.cpp	/^struct TestFieldParam$/;"	s	file:
TestIterator	core/gtl/test/sp_iterator_test.cpp	/^class TestIterator: public testing::TestWithParam<nTuple<3, size_t> >$/;"	c	file:
TestKineticParticle	core/particle/test/kinetic_particle_test.cpp	/^class TestKineticParticle: public testing::Test$/;"	c	file:
TestKineticParticle	core/particle/test/kinetic_particle_test.h	/^class TestKineticParticle: public testing::TestWithParam<SimpleMesh>$/;"	c
TestModel	core/geometry/test/geometry_test.cpp	/^TYPED_TEST_CASE_P(TestModel);$/;"	v
TestModel	core/geometry/test/geometry_test.cpp	/^class TestModel: public testing::Test$/;"	c	file:
TestModel	core/model/test/model_test.cpp	/^TYPED_TEST_CASE_P(TestModel);$/;"	v
TestModel	core/model/test/model_test.cpp	/^class TestModel: public testing::Test$/;"	c	file:
TestNtupleReduce	core/gtl/test/ntuple_reduce_test.cpp	/^class TestNtupleReduce: public testing::Test$/;"	c	file:
TheEnd	core/gtl/utilities/logo.cpp	/^void TheEnd(int flag)$/;"	f	namespace:simpla
TheStart	core/gtl/utilities/logo.cpp	/^void TheStart(int flag)$/;"	f	namespace:simpla
Time domain difference scheme	docs/tex/FDTD_Plasma.tex	/^coefficient. $/;"	P
TimeIntegrator	core/manifold/obsoleted/time_integrator_policy.h	/^    TimeIntegrator(TGeo &geo) : m_geo_(geo) { }$/;"	f	struct:simpla::manifold::policy::TimeIntegrator
TimeIntegrator	core/manifold/obsoleted/time_integrator_policy.h	/^struct TimeIntegrator<TGeo, Policy...>$/;"	s	namespace:simpla::manifold::policy
Toroidal	core/geometry/CoordinateSystem.h	/^struct Toroidal$/;"	s	namespace:simpla::geometry::coordinate_system
TracerParticleAttributeNames	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^    std::vector<std::string> TracerParticleAttributeNames;$/;"	m	class:vtkAMRSimPlaReader::pimpl_s	file:
Tracker	core/gtl/design_pattern/signal.h	/^        Tracker(std::shared_ptr<T> &obj) : m_ptr_(obj)$/;"	f	struct:simpla::Signal::Slot::Tracker
Tracker	core/gtl/design_pattern/signal.h	/^    struct Tracker : public AbstractTracker$/;"	s	struct:simpla::Signal::Slot
TransformIterator	core/gtl/iterator/sp_iterator_shared_container.h	/^	TransformIterator(conatiner_type &d, key_iterator const & ib, key_iterator const&)$/;"	f	class:simpla::TransformIterator
TransformIterator	core/gtl/iterator/sp_iterator_shared_container.h	/^	TransformIterator(container_type & container, key_iterator_type const & ib)$/;"	f	class:simpla::TransformIterator
TransformIterator	core/gtl/iterator/sp_iterator_shared_container.h	/^	TransformIterator(this_type const & other)$/;"	f	class:simpla::TransformIterator
TransformIterator	core/gtl/iterator/sp_iterator_shared_container.h	/^class TransformIterator: public StorageContainerPolicy<TContainer>$/;"	c	namespace:simpla
TransformRevolve	core/model/obsoleted/trans_revolve.h	/^    TransformRevolve() { };$/;"	f	struct:simpla::TransformRevolve
TransformRevolve	core/model/obsoleted/trans_revolve.h	/^struct TransformRevolve$/;"	s	namespace:simpla
TypeCast	core/gtl/type_traits_ext.h	/^template<typename TV, typename TR> inline TV TypeCast(TR const& obj)$/;"	f	namespace:simpla
TypeParamList	core/field/test/field_basic_algebra_test.cpp	/^> TypeParamList;$/;"	t	file:
TypeParamList	core/field/test/trash/field_basic_algebra_Cartesian_test.cpp	/^> TypeParamList;$/;"	t	file:
TypeParamList	core/field/test/trash/field_basic_algebra_cylindrical_test.cpp	/^> TypeParamList;$/;"	t	file:
TypeParamList	core/field/test/trash/field_simple_mesh_shared_ptr_test.cpp	/^> TypeParamList;$/;"	t	file:
U	example/misc/demo_misc.cpp	/^struct U$/;"	s	file:
UNDEFINE_FUNCTION	core/gtl/utilities/log.h	333;"	d
UNIFORM	core/io/XDMFStream.h	/^        UNIFORM = 0, COLLECTION_TEMPORAL = 1, TREE = 2$/;"	e	enum:simpla::io::XDMFStream::__anon7
UNIMPLEMENTED	core/gtl/utilities/log.h	324;"	d
UNIMPLEMENTED2	core/gtl/utilities/log.h	331;"	d
USE_CASE	core/task_flow/use_case.h	99;"	d
USE_CASE	example/general_field_op/demo_general_field_op.cpp	/^USE_CASE(general_field_op, "General field operation")$/;"	f
USE_CASE	example/model/demo_model.cpp	/^USE_CASE(model,"Model")$/;"	f	namespace:simpla
USE_CASE	example/pic/demo_pic.cpp	/^USE_CASE(pic, " particle in cell")$/;"	f
USE_CASE	example/probe_particle/demo_probe_particle.cpp	/^USE_CASE(demo_probe_particle)$/;"	f
UTILITIES_H_	core/gtl/utilities/misc_utilities.h	9;"	d
Undefine	core/gtl/expression_template.h	/^struct Undefine$/;"	s	namespace:simpla
UnorderedSet	core/gtl/containers/UnorderedSet.h	/^UnorderedSet<ValueType, Key>::UnorderedSet()$/;"	f	class:simpla::gtl::UnorderedSet
UnorderedSet	core/gtl/containers/UnorderedSet.h	/^class UnorderedSet : public parallel::concurrent_hash_map<Key, std::list<ValueType>>$/;"	c	namespace:simpla::gtl
UnorderedSet	core/gtl/containers/unordered_set.h	/^    UnorderedSet()$/;"	f	class:simpla::UnorderedSet
UnorderedSet	core/gtl/containers/unordered_set.h	/^    UnorderedSet(this_type &&other) :$/;"	f	class:simpla::UnorderedSet
UnorderedSet	core/gtl/containers/unordered_set.h	/^    UnorderedSet(this_type &other, TRange const &range)$/;"	f	class:simpla::UnorderedSet
UnorderedSet	core/gtl/containers/unordered_set.h	/^    UnorderedSet(this_type const &other) :$/;"	f	class:simpla::UnorderedSet
UnorderedSet	core/gtl/containers/unordered_set.h	/^class UnorderedSet$/;"	c	namespace:simpla
Unregister	core/gtl/design_pattern/factory.h	/^	int Unregister(identifier_type const & id)$/;"	f	struct:simpla::Factory
UpdateIncludeState	cpplint.py	/^def UpdateIncludeState(filename, include_state, io=codecs):$/;"	f
UseCase	core/task_flow/use_case.h	/^    UseCase()$/;"	f	class:simpla::use_case::UseCase
UseCase	core/task_flow/use_case.h	/^class UseCase$/;"	c	namespace:simpla::use_case
UseCaseList	core/task_flow/use_case.h	/^class UseCaseList : public std::map<std::string, std::shared_ptr<UseCase>>$/;"	c	namespace:simpla::use_case
VACUUM	core/model/obsoleted/model.h	/^        VACUUM = 1UL << 1,$/;"	e	enum:simpla::Model::__anon9
VERBOSE	core/gtl/utilities/log.h	346;"	d
VERBOSE_CMD	core/gtl/utilities/log.h	428;"	d
VERTEX	core/manifold/ManifoldTraits.h	/^    VERTEX = 0,$/;"	e	enum:simpla::ManifoldTypeID
VISITOR_H_	core/gtl/design_pattern/visitor.h	9;"	d
VOLUME	core/manifold/ManifoldTraits.h	/^    VOLUME = 3$/;"	e	enum:simpla::ManifoldTypeID
VTKAMRENZOPARTICLESREADER_H_	plugins/vtk_reader/vtkAMRSimPlaParticlesReader.h	25;"	d
VTKAMRENZOREADER_H_	plugins/vtk_reader/vtkAMRSimPlaReader.h	22;"	d
VTKIOAMR_EXPORT	plugins/vtk_reader/vtkAMRSimPlaReader.h	24;"	d
Value	scripts/configure/cold_plasma.lua	/^  	Value=function(t,x,y,z)	$/;"	f
Value	scripts/configure/demo_gfile.lua	/^  	Value=function(x,y,z,t)	$/;"	f
Value	scripts/configure/icrf.lua	/^  	Value=function(t,x,y,z)	$/;"	f
Value	scripts/configure/test.lua	/^			Value= function(x)$/;"	f
Value	scripts/demo.lua	/^Value= function(x)$/;"	f
Value 	example/em/demo_em.lua	/^        Value = function(x, t)$/;"	f
Value 	example/em/demo_em.lua	/^        Value = function(x, t, v)$/;"	f
Value 	example/em/em.lua	/^        Value = function(t, x)$/;"	f
Value 	example/em_tokamak/tokamak.lua	/^        Value = function(t, x)$/;"	f
Vec3	core/gtl/primitives.h	/^typedef nTuple<Real, 3> Vec3;$/;"	t	namespace:simpla
Vector	core/geometry/primitive.h	/^struct Vector$/;"	s	namespace:simpla::geometry::model
Visitor	core/gtl/design_pattern/visitor.h	/^    Visitor(Args ... args)$/;"	f	struct:simpla::Visitor
Visitor	core/gtl/design_pattern/visitor.h	/^struct Visitor : public VisitorBase$/;"	s	namespace:simpla
VisitorBase	core/gtl/design_pattern/visitor.h	/^    VisitorBase() { }$/;"	f	struct:simpla::VisitorBase
VisitorBase	core/gtl/design_pattern/visitor.h	/^struct VisitorBase$/;"	s	namespace:simpla
W	example/misc/demo_misc.cpp	/^struct W$/;"	s	file:
WARNING	core/gtl/utilities/log.h	317;"	d
Wedge	core/manifold/Calculus.h	/^struct Wedge$/;"	s	namespace:simpla::calculus::tags
Write	core/model/geqdsk_xdmf.cpp	/^void Write(std::string const &fname)$/;"	f	namespace:simpla
WriteBuffer	core/io/WriteBuffer.cpp	/^WriteBuffer::WriteBuffer(IOStream &os) : m_out_stream_(os) { }$/;"	f	class:simpla::io::WriteBuffer
WriteBuffer	core/io/WriteBuffer.h	/^class WriteBuffer$/;"	c	namespace:simpla::io
WriteBufferProxy	core/io/WriteBuffer.h	/^    WriteBufferProxy(HDF5Stream &os) : WriteBuffer(os) { WriteBuffer::data_type(data_model::DataType::create<T>()); }$/;"	f	class:simpla::io::WriteBufferProxy
WriteBufferProxy	core/io/WriteBuffer.h	/^class WriteBufferProxy : public WriteBuffer$/;"	c	namespace:simpla::io
X10	applications/field_solver/pml.h	/^	typename mesh_type:: template field<EDGE, scalar_type> X10, X11, X12;$/;"	m	class:simpla::PML
X11	applications/field_solver/pml.h	/^	typename mesh_type:: template field<EDGE, scalar_type> X10, X11, X12;$/;"	m	class:simpla::PML
X12	applications/field_solver/pml.h	/^	typename mesh_type:: template field<EDGE, scalar_type> X10, X11, X12;$/;"	m	class:simpla::PML
X20	applications/field_solver/pml.h	/^	typename mesh_type:: template field<FACE, scalar_type> X20, X21, X22;$/;"	m	class:simpla::PML
X21	applications/field_solver/pml.h	/^	typename mesh_type:: template field<FACE, scalar_type> X20, X21, X22;$/;"	m	class:simpla::PML
X22	applications/field_solver/pml.h	/^	typename mesh_type:: template field<FACE, scalar_type> X20, X21, X22;$/;"	m	class:simpla::PML
XAXIS	core/model/obsoleted/revolve_polygon.h	/^    static constexpr int XAXIS = (ZAXIS + 1) % 3;$/;"	m	struct:simpla::RevolvePolygon
XAXIS	core/model/obsoleted/trans_revolve.h	/^    static constexpr int XAXIS = (ZAXIS + 1) % 3;$/;"	m	struct:simpla::TransformRevolve
XDMFStream	core/io/XDMFStream.cpp	/^XDMFStream::XDMFStream()$/;"	f	class:simpla::io::XDMFStream
XDMFStream	core/io/XDMFStream.h	/^class XDMFStream$/;"	c	namespace:simpla::io
XDMF_IO_H_	core/io/XDMFIO.h	9;"	d
XdmfTypeTraits	core/io/XDMFIO.h	/^struct XdmfTypeTraits$/;"	s	namespace:simpla::io
YAXIS	core/model/obsoleted/revolve_polygon.h	/^    static constexpr int YAXIS = (ZAXIS + 2) % 3;$/;"	m	struct:simpla::RevolvePolygon
YAXIS	core/model/obsoleted/trans_revolve.h	/^    static constexpr int YAXIS = (ZAXIS + 2) % 3;$/;"	m	struct:simpla::TransformRevolve
ZAXIS	core/geometry/obsolete/polygon.h	/^	size_t ZAXIS = 2;$/;"	m	struct:simpla::PolyGon
ZAxis	core/field/test/field_diff_calculus_test.h	/^static constexpr const int ZAxis = cs::ZAxis;$/;"	v
ZAxis	core/geometry/CoordinateSystem.h	/^    static constexpr int ZAxis = (PhiAxis + 2) % 3;$/;"	m	struct:simpla::geometry::coordinate_system::Cylindrical
ZAxis	core/geometry/csCylindrical.h	/^    static constexpr int ZAxis = cs::ZAxis;$/;"	m	struct:simpla::geometry::Metric
ZAxis	core/model/GEqdsk.cpp	/^constexpr int GEqdsk::ZAxis;$/;"	m	class:simpla::GEqdsk	file:
ZAxis	core/model/GEqdsk.h	/^    static constexpr int ZAxis = (PhiAxis + 2) % 3;$/;"	m	class:simpla::GEqdsk
ZAxis	example/em/em.cpp	/^static constexpr const int ZAxis = cs::ZAxis;$/;"	v	file:
Zero	core/gtl/expression_template.h	/^struct Zero$/;"	s	namespace:simpla
_CHECK_MACROS	cpplint.py	/^_CHECK_MACROS = [$/;"	v
_CHECK_REPLACEMENT	cpplint.py	/^_CHECK_REPLACEMENT = dict([(m, {}) for m in _CHECK_MACROS])$/;"	v
_CPP_HEADERS	cpplint.py	/^_CPP_HEADERS = frozenset([$/;"	v
_CPP_SECTION	cpplint.py	/^  _CPP_SECTION = 3$/;"	v	class:_IncludeState
_CPP_SYS_HEADER	cpplint.py	/^_CPP_SYS_HEADER = 2$/;"	v
_C_SECTION	cpplint.py	/^  _C_SECTION = 2$/;"	v	class:_IncludeState
_C_SYS_HEADER	cpplint.py	/^_C_SYS_HEADER = 1$/;"	v
_ClassInfo	cpplint.py	/^class _ClassInfo(object):$/;"	c
_ClassState	cpplint.py	/^class _ClassState(object):$/;"	c
_ClassifyInclude	cpplint.py	/^def _ClassifyInclude(fileinfo, include, is_system):$/;"	f
_CollapseStrings	cpplint.py	/^  def _CollapseStrings(elided):$/;"	m	class:CleansedLines
_CppLintState	cpplint.py	/^class _CppLintState(object):$/;"	c
_D	core/manifold/mesh/MeshIds.h	/^    static constexpr id_type _D = 1UL << (MESH_RESOLUTION - 1);$/;"	m	struct:simpla::mesh::MeshEntityIdCoder
_DA	core/manifold/mesh/MeshIds.h	/^    static constexpr id_type _DA = _DI | _DJ | _DK;$/;"	m	struct:simpla::mesh::MeshEntityIdCoder
_DA	core/manifold/mesh/MeshIds.h	/^template<int L> constexpr typename MeshEntityIdCoder<L>::id_type MeshEntityIdCoder<L>::_DA;$/;"	m	class:simpla::mesh::MeshEntityIdCoder
_DEFAULT_FILTERS	cpplint.py	/^_DEFAULT_FILTERS = [ '-build\/include_alpha' ]$/;"	v
_DI	core/manifold/mesh/MeshIds.h	/^    static constexpr id_type _DI = _D;$/;"	m	struct:simpla::mesh::MeshEntityIdCoder
_DI	core/manifold/mesh/MeshIds.h	/^template<int L> constexpr typename MeshEntityIdCoder<L>::id_type MeshEntityIdCoder<L>::_DI;$/;"	m	class:simpla::mesh::MeshEntityIdCoder
_DJ	core/manifold/mesh/MeshIds.h	/^    static constexpr id_type _DJ = _D << (ID_DIGITS);$/;"	m	struct:simpla::mesh::MeshEntityIdCoder
_DJ	core/manifold/mesh/MeshIds.h	/^template<int L> constexpr typename MeshEntityIdCoder<L>::id_type MeshEntityIdCoder<L>::_DJ;$/;"	m	class:simpla::mesh::MeshEntityIdCoder
_DK	core/manifold/mesh/MeshIds.h	/^    static constexpr id_type _DK = _D << (ID_DIGITS * 2);$/;"	m	struct:simpla::mesh::MeshEntityIdCoder
_DK	core/manifold/mesh/MeshIds.h	/^template<int L> constexpr typename MeshEntityIdCoder<L>::id_type MeshEntityIdCoder<L>::_DK;$/;"	m	class:simpla::mesh::MeshEntityIdCoder
_DropCommonSuffixes	cpplint.py	/^def _DropCommonSuffixes(filename):$/;"	f
_ERROR_CATEGORIES	cpplint.py	/^_ERROR_CATEGORIES = [$/;"	v
_Filters	cpplint.py	/^def _Filters():$/;"	f
_FunctionState	cpplint.py	/^class _FunctionState(object):$/;"	c
_HEADERS_ACCEPTED_BUT_NOT_PROMOTED	cpplint.py	/^_HEADERS_ACCEPTED_BUT_NOT_PROMOTED = {$/;"	v
_HEADERS_CONTAINING_TEMPLATES	cpplint.py	/^_HEADERS_CONTAINING_TEMPLATES = ($/;"	v
_INITIAL_SECTION	cpplint.py	/^  _INITIAL_SECTION = 0$/;"	v	class:_IncludeState
_IncludeError	cpplint.py	/^class _IncludeError(Exception):$/;"	c
_IncludeState	cpplint.py	/^class _IncludeState(dict):$/;"	c
_IsTestFilename	cpplint.py	/^def _IsTestFilename(filename):$/;"	f
_LIKELY_MY_HEADER	cpplint.py	/^_LIKELY_MY_HEADER = 3$/;"	v
_MY_H_SECTION	cpplint.py	/^  _MY_H_SECTION = 1$/;"	v	class:_IncludeState
_NORMAL_TRIGGER	cpplint.py	/^  _NORMAL_TRIGGER = 250  # for --v=0, 500 for --v=1, etc.$/;"	v	class:_FunctionState
_OTHER_HEADER	cpplint.py	/^_OTHER_HEADER = 5$/;"	v
_OTHER_H_SECTION	cpplint.py	/^  _OTHER_H_SECTION = 4$/;"	v	class:_IncludeState
_OutputFormat	cpplint.py	/^def _OutputFormat():$/;"	f
_POSSIBLE_MY_HEADER	cpplint.py	/^_POSSIBLE_MY_HEADER = 4$/;"	v
_R	core/manifold/mesh/MeshIds.h	/^    static constexpr Real _R = static_cast<Real>(_D);$/;"	m	struct:simpla::mesh::MeshEntityIdCoder
_R	core/manifold/mesh/MeshIds.h	/^template<int L> constexpr Real MeshEntityIdCoder<L>::_R;$/;"	m	class:simpla::mesh::MeshEntityIdCoder
_RE_FIRST_COMPONENT	cpplint.py	/^_RE_FIRST_COMPONENT = re.compile(r'^[^-_.]+')$/;"	v
_RE_PATTERN_CLEANSE_LINE_C_COMMENTS	cpplint.py	/^_RE_PATTERN_CLEANSE_LINE_C_COMMENTS = re.compile($/;"	v
_RE_PATTERN_CLEANSE_LINE_DOUBLE_QUOTES	cpplint.py	/^_RE_PATTERN_CLEANSE_LINE_DOUBLE_QUOTES = re.compile(r'"[^"]*"')$/;"	v
_RE_PATTERN_CLEANSE_LINE_ESCAPES	cpplint.py	/^_RE_PATTERN_CLEANSE_LINE_ESCAPES = re.compile($/;"	v
_RE_PATTERN_CLEANSE_LINE_SINGLE_QUOTES	cpplint.py	/^_RE_PATTERN_CLEANSE_LINE_SINGLE_QUOTES = re.compile(r"'.'")$/;"	v
_RE_PATTERN_INCLUDE	cpplint.py	/^_RE_PATTERN_INCLUDE = re.compile(r'^\\s*#\\s*include\\s*([<"])([^>"]*)[>"].*$')$/;"	v
_RE_PATTERN_INCLUDE_NEW_STYLE	cpplint.py	/^_RE_PATTERN_INCLUDE_NEW_STYLE = re.compile(r'#include +"[^\/]+\\.h"')$/;"	v
_RE_PATTERN_INVALID_INCREMENT	cpplint.py	/^_RE_PATTERN_INVALID_INCREMENT = re.compile($/;"	v
_RE_PATTERN_STRING	cpplint.py	/^_RE_PATTERN_STRING = re.compile(r'\\bstring\\b')$/;"	v
_RE_PATTERN_TODO	cpplint.py	/^_RE_PATTERN_TODO = re.compile(r'^\/\/(\\s*)TODO(\\(.+?\\))?:?(\\s|$)?')$/;"	v
_RE_SUPPRESSION	cpplint.py	/^_RE_SUPPRESSION = re.compile(r'\\bNOLINT\\b(\\([^)]*\\))?')$/;"	v
_SECTION_NAMES	cpplint.py	/^  _SECTION_NAMES = {$/;"	v	class:_IncludeState
_SP_DEFINE_EXPR_ASSIGNMENT_OPERATOR	core/gtl/expression_template.h	469;"	d
_SP_DEFINE_EXPR_BINARY_BOOLEAN_OPERATOR	core/gtl/expression_template.h	481;"	d
_SP_DEFINE_EXPR_BINARY_FUNCTION	core/gtl/expression_template.h	503;"	d
_SP_DEFINE_EXPR_BINARY_OPERATOR	core/gtl/expression_template.h	455;"	d
_SP_DEFINE_EXPR_BINARY_RIGHT_OPERATOR	core/gtl/expression_template.h	449;"	d
_SP_DEFINE_EXPR_UNARY_BOOLEAN_OPERATOR	core/gtl/expression_template.h	496;"	d
_SP_DEFINE_EXPR_UNARY_FUNCTION	core/gtl/expression_template.h	518;"	d
_SP_DEFINE_EXPR_UNARY_OPERATOR	core/gtl/expression_template.h	475;"	d
_SP_DEFINE_nTuple_EXPR_BINARY_BOOLEAN_OPERATOR	core/gtl/ntuple.h	957;"	d
_SP_DEFINE_nTuple_EXPR_BINARY_FUNCTION	core/gtl/ntuple.h	767;"	d
_SP_DEFINE_nTuple_EXPR_BINARY_OPERATOR	core/gtl/ntuple.h	743;"	d
_SP_DEFINE_nTuple_EXPR_BINARY_RIGHT_OPERATOR	core/gtl/ntuple.h	736;"	d
_SP_DEFINE_nTuple_EXPR_UNARY_BOOLEAN_OPERATOR	core/gtl/ntuple.h	974;"	d
_SP_DEFINE_nTuple_EXPR_UNARY_FUNCTION	core/gtl/ntuple.h	784;"	d
_SP_DEFINE_nTuple_EXPR_UNARY_OPERATOR	core/gtl/ntuple.h	760;"	d
_STL_HEADERS	cpplint.py	/^_STL_HEADERS = frozenset([$/;"	v
_SetCountingStyle	cpplint.py	/^def _SetCountingStyle(level):$/;"	f
_SetFilters	cpplint.py	/^def _SetFilters(filters):$/;"	f
_SetOutputFormat	cpplint.py	/^def _SetOutputFormat(output_format):$/;"	f
_SetVerboseLevel	cpplint.py	/^def _SetVerboseLevel(level):$/;"	f
_ShouldPrintError	cpplint.py	/^def _ShouldPrintError(category, confidence, linenum):$/;"	f
_TEST_TRIGGER	cpplint.py	/^  _TEST_TRIGGER = 400    # about 50% more than _NORMAL_TRIGGER.$/;"	v	class:_FunctionState
_TYPE_NAMES	cpplint.py	/^  _TYPE_NAMES = {$/;"	v	class:_IncludeState
_VerboseLevel	cpplint.py	/^def _VerboseLevel():$/;"	f
__init__	cpplint.py	/^  def __init__(self):$/;"	m	class:_ClassState
__init__	cpplint.py	/^  def __init__(self):$/;"	m	class:_CppLintState
__init__	cpplint.py	/^  def __init__(self):$/;"	m	class:_FunctionState
__init__	cpplint.py	/^  def __init__(self):$/;"	m	class:_IncludeState
__init__	cpplint.py	/^  def __init__(self, filename):$/;"	m	class:FileInfo
__init__	cpplint.py	/^  def __init__(self, lines):$/;"	m	class:CleansedLines
__init__	cpplint.py	/^  def __init__(self, name, linenum):$/;"	m	class:_ClassInfo
__init__	scripts/PreProcess/input_geqdsk.py	/^    def __init__(selfparams):$/;"	m	class:GEQDSK
_assign	core/gtl/expression_template.h	/^struct _assign$/;"	s	namespace:simpla::_impl
_cpplint_state	cpplint.py	/^_cpplint_state = _CppLintState()$/;"	v
_error_suppressions	cpplint.py	/^_error_suppressions = {}$/;"	v
_identify	core/gtl/expression_template.h	/^struct _identify$/;"	s	namespace:simpla::_impl
_impl	core/data_model/DataSet.h	/^namespace _impl$/;"	n	namespace:simpla::data_model
_impl	core/field/obsoleted/field_constant.h	/^namespace _impl$/;"	n	namespace:simpla
_impl	core/gtl/any.h	/^namespace _impl$/;"	n	namespace:simpla
_impl	core/gtl/check_concept.h	/^namespace _impl$/;"	n	namespace:simpla::traits
_impl	core/gtl/concept_check.h	/^namespace _impl$/;"	n	namespace:simpla
_impl	core/gtl/expression_template.h	/^namespace _impl$/;"	n	namespace:simpla
_impl	core/gtl/iterator/sp_iterator_shared_container.h	/^namespace _impl$/;"	n	namespace:simpla
_impl	core/gtl/iterator/sp_ntuple_range.h	/^namespace _impl {$/;"	n	namespace:simpla
_impl	core/gtl/ntuple.h	/^namespace _impl$/;"	n	namespace:simpla
_impl	core/gtl/ntuple.h	/^namespace _impl$/;"	n	namespace:simpla::traits
_impl	core/gtl/type_traits.h	/^namespace _impl$/;"	n	namespace:simpla
_impl	core/gtl/type_traits.h	/^namespace _impl$/;"	n	namespace:simpla::traits
_impl	core/gtl/type_traits_ext.h	/^namespace _impl$/;"	n	namespace:simpla
_impl	core/gtl/utilities/lua_object.cpp	/^namespace _impl$/;"	n	namespace:simpla::lua	file:
_impl	core/gtl/utilities/lua_object_ext.h	/^namespace _impl$/;"	n	namespace:simpla::lua
_impl	core/gtl/utilities/pretty_stream.h	/^namespace _impl$/;"	n	namespace:std
_impl	core/manifold/obsoleted/amr_policy.h	/^namespace _impl$/;"	n	namespace:simpla::manifold::policy
_impl	core/manifold/obsoleted/patch/mesh_patch.h	/^namespace _impl$/;"	n	namespace:simpla::mesh
_impl	core/model/Constraint.h	/^namespace _impl$/;"	n	namespace:simpla::model
_impl	core/parallel/MPIDataType.h	/^namespace _impl$/;"	n	namespace:simpla
_impl	core/particle/obsolete/kinetic_particle.h	/^namespace _impl$/;"	n	namespace:simpla
_impl	core/task_flow/task.cpp	/^namespace simpla { namespace task_flow { namespace _impl$/;"	n	namespace:simpla::task_flow	file:
_impl	core/task_flow/task.h	/^namespace _impl$/;"	n	namespace:simpla::task_flow
_index_of	core/gtl/any.h	/^    std::shared_ptr<Base> _index_of(nTuple<V, N> const &v, int n) const$/;"	f	struct:simpla::Derived
_index_of	core/gtl/any.h	/^    template<typename T0, typename T1> std::shared_ptr<Base> _index_of(std::tuple<T0, T1> const &v, int n) const$/;"	f	struct:simpla::Derived
_index_of	core/gtl/any.h	/^    template<typename V> std::shared_ptr<Base> _index_of(V const &v, int n) const$/;"	f	struct:simpla::Derived
_invoke_helper	core/geometry/GeoObject.h	/^    inline int _invoke_helper(T const &p_tuple, index_sequence<I...>) const$/;"	f	class:simpla::geometry::GeoObject
_invoke_patch_helper	core/manifold/obsoleted/amr_policy.h	/^_invoke_patch_helper(size_t id, Field<Expression<TOP, Args...>> const &expr,$/;"	f	namespace:simpla::manifold::policy::_impl
_invoke_patch_helper	core/manifold/obsoleted/patch/mesh_patch.h	/^_invoke_patch_helper(size_t id, Field<Expression<TOP, Args...>> const &expr,$/;"	f	namespace:simpla::mesh::_impl
_iterator_policy_mapped	core/gtl/iterator/sp_iterator_mapped.h	/^class _iterator_policy_mapped$/;"	c	namespace:simpla
_make_error_msg	core/gtl/utilities/log.h	/^inline std::ostringstream &_make_error_msg(std::ostringstream &os)$/;"	f	namespace:simpla::logger
_make_msg	core/gtl/utilities/log.h	/^std::ostringstream &_make_msg(std::ostringstream &os, T const &first)$/;"	f	namespace:simpla::logger
_make_msg	core/gtl/utilities/log.h	/^std::ostringstream &_make_msg(std::ostringstream &os, T const &first, Others const &...others)$/;"	f	namespace:simpla::logger
_pow2	core/gtl/expression_template.h	/^struct _pow2$/;"	s	namespace:simpla::_impl
_re_pattern_algorithm_header	cpplint.py	/^_re_pattern_algorithm_header = []$/;"	v
_re_pattern_templates	cpplint.py	/^_re_pattern_templates = []$/;"	v
_regexp_compile_cache	cpplint.py	/^_regexp_compile_cache = {}$/;"	v
_seq_for	core/gtl/integer_sequence.h	/^struct _seq_for<0>$/;"	s	namespace:simpla::mpl
_seq_for	core/gtl/integer_sequence.h	/^struct _seq_for<M, N...>$/;"	s	namespace:simpla::mpl
_seq_for	core/gtl/integer_sequence.h	/^struct _seq_for<M>$/;"	s	namespace:simpla::mpl
_seq_reduce	core/gtl/integer_sequence.h	/^struct _seq_reduce<1, N...>$/;"	s	namespace:simpla::mpl
_seq_reduce	core/gtl/integer_sequence.h	/^struct _seq_reduce<>$/;"	s	namespace:simpla::mpl
_seq_reduce	core/gtl/integer_sequence.h	/^struct _seq_reduce<M, N...>$/;"	s	namespace:simpla::mpl
_size_of	core/gtl/any.h	/^    template<typename ...V> int _size_of(std::tuple<V ...> const &) const { return sizeof...(V); }$/;"	f	struct:simpla::Derived
_size_of	core/gtl/any.h	/^    template<typename V, int N, int ...M> int _size_of(nTuple<V, N, M...> const &) const { return N; }$/;"	f	struct:simpla::Derived
_size_of	core/gtl/any.h	/^    template<typename V> int _size_of(V const &) const { return 1; }$/;"	f	struct:simpla::Derived
_str_replace	core/io/XDMFStream.cpp	/^void _str_replace(std::string *s, std::string const &place_holder, std::string const &txt)$/;"	f	namespace:simpla::io
_swap	core/gtl/expression_template.h	/^struct _swap$/;"	s	namespace:simpla::_impl
_to_string	core/gtl/any.h	/^inline std::string _to_string(std::string const &v) { return (v); };$/;"	f	namespace:simpla::_impl
_to_string	core/gtl/any.h	/^std::string _to_string(T const &v) { return ""; };$/;"	f	namespace:simpla::_impl
a	core/gtl/test/ntuple_perf_test.cpp	/^	value_type a, b, c, d;$/;"	m	class:nTuplePerf1	file:
a	core/gtl/test/ntuple_perf_test.cpp	/^	value_type a, b, c, d;$/;"	m	class:nTuplePerf2	file:
a	core/gtl/test/ntuple_reduce_test.cpp	/^	value_type a, b, c, d;$/;"	m	class:TestNtupleReduce	file:
a	scripts/configure/test.py	/^a=ctx.getField("B0",2)$/;"	v
a0	applications/field_solver/pml.h	/^	typename mesh_type:: template field<VERTEX, Real> a0, a1, a2;$/;"	m	class:simpla::PML
a1	applications/field_solver/pml.h	/^	typename mesh_type:: template field<VERTEX, Real> a0, a1, a2;$/;"	m	class:simpla::PML
a2	applications/field_solver/pml.h	/^	typename mesh_type:: template field<VERTEX, Real> a0, a1, a2;$/;"	m	class:simpla::PML
aA	core/gtl/test/ntuple_perf_test.cpp	/^	value_type aA[N], aB[N], aC[N], aD[N], res[N];$/;"	m	class:nTuplePerf1	file:
aA	core/gtl/test/ntuple_perf_test.cpp	/^	value_type aA[N][M], aB[N][M], aC[N][M], aD[N][M], res[N][M];$/;"	m	class:nTuplePerf2	file:
aA	core/gtl/test/ntuple_reduce_test.cpp	/^	typename traits::pod_type<T>::type aA, aB, aC, aD, res;$/;"	m	class:TestNtupleReduce	file:
aB	core/gtl/test/ntuple_perf_test.cpp	/^	value_type aA[N], aB[N], aC[N], aD[N], res[N];$/;"	m	class:nTuplePerf1	file:
aB	core/gtl/test/ntuple_perf_test.cpp	/^	value_type aA[N][M], aB[N][M], aC[N][M], aD[N][M], res[N][M];$/;"	m	class:nTuplePerf2	file:
aB	core/gtl/test/ntuple_reduce_test.cpp	/^	typename traits::pod_type<T>::type aA, aB, aC, aD, res;$/;"	m	class:TestNtupleReduce	file:
aC	core/geometry/obsolete/line_cliping.h	/^	size_t aC; \/* used by procedure TwoBitEndPoint *\/$/;"	m	class:simpla::polygon_clip
aC	core/gtl/test/ntuple_perf_test.cpp	/^	value_type aA[N], aB[N], aC[N], aD[N], res[N];$/;"	m	class:nTuplePerf1	file:
aC	core/gtl/test/ntuple_perf_test.cpp	/^	value_type aA[N][M], aB[N][M], aC[N][M], aD[N][M], res[N][M];$/;"	m	class:nTuplePerf2	file:
aC	core/gtl/test/ntuple_reduce_test.cpp	/^	typename traits::pod_type<T>::type aA, aB, aC, aD, res;$/;"	m	class:TestNtupleReduce	file:
aD	core/gtl/test/ntuple_perf_test.cpp	/^	value_type aA[N], aB[N], aC[N], aD[N], res[N];$/;"	m	class:nTuplePerf1	file:
aD	core/gtl/test/ntuple_perf_test.cpp	/^	value_type aA[N][M], aB[N][M], aC[N][M], aD[N][M], res[N][M];$/;"	m	class:nTuplePerf2	file:
aD	core/gtl/test/ntuple_reduce_test.cpp	/^	typename traits::pod_type<T>::type aA, aB, aC, aD, res;$/;"	m	class:TestNtupleReduce	file:
a_type	core/geometry/primitive.h	/^    typedef typename area_type<CS>::type a_type;$/;"	t	struct:simpla::geometry::traits::volume_type
absolute_path	core/io/HDF5Stream.cpp	/^std::string HDF5Stream::absolute_path(std::string const &url) const$/;"	f	class:simpla::io::HDF5Stream
absorb	core/particle/ParticleConstraint.h	/^void absorb(Particle<P, M> &p, model::Surface<M> const &surface)$/;"	f	namespace:simpla::particle
acc	core/gtl/utilities/lua_object.h	/^        accessor acc() { return accessor(m_l_); }$/;"	f	struct:simpla::lua::LuaObject::LuaState
acc	core/gtl/utilities/lua_object.h	/^        const_accessor acc() const { return const_accessor(m_l_); }$/;"	f	struct:simpla::lua::LuaObject::LuaState
accept	core/base/Attribute.h	/^    void accept(TRange const &r0, Func const &fun)$/;"	f	class:simpla::base::Attribute
accept	core/field/FieldDense.h	/^    void accept(Args &&...args) { data()->accept(std::forward<Args>(args)...); }$/;"	f	class:simpla::Field
accept	core/gtl/design_pattern/visitor.h	/^    virtual void accept(VisitorBase &visitor)$/;"	f	struct:simpla::AcceptorBase
accept	core/gtl/design_pattern/visitor.h	/^    virtual void accept(VisitorBase const &visitor)$/;"	f	struct:simpla::AcceptorBase
accept	core/task_flow/task_flow_base.h	/^    virtual void accept(TaskBase &v) { v.visit(*this); };$/;"	f	class:simpla::task_flow::ContextBase
accept_signal	core/task_flow/use_case.h	/^    virtual void accept_signal() { };$/;"	f	class:simpla::use_case::UseCase
acceptor_type	core/gtl/design_pattern/visitor.h	/^    typedef TAcceptor acceptor_type;$/;"	t	struct:simpla::Visitor
access	core/geometry/boost_gemetry_adapted.h	/^struct access<sgm::Primitive<N, CS, TAG>, M>$/;"	s	namespace:boost::geometry::traits
access	core/gtl/ntuple.h	/^struct access<N, nTuple<T, M...> >$/;"	s	namespace:simpla::traits
access	core/gtl/type_traits.h	/^struct access$/;"	s	namespace:simpla::traits
access	core/gtl/type_traits.h	/^struct access<N, T *>$/;"	s	namespace:simpla::traits
access	core/gtl/type_traits.h	/^struct access<N, std::pair<T0, T1>>$/;"	s	namespace:simpla::traits
access	core/gtl/type_traits.h	/^struct access<N, std::tuple<T...>>$/;"	s	namespace:simpla::traits
access_helper	core/gtl/type_traits.h	/^struct access_helper<>$/;"	s	namespace:simpla::traits::_impl
access_helper	core/gtl/type_traits.h	/^struct access_helper<N0, N...>$/;"	s	namespace:simpla::traits::_impl
access_helper	core/gtl/type_traits.h	/^struct access_helper<N>$/;"	s	namespace:simpla::traits::_impl
accessor	core/gtl/utilities/lua_object.h	/^            accessor(std::shared_ptr<lua_s> const &l) : m_l_(l) { m_l_->m_mutex_.lock(); }$/;"	f	struct:simpla::lua::LuaObject::LuaState::accessor
accessor	core/gtl/utilities/lua_object.h	/^        struct accessor$/;"	s	struct:simpla::lua::LuaObject::LuaState
add	core/field/FieldDense.h	/^    void add(id_type const &s, Other const &other)$/;"	f	class:simpla::Field
add	core/gtl/utilities/lua_object.h	/^    inline void add(T const &v)$/;"	f	class:simpla::lua::LuaObject
add	core/parallel/DistributedObject.cpp	/^void DistributedObject::add(data_model::DataSet ds)$/;"	f	class:simpla::parallel::DistributedObject
add	core/parallel/DistributedObject.h	/^    void add(T &args)$/;"	f	struct:simpla::parallel::DistributedObject
add	core/parallel/DistributedObject.h	/^    void add(T *args)$/;"	f	struct:simpla::parallel::DistributedObject
add	core/parallel/DistributedObject.h	/^    void add(T const &args)$/;"	f	struct:simpla::parallel::DistributedObject
add	core/parallel/DistributedObject.h	/^    void add(T const &args, Others &&...others)$/;"	f	struct:simpla::parallel::DistributedObject
add	core/task_flow/use_case.h	/^    std::string add(std::string const &name)$/;"	f	class:simpla::use_case::UseCaseList
add	core/task_flow/use_case.h	/^    std::string add(std::string const &name, std::shared_ptr<T> const &p)$/;"	f	class:simpla::use_case::UseCaseList
add_filter	core/particle/Particle.h	/^    virtual void add_filter(std::string const &key,$/;"	f	struct:simpla::particle::Particle
add_gather	core/particle/Particle.h	/^void  Particle<P, M>::add_gather(::simpla::Field<TV, M, std::integral_constant<int, IFORM>, Policies...> &f)$/;"	f	class:simpla::particle::Particle
add_link_recv	core/parallel/DistributedObject.h	/^    void add_link_recv(nTuple<int, 3> const &coord_offset, Args &&...args)$/;"	f	struct:simpla::parallel::DistributedObject
add_link_recv	core/parallel/DistributedObject.h	/^    void add_link_recv(nTuple<int, 3> const &coord_offset, data_model::DataSet &ds)$/;"	f	struct:simpla::parallel::DistributedObject
add_link_send	core/parallel/DistributedObject.h	/^    inline void add_link_send(nTuple<int, 3> const &coord_offset, data_model::DataSet &ds)$/;"	f	struct:simpla::parallel::DistributedObject
add_link_send	core/parallel/DistributedObject.h	/^    void add_link_send(nTuple<int, 3> const &coord_offset, Args &&...args)$/;"	f	struct:simpla::parallel::DistributedObject
add_particle	core/phy_solver/em_fluid.h	/^    add_particle(std::string const &name, Real mass, Real charge)$/;"	f	class:simpla::phy_solver::EMFluid
add_particle	example/em_tokamak/tokamak.cpp	/^    add_particle(std::string const &name, Real mass, Real charge)$/;"	f	struct:simpla::EMTokamak
add_point	core/model/obsoleted/revolve_polygon.h	/^    void add_point(point_type const &p)$/;"	f	struct:simpla::RevolvePolygon
addr_	core/gtl/utilities/memory_pool.h	/^        void *addr_;$/;"	m	struct:simpla::MemoryPool::deleter_s
advance	core/gtl/array_view.h	/^    void advance(ptrdiff_t n)$/;"	f	struct:simpla::gtl::ArrayView::iterator
advance	core/gtl/iterator/block_iterator.h	/^    ptrdiff_t advance(ptrdiff_t n = 1)$/;"	f	struct:simpla::block_iterator
advance	core/parallel/ParallelRandomGenerator.h	/^    void advance(size_t n) { m_count_ += n; }$/;"	f	struct:simpla::parallel::DistributedCounter::input_iterator
alloc	core/geometry/obsolete/polygons.h	/^	int len, alloc;$/;"	m	struct:__anon2
allocate	core/field/test/trash/field_continue.h	/^	void allocate()$/;"	f	struct:simpla::Field
allocate	core/gtl/containers/container_dense.h	/^	void allocate()$/;"	f	class:simpla::DenseContainer
allocate	core/gtl/containers/container_sparse.h	/^    void allocate()$/;"	f	class:simpla::SparseContainer
allocate	core/gtl/containers/container_traits.h	/^	static holder_type allocate(size_t s)$/;"	f	struct:simpla::container_traits
allocator_type	core/gtl/containers/container_container.h	/^	typedef typename value_type::allocator_type allocator_type;$/;"	t	class:simpla::ContainerContainer
allocator_type	core/gtl/containers/unordered_set.h	/^    typedef Allocator allocator_type;$/;"	t	class:simpla::UnorderedSet
allreduce	core/parallel/MPIAuxFunctions.cpp	/^void allreduce(void const *send_data, void *recv_data, size_t count,$/;"	f	namespace:simpla::parallel
allreduce	core/parallel/MPIAuxFunctions.h	/^T allreduce(T send, std::string const &op_c = "Sum")$/;"	f	namespace:simpla::parallel
allreduce	core/parallel/MPIAuxFunctions.h	/^nTuple<T, DIMS> allreduce(nTuple<T, DIMS> const &send,$/;"	f	namespace:simpla::parallel
allreduce	core/parallel/MPIAuxFunctions.h	/^void allreduce(T *p_send, std::string const &op_c = "Sum")$/;"	f	namespace:simpla::parallel
allreduce	core/parallel/MPIAuxFunctions.h	/^void allreduce(T *send_data, T *recv_data, size_t count,$/;"	f	namespace:simpla::parallel
allreduce	core/parallel/MPIAuxFunctions.h	/^void allreduce(nTuple<T, DIMS> *p_send, std::string const &op_c = "Sum")$/;"	f	namespace:simpla::parallel
alpha_	applications/field_solver/pml.h	/^	inline Real alpha_(Real r, Real expN, Real dB)$/;"	f	class:simpla::PML
amr_policy	core/manifold/obsoleted/amr_policy.h	/^    typedef this_type amr_policy;$/;"	t	class:simpla::manifold::policy::AMR
anim	scripts/animation.py	/^anim = animation.FuncAnimation(fig,animate ,frames=range(720),interval=20,blit=False,repeat=True)$/;"	v
animate	scripts/animation.py	/^def animate(iter):$/;"	f
any	core/gtl/any.h	/^    any(U &&value) : ptr_(new Derived<typename std::decay<U>::type>(std::forward<U>(value))) { }$/;"	f	struct:simpla::any
any	core/gtl/any.h	/^    any(any &other) : ptr_(other.clone()) { }$/;"	f	struct:simpla::any
any	core/gtl/any.h	/^    any(any const &other) : ptr_(other.clone()) { }$/;"	f	struct:simpla::any
any	core/gtl/any.h	/^    any(void) { }$/;"	f	struct:simpla::any
any	core/gtl/any.h	/^struct any$/;"	s	namespace:simpla
append	core/gtl/Properties.h	/^    this_type &append(this_type const &other)$/;"	f	class:simpla::Properties
append_ntuple	core/gtl/ntuple.h	/^nTuple<TV, N> append_ntuple(T1 const &v0, TV const &v1)$/;"	f	namespace:simpla::traits
apply	core/field/FieldDense.h	/^    void apply(TOP const &op, this_type &f, Args &&... args)$/;"	f	class:simpla::Field
apply	core/manifold/obsoleted/mesh_graph.h	/^    template<typename TV, int IFORM> void apply(DataSet *ds)$/;"	f	struct:simpla::mesh::MeshMapEdge
apply	core/model/obsoleted/trans_revolve.h	/^    point_type *apply(point_type *p) const$/;"	f	struct:simpla::TransformRevolve
apply_filter	core/particle/Particle.h	/^    virtual void apply_filter()$/;"	f	struct:simpla::particle::Particle
area	core/geometry/cube.h	/^typename traits::area_type<CS>::type area($/;"	f	namespace:simpla::geometry
area	core/geometry/simplex.h	/^typename traits::area_type<CS>::type area($/;"	f	namespace:simpla::geometry
area_type	core/geometry/primitive.h	/^template<typename CS> struct area_type$/;"	s	namespace:simpla::geometry::traits
argc	core/gtl/utilities/config_parser.h	/^    int argc;$/;"	m	struct:simpla::ConfigParser
args	core/gtl/expression_template.h	/^            args;$/;"	m	struct:simpla::Expression
args_	core/gtl/design_pattern/visitor.h	/^    std::tuple<Args...> args_;$/;"	m	struct:simpla::Visitor
args_tuple_type	core/gtl/design_pattern/visitor.h	/^    typedef std::tuple<Args...> args_tuple_type;$/;"	t	struct:simpla::Visitor
argv	core/gtl/utilities/config_parser.h	/^    char **argv;$/;"	m	struct:simpla::ConfigParser
as	core/gtl/any.h	/^    U as(U const &def_v) const$/;"	f	struct:simpla::any
as	core/gtl/any.h	/^    bool as(U *v) const$/;"	f	struct:simpla::Base
as	core/gtl/any.h	/^    bool as(nTuple<U, N> *v) const$/;"	f	struct:simpla::Base
as	core/gtl/any.h	/^    template<class U> U as() const$/;"	f	struct:simpla::any
as	core/gtl/any.h	/^    template<class U> bool as(U *v) const { return ptr_ != nullptr && ptr_->as(v); }$/;"	f	struct:simpla::any
as	core/gtl/utilities/config_parser.h	/^        T as() const$/;"	f	struct:simpla::ConfigParser::DictObject
as	core/gtl/utilities/config_parser.h	/^        T as(T const &default_value) const$/;"	f	struct:simpla::ConfigParser::DictObject
as	core/gtl/utilities/config_parser.h	/^        bool as(Properties *v) const$/;"	f	struct:simpla::ConfigParser::DictObject
as	core/gtl/utilities/config_parser.h	/^        void as(T *v) const$/;"	f	struct:simpla::ConfigParser::DictObject
as	core/gtl/utilities/lua_object.h	/^    inline T as() const$/;"	f	class:simpla::lua::LuaObject
as	core/gtl/utilities/lua_object.h	/^    inline T as(T const &default_value) const$/;"	f	class:simpla::lua::LuaObject
as	core/gtl/utilities/lua_object.h	/^    inline bool as(T *res) const$/;"	f	class:simpla::lua::LuaObject
as	core/gtl/utilities/lua_object.h	/^    void as(std::function<TRect(Args ...)> *res) const$/;"	f	class:simpla::lua::LuaObject
as_tuple	core/gtl/utilities/lua_object.h	/^    inline std::tuple<T...> as_tuple() const { return std::move(as<std::tuple<T...>>()); }$/;"	f	class:simpla::lua::LuaObject
assamble_tuple	core/gtl/mpl.h	/^struct assamble_tuple$/;"	s	namespace:simpla::mpl
assamble_tuple	core/gtl/mpl.h	/^struct assamble_tuple<H,std::tuple<P...>>$/;"	s	namespace:simpla::mpl
assign	core/field/FieldDense.h	/^    void assign(id_type const &s, Other const &other)$/;"	f	class:simpla::Field
assign	core/gtl/containers/unordered_set.h	/^    void assign(IputIterator first, IputIterator last)$/;"	f	class:simpla::UnorderedSet
assign	core/gtl/containers/unordered_set.h	/^    void assign(key_type const &key, Others &&...others)$/;"	f	class:simpla::UnorderedSet
assign	core/gtl/ntuple.h	/^    void assign(Op const &op, TR const &rhs)$/;"	f	struct:simpla::nTuple
assign_cast	core/gtl/type_cast.h	/^T assign_cast(U const & s)$/;"	f	namespace:simpla
assigne_nTuple_helper	core/gtl/ntuple.h	/^assigne_nTuple_helper(nTuple<T, M...> &lhs, std::integral_constant<int, 0> const, Others &&... others)$/;"	f	namespace:simpla::traits::_impl
assigne_nTuple_helper	core/gtl/ntuple.h	/^assigne_nTuple_helper(nTuple<T, N, M...> &lhs, std::integral_constant<int, I> const, T0 const &a0,$/;"	f	namespace:simpla::traits::_impl
at	core/base/Attribute.h	/^    value_type &at(id_type const &s) { return m_data_.get()[this->mesh().hash(s)]; }$/;"	f	class:simpla::base::Attribute
at	core/base/Attribute.h	/^    value_type const &at(id_type const &s) const { return m_data_.get()[this->mesh().hash(s)]; }$/;"	f	class:simpla::base::Attribute
at	core/field/FieldFunction.h	/^    value_type at(id_type const &s) const$/;"	f	class:simpla::Field
at	core/gtl/containers/container_container.h	/^	value_type & at(key_type s)$/;"	f	class:simpla::ContainerContainer
at	core/gtl/containers/container_container.h	/^	value_type const & at(key_type s) const$/;"	f	class:simpla::ContainerContainer
at	core/gtl/containers/container_dense.h	/^	value_type & at(key_type s)$/;"	f	class:simpla::DenseContainer
at	core/gtl/containers/container_dense.h	/^	value_type const & at(key_type s) const$/;"	f	class:simpla::DenseContainer
at	core/gtl/containers/container_sparse.h	/^    value_type &at(key_type s)$/;"	f	class:simpla::SparseContainer
at	core/gtl/containers/container_sparse.h	/^    value_type const &at(key_type s) const$/;"	f	class:simpla::SparseContainer
at	core/gtl/containers/unordered_set.h	/^    bucket_type &at(key_type const &key)$/;"	f	class:simpla::UnorderedSet
at	core/gtl/containers/unordered_set.h	/^    bucket_type const &at(key_type const &key) const$/;"	f	class:simpla::UnorderedSet
at	core/gtl/ntuple.h	/^    sub_type &at(int s)$/;"	f	struct:simpla::nTuple
at	core/gtl/ntuple.h	/^    sub_type const &at(int s) const$/;"	f	struct:simpla::nTuple
at	core/gtl/utilities/lua_object.cpp	/^LuaObject LuaObject::at(int s) const$/;"	f	class:simpla::lua::LuaObject
at	core/gtl/utilities/lua_object.cpp	/^LuaObject LuaObject::at(size_t const &s) const$/;"	f	class:simpla::lua::LuaObject
at	core/model/obsoleted/model.h	/^    tag_type &at(id_type s)$/;"	f	class:simpla::Model
at	core/model/obsoleted/model.h	/^    tag_type const &at(id_type s) const$/;"	f	class:simpla::Model
at	core/task_flow/task.h	/^    virtual std::shared_ptr<TaskBase> at(std::string const &k) const$/;"	f	struct:simpla::task_flow::_impl::TaskRegistry
attribute	core/field/FieldDense.h	/^    std::shared_ptr<const attribute_type> attribute() const { return m_data_; }$/;"	f	class:simpla::Field
attribute_holder_type	core/manifold/Manifold.h	/^    typedef std::map<std::string, std::weak_ptr<AttributeEntity>> attribute_holder_type;$/;"	t	class:simpla::Manifold
attribute_type	core/field/FieldDense.h	/^    typedef typename mesh_type::template Attribute<value_type, iform> attribute_type;$/;"	t	class:simpla::Field
attribute_type	core/manifold/obsoleted/patch/mesh_patch.h	/^    typedef typename mesh_type::template Attribute<value_type, iform> attribute_type;$/;"	t	class:simpla::mesh::PatchPolicy
attributes	core/manifold/Manifold.h	/^    attribute_holder_type &attributes() { return m_attributes_; };$/;"	f	class:simpla::Manifold
attributes	core/manifold/Manifold.h	/^    attribute_holder_type const &attributes() const { return m_attributes_; };$/;"	f	class:simpla::Manifold
auto_increase_file_name	core/io/IOStream.cpp	/^std::string IOStream::auto_increase_file_name(std::string filename, std::string const &ext_str) const$/;"	f	class:simpla::io::IOStream
b	core/gtl/test/ntuple_perf_test.cpp	/^	value_type a, b, c, d;$/;"	m	class:nTuplePerf1	file:
b	core/gtl/test/ntuple_perf_test.cpp	/^	value_type a, b, c, d;$/;"	m	class:nTuplePerf2	file:
b	core/gtl/test/ntuple_reduce_test.cpp	/^	value_type a, b, c, d;$/;"	m	class:TestNtupleReduce	file:
b_	core/gtl/iterator/iterator_sequence.h	/^	TI b_;$/;"	m	class:simpla::IteratorSequence
b_it_	core/gtl/iterator/sp_iterator_mapped.h	/^	base_iterator b_it_;$/;"	m	struct:simpla::Iterator
barrier	core/parallel/MPIComm.cpp	/^void MPIComm::barrier()$/;"	f	class:simpla::parallel::MPIComm
base	core/base/Attribute.h	/^namespace simpla { namespace base$/;"	n	namespace:simpla
base	core/base/DataObject.cpp	/^namespace simpla { namespace base$/;"	n	namespace:simpla	file:
base	core/base/DataObject.h	/^namespace simpla { namespace base$/;"	n	namespace:simpla
base	core/base/LifeClick.h	/^namespace simpla { namespace base$/;"	n	namespace:simpla
base	core/base/Object.cpp	/^namespace simpla { namespace base$/;"	n	namespace:simpla	file:
base	core/base/Object.h	/^namespace simpla { namespace base$/;"	n	namespace:simpla
base	core/base/Patch.h	/^namespace simpla { namespace base$/;"	n	namespace:simpla
base_container_type	core/gtl/containers/container_container.h	/^	typedef std::map<key_type, value_type> base_container_type;$/;"	t	class:simpla::ContainerContainer
base_container_type	core/gtl/containers/container_sparse.h	/^    typedef std::map <key_type, value_type> base_container_type;$/;"	t	class:simpla::SparseContainer
base_container_type	core/gtl/containers/unordered_set.h	/^    typedef std::map<key_type, bucket_type> base_container_type;$/;"	t	class:simpla::UnorderedSet
base_file_id_	core/io/HDF5Stream.cpp	/^    hid_t base_file_id_;$/;"	m	struct:simpla::io::HDF5Stream::pimpl_s	file:
base_group_id_	core/io/HDF5Stream.cpp	/^    hid_t base_group_id_;$/;"	m	struct:simpla::io::HDF5Stream::pimpl_s	file:
base_iterator	core/gtl/containers/iterator_proxy.h	/^	typedef TIterator base_iterator;$/;"	t	struct:simpla::iterator_proxy
base_iterator	core/gtl/iterator/indirect_iterator.h	/^	typedef typename std::iterator_traits<src_iterator>::value_type base_iterator;$/;"	t	struct:simpla::indirect_iterator
base_iterator	core/gtl/iterator/iterator_cycle.h	/^	typedef TI base_iterator;$/;"	t	struct:simpla::iterator_cycle
base_iterator	core/gtl/iterator/sp_iterator_cycle.h	/^	typedef TBaseIterator base_iterator;$/;"	t	struct:simpla::CycleIterator
base_iterator	core/gtl/iterator/sp_iterator_filter.h	/^	typedef BaseIterator base_iterator;$/;"	t	struct:simpla::sp_fliter_iterator
base_iterator	core/gtl/iterator/sp_iterator_mapped.h	/^	typedef typename conatiner_type::iterator base_iterator;$/;"	t	struct:simpla::Iterator
base_iterator	core/gtl/iterator/sp_range_filter.h	/^	typedef typename base_range::iterator base_iterator;$/;"	t	struct:simpla::FilterRange
base_iterator_type	core/gtl/iterator/sp_indirect_iterator.h	/^    typedef BaseIterator base_iterator_type;$/;"	t	struct:simpla::sp_indirect_iterator
base_manifold	example/pic/demo_pic.h	/^	typedef TBase base_manifold;$/;"	t	struct:simpla::FiberBundle
base_range	core/gtl/iterator/sp_range_filter.h	/^	typedef BaseRange base_range;$/;"	t	struct:simpla::FilterRange
base_type	applications/contexts/explicit_em.h	/^    typedef ContextBase base_type;$/;"	t	struct:simpla::ExplicitEMContext
base_type	core/base/Attribute.h	/^    typedef AttributeEntity<TMesh> base_type;$/;"	t	class:simpla::base::Attribute
base_type	core/base/Attribute.h	/^    typedef AttributeObject base_type;$/;"	t	class:simpla::base::AttributeEntity
base_type	core/geometry/implicit_function.h	/^	typedef Expression<_impl::logical_and, TL, std::nullptr_t> base_type;$/;"	t	struct:simpla::ImplicitFunction
base_type	core/geometry/implicit_function.h	/^	typedef Expression<_impl::logical_not, TL, std::nullptr_t> base_type;$/;"	t	struct:simpla::ImplicitFunction
base_type	core/geometry/implicit_function.h	/^	typedef Expression<_impl::negate, TL, std::nullptr_t> base_type;$/;"	t	struct:simpla::ImplicitFunction
base_type	core/geometry/implicit_function.h	/^	typedef Expression<_impl::plus, TL, std::nullptr_t> base_type;$/;"	t	struct:simpla::ImplicitFunction
base_type	core/geometry/obsolete/surface.h	/^	typedef std::map<id_type, std::tuple<Real, Vec3>> base_type;$/;"	t	class:simpla::Surface
base_type	core/gtl/containers/UnorderedSet.h	/^    typedef typename parallel::concurrent_hash_map<Key, bucket_type> base_type;$/;"	t	class:simpla::gtl::UnorderedSet
base_type	core/gtl/iterator/block_iterator.h	/^            nTuple<TV, NDIMS>, ptrdiff_t> base_type;$/;"	t	struct:simpla::block_iterator
base_type	core/gtl/utilities/log.h	/^    typedef std::ostringstream base_type;$/;"	t	class:simpla::logger::Logger
base_type	core/manifold/mesh/CoRectMesh.h	/^    typedef block_type base_type;$/;"	t	struct:simpla::mesh::Mesh
base_type	core/manifold/mesh/MeshIds.h	/^        typedef block_iterator<index_type, ndims + 1> base_type;$/;"	t	struct:simpla::mesh::MeshEntityIdCoder::iterator
base_type	core/manifold/mesh/RectMesh.h	/^    typedef block_type base_type;$/;"	t	struct:simpla::mesh::Mesh
base_type	core/manifold/policy/IOPolicy.h	/^    typedef io::XDMFStream base_type;$/;"	t	struct:simpla::manifold::policy::IOPolicy
base_type	core/parallel/obsoleted/distributed.h	/^	typedef TBase base_type;$/;"	t	class:simpla::Distributed
base_type	core/parallel/obsoleted/distributed_unordered_set.h	/^	typedef UnorderedSet<TV, Others...> base_type;$/;"	t	struct:simpla::Distributed
base_type	core/particle/ParticleGenerator.h	/^    typedef ParticleGenerator<typename TP::sample_type, TSeed, XDist, VDist> base_type;$/;"	t	class:simpla::particle::ParticleGeneratorPerCell
base_type	core/particle/obsolete/probe_particle.h	/^    typedef enable_split_from_this <this_type> base_type;$/;"	t	struct:simpla::ProbeParticle
base_type	core/task_flow/use_case.h	/^    typedef std::map<std::string, std::shared_ptr<UseCase>> base_type;$/;"	t	class:simpla::use_case::UseCaseList
bc_absorb	core/particle/obsolete/bc_absorb.h	/^void bc_absorb(Surface<TM> const & surface, TParticle *particle)$/;"	f	namespace:simpla
bc_cycle	core/particle/obsolete/bc_cycle.h	/^void bc_cycle(Surface <TM> const &surface,$/;"	f	namespace:simpla
bc_reflect	core/particle/obsolete/bc_reflect.h	/^void bc_reflect(TSurface const &surface, TParticle *particle)$/;"	f	namespace:simpla
bcast_string	core/parallel/MPIAuxFunctions.cpp	/^void bcast_string(std::string *filename_)$/;"	f	namespace:simpla::parallel
begin	core/gtl/array_view.h	/^    iterator begin() const$/;"	f	class:simpla::gtl::ArrayView
begin	core/gtl/containers/sp_indirect_container.h	/^	const_iterator begin() const$/;"	f	struct:simpla::indirect_container
begin	core/gtl/containers/sp_indirect_container.h	/^	iterator begin()$/;"	f	struct:simpla::indirect_container
begin	core/gtl/containers/unordered_set.h	/^    const_iterator begin() const$/;"	f	class:simpla::UnorderedSet
begin	core/gtl/containers/unordered_set.h	/^    constexpr const_local_iterator begin(key_type const &id) const$/;"	f	class:simpla::UnorderedSet
begin	core/gtl/containers/unordered_set.h	/^    local_iterator begin(key_type const &id)$/;"	f	class:simpla::UnorderedSet
begin	core/gtl/iterator/range.h	/^    const_iterator const &begin() const { return m_begin_; }$/;"	f	class:simpla::Range
begin	core/gtl/iterator/sp_indirect_iterator.h	/^    const_iterator begin() const$/;"	f	struct:simpla::sp_indirect_range
begin	core/gtl/iterator/sp_indirect_iterator.h	/^    iterator begin()$/;"	f	struct:simpla::sp_indirect_range
begin	core/gtl/iterator/sp_ntuple_range.h	/^    constexpr const_iterator begin() const$/;"	f	struct:simpla::sp_nTuple_range
begin	core/gtl/iterator/sp_range_filter.h	/^	iterator begin() const$/;"	f	struct:simpla::FilterRange
begin	core/gtl/iterator/sp_range_filter.h	/^	iterator begin()$/;"	f	struct:simpla::FilterRange
begin	core/gtl/range/block_range.h	/^    const_iterator begin() const { return m_begin_; }$/;"	f	class:simpla::BlockRange
begin	core/gtl/utilities/lua_object.h	/^    iterator begin() const { return iterator(L_, GLOBAL_REF_IDX_, self_, path_); }$/;"	f	class:simpla::lua::LuaObject
begin	core/gtl/utilities/lua_object.h	/^    iterator begin()$/;"	f	class:simpla::lua::LuaObject
begin	core/manifold/mesh/MeshIds.h	/^        const_iterator begin() const { return const_iterator(m_min_, m_min_, m_max_, m_iform_); }$/;"	f	struct:simpla::mesh::MeshEntityIdCoder::range_type
begin	core/parallel/obsoleted/blocked_range.h	/^	const_iterator begin() const$/;"	f	struct:simpla::BlockedRange
begin	core/parallel/obsoleted/blocked_range.h	/^	iterator begin() const$/;"	f	struct:simpla::range
begin_	core/parallel/obsoleted/blocked_range.h	/^	const_iterator begin_;$/;"	m	struct:simpla::BlockedRange
begin_	core/parallel/obsoleted/blocked_range.h	/^	index_tuple begin_, end_;$/;"	m	struct:simpla::range
begin_	core/parallel/obsoleted/blocked_range.h	/^	nTuple<index_type, ndims> self_, begin_, end_;$/;"	m	struct:simpla::iterator
begin_	core/particle/obsolete/probe_particle.h	/^    size_t begin_ = 0, end_ = 0;$/;"	m	struct:simpla::ProbeParticle
begin{eqnarray}
binary_right	core/gtl/expression_template.h	/^struct binary_right$/;"	s	namespace:simpla::_impl
block_iterator	core/gtl/iterator/block_iterator.h	/^    block_iterator() : m_min_(), m_max_(m_min_), m_self_(m_min_) { }$/;"	f	struct:simpla::block_iterator
block_iterator	core/gtl/iterator/block_iterator.h	/^    block_iterator(nTuple<TV, NDIMS> const &min, nTuple<TV, NDIMS> const &max) :$/;"	f	struct:simpla::block_iterator
block_iterator	core/gtl/iterator/block_iterator.h	/^    block_iterator(nTuple<TV, NDIMS> const &self, nTuple<TV, NDIMS> const &min, nTuple<TV, NDIMS> const &max) :$/;"	f	struct:simpla::block_iterator
block_iterator	core/gtl/iterator/block_iterator.h	/^    block_iterator(this_type &&other) :$/;"	f	struct:simpla::block_iterator
block_iterator	core/gtl/iterator/block_iterator.h	/^    block_iterator(this_type const &other) :$/;"	f	struct:simpla::block_iterator
block_iterator	core/gtl/iterator/block_iterator.h	/^struct block_iterator : public std::iterator<$/;"	s	namespace:simpla
block_type	core/manifold/mesh/CartesianCoRect.h	/^    typedef MeshBlock block_type;$/;"	t	struct:simpla::mesh::CartesianCoRect
block_type	core/manifold/mesh/CoRectMesh.h	/^    typedef MeshBlock block_type;$/;"	t	struct:simpla::mesh::Mesh
block_type	core/manifold/mesh/CylindricalCoRect.h	/^    typedef MeshBlock block_type;$/;"	t	class:simpla::mesh::CylindricalCoRect
block_type	core/manifold/mesh/RectMesh.h	/^    typedef MeshBlock block_type;$/;"	t	struct:simpla::mesh::Mesh
bondary_range	core/manifold/obsoleted/embedded_policy.h	/^    bondary_range()const{}$/;"	f	struct:simpla::manifold::policy::EmbeddedPolicy
boost	core/geometry/boost_gemetry_adapted.h	/^namespace boost$/;"	n
boundary	core/model/GEqdsk.cpp	/^geometry::GeoObject const &GEqdsk::boundary() const$/;"	f	class:simpla::geometry::GEqdsk
boundary_box	core/manifold/mesh/MeshBlock.h	/^    std::vector<index_box_type> const &boundary_box() const { return m_boundary_box_; }$/;"	f	class:simpla::mesh::MeshBlock::std
boundary_type	core/geometry/chains.h	/^            Policies...> boundary_type;$/;"	t	struct:simpla::geometry::model::Chains
box	core/field/test/field_diff_calculus_test.h	/^    box_type box;$/;"	m	class:FETLTest
box	core/geometry/obsolete/surface.h	/^	auto box(Args &&...args) const$/;"	f	class:simpla::Surface
box	core/geometry/polygon.h	/^    virtual box_type box() const$/;"	f	struct:simpla::geometry::Polygon
box	core/gtl/iterator/sp_ntuple_range.h	/^    std::tuple<value_type, value_type> box() const$/;"	f	struct:simpla::sp_nTuple_range
box	core/manifold/mesh/CoRectMesh.h	/^    box_type box() const { return (std::make_tuple(m_coords_min_, m_coords_max_)); }$/;"	f	struct:simpla::mesh::Mesh
box	core/manifold/mesh/CoRectMesh.h	/^    box_type box(id_type const &s) const$/;"	f	struct:simpla::mesh::Mesh
box	core/manifold/mesh/CoRectMesh.h	/^    void box(X0 const &x0, X1 const &x1)$/;"	f	struct:simpla::mesh::Mesh
box	core/manifold/mesh/CoRectMesh.h	/^    void box(box_type const &b) { std::tie(m_coords_min_, m_coords_max_) = b; }$/;"	f	struct:simpla::mesh::Mesh
box	core/manifold/mesh/MeshBlock.h	/^    box_type box() const { return (std::make_tuple(m_min_, m_max_)); }$/;"	f	struct:simpla::mesh::MeshBlock
box	core/manifold/mesh/MeshBlock.h	/^    void box(box_type const &b) { std::tie(m_min_, m_max_) = b; }$/;"	f	struct:simpla::mesh::MeshBlock
box	core/manifold/mesh/RectMesh.h	/^    box_type box() const { return (std::make_tuple(m_coords_min_, m_coords_max_)); }$/;"	f	struct:simpla::mesh::Mesh
box	core/manifold/mesh/RectMesh.h	/^    box_type box(id_type const &s) const$/;"	f	struct:simpla::mesh::Mesh
box	core/manifold/mesh/RectMesh.h	/^    void box(X0 const &x0, X1 const &x1)$/;"	f	struct:simpla::mesh::Mesh
box	core/manifold/mesh/RectMesh.h	/^    void box(box_type const &b) { std::tie(m_coords_min_, m_coords_max_) = b; }$/;"	f	struct:simpla::mesh::Mesh
box	core/model/GEqdsk.cpp	/^std::tuple<typename GEqdsk::point_type, typename GEqdsk::point_type> GEqdsk::box() const$/;"	f	class:simpla::GEqdsk
box	core/model/obsoleted/revolve_polygon.h	/^    box_type box() const$/;"	f	struct:simpla::RevolvePolygon
box_area	core/geometry/csCylindrical.h	/^    static Real box_area(point_type const &p0, point_type const &p1)$/;"	f	struct:simpla::geometry::Metric
box_intersection	core/geometry/GeoAlgorithm.h	/^bool box_intersection(TL const &l, TR *r)$/;"	f	namespace:simpla::geometry
box_intersection	core/geometry/GeoAlgorithm.h	/^bool box_intersection(nTuple<TS, NDIMS> const &l_b, nTuple<TS, NDIMS> const &l_e,$/;"	f	namespace:simpla::geometry
box_intersection	core/geometry/polygon.cpp	/^int Polygon<2>::box_intersection(point_type *x0, point_type *x1) const$/;"	f	class:simpla::geometry::Polygon
box_intersection	core/model/obsoleted/revolve_polygon.h	/^    virtual int box_intersection(point_type *x0, point_type *x1) const$/;"	f	struct:simpla::RevolvePolygon
box_type	core/field/test/field_diff_calculus_test.h	/^    typedef typename mesh_type::box_type box_type;$/;"	t	class:FETLTest
box_type	core/geometry/GeoObject.h	/^    typedef std::tuple<point_type, point_type> box_type;$/;"	t	class:simpla::geometry::GeoObject
box_type	core/manifold/mesh/CartesianCoRect.h	/^    typedef std::tuple<point_type, point_type> box_type;$/;"	t	struct:simpla::mesh::CartesianCoRect
box_type	core/manifold/mesh/CoRectMesh.h	/^    typedef std::tuple<point_type, point_type> box_type;$/;"	t	struct:simpla::mesh::Mesh
box_type	core/manifold/mesh/CylindricalCoRect.h	/^    typedef std::tuple<point_type, point_type> box_type;$/;"	t	class:simpla::mesh::CylindricalCoRect
box_type	core/manifold/mesh/MeshIds.h	/^    typedef std::tuple<point_type, point_type> box_type;$/;"	t	struct:simpla::mesh::MeshEntityIdCoder
box_type	core/manifold/mesh/RectMesh.h	/^    typedef std::tuple<point_type, point_type> box_type;$/;"	t	struct:simpla::mesh::Mesh
box_type	core/manifold/obsoleted/patch/mesh_patch.h	/^    typedef typename mesh_type::box_type box_type;$/;"	t	class:simpla::mesh::MeshPatch
box_type	core/phy_solver/em_fluid.h	/^    typedef typename mesh_type::box_type box_type;$/;"	t	class:simpla::phy_solver::EMFluid
box_type	example/em_tokamak/tokamak.cpp	/^    typedef typename mesh_type::box_type box_type;$/;"	t	struct:simpla::EMTokamak	file:
box_volume	core/geometry/csCylindrical.h	/^    static Real box_volume(point_type const &p0, point_type const &p1)$/;"	f	struct:simpla::geometry::Metric
bucket_type	core/gtl/containers/UnorderedSet.h	/^    typedef std::list<ValueType> bucket_type;$/;"	t	class:simpla::gtl::UnorderedSet
bucket_type	core/gtl/containers/unordered_set.h	/^    typedef std::forward_list<T, allocator_type> bucket_type;$/;"	t	class:simpla::UnorderedSet
bucket_type	core/particle/ParticleContainer.h	/^    typedef std::list<value_type> bucket_type;$/;"	t	struct:simpla::particle::ParticleContainer
buffer	core/io/WriteBuffer.cpp	/^void *WriteBuffer::buffer()$/;"	f	class:simpla::io::WriteBuffer
buffer_type	core/gtl/containers/UnorderedSet.h	/^    typedef base_type buffer_type;$/;"	t	class:simpla::gtl::UnorderedSet
buffer_type	core/particle/ParticleContainer.h	/^    typedef container_type buffer_type;$/;"	t	struct:simpla::particle::ParticleContainer
byte_type	core/gtl/utilities/memory_pool.h	/^    typedef char byte_type;$/;"	t	class:simpla::MemoryPool
c	core/gtl/test/ntuple_perf_test.cpp	/^	value_type a, b, c, d;$/;"	m	class:nTuplePerf1	file:
c	core/gtl/test/ntuple_perf_test.cpp	/^	value_type a, b, c, d;$/;"	m	class:nTuplePerf2	file:
c	core/gtl/test/ntuple_reduce_test.cpp	/^	value_type a, b, c, d;$/;"	m	class:TestNtupleReduce	file:
cache	core/gtl/cache.h	/^typename Cache<T>::cached_type cache(Args&& ...args)$/;"	f	namespace:simpla
cache	core/particle/obsolete/probe_particle.h	/^DataSet ProbeParticle<Engine>::cache() const$/;"	f	class:simpla::ProbeParticle
cache_	core/gtl/containers/container_save_cache.h	/^	std::vector<value_type> cache_;$/;"	m	class:simpla::ContainerSaveCache
cache_	core/particle/obsolete/probe_particle.h	/^    std::shared_ptr<Point_s> cache_;$/;"	m	struct:simpla::ProbeParticle
cache_depth	core/gtl/containers/container_save_cache.h	/^	size_t cache_depth() const$/;"	f	class:simpla::ContainerSaveCache
cache_depth	core/gtl/containers/container_save_cache.h	/^	void cache_depth(size_t d)$/;"	f	class:simpla::ContainerSaveCache
cache_depth	core/particle/obsolete/probe_particle.h	/^    size_t cache_depth() const$/;"	f	struct:simpla::ProbeParticle
cache_depth	core/particle/obsolete/probe_particle.h	/^    void cache_depth(size_t d)$/;"	f	struct:simpla::ProbeParticle
cache_depth_	core/gtl/containers/container_save_cache.h	/^	size_t cache_depth_ = 10;$/;"	m	class:simpla::ContainerSaveCache
cache_depth_	core/particle/obsolete/probe_particle.h	/^    size_t cache_depth_ = 0;$/;"	m	struct:simpla::ProbeParticle
cache_is_valid	core/particle/obsolete/probe_particle.h	/^    bool cache_is_valid() const$/;"	f	struct:simpla::ProbeParticle
cache_is_valid_	core/particle/obsolete/probe_particle.h	/^    bool cache_is_valid_ = false;$/;"	m	struct:simpla::ProbeParticle
cache_width_	core/particle/obsolete/probe_particle.h	/^    size_t cache_width_ = 0;$/;"	m	struct:simpla::ProbeParticle
cached_type	core/gtl/cache.h	/^	typedef T * cached_type;$/;"	t	struct:simpla::Cache
cached_type	core/gtl/cache.h	/^	typedef T cached_type;$/;"	t	struct:simpla::Cache
cached_type	core/gtl/cache.h	/^	typedef T const & cached_type;$/;"	t	struct:simpla::Cache
calculate	core/numeric/interpolation.h	/^                          TX const &x) const -> decltype(calculate(v, x[0], x[1]))$/;"	f	class:simpla::BiLinearInterpolation
calculate	core/numeric/interpolation.h	/^    inline typename container::mapped_type calculate(container const &,$/;"	f	struct:simpla::LinearInterpolation
calculate	core/numeric/interpolation.h	/^    value_type calculate(TArgs const &... x) const$/;"	f	class:simpla::MultiDimesionInterpolation
calculate	core/numeric/interpolation.h	/^    value_type calculate(key_x_type const &x) const$/;"	f	class:simpla::Interpolation
calculus	core/manifold/Calculus.h	/^namespace calculus$/;"	n	namespace:simpla
calculus_policy	core/field/FieldDense.h	/^    typedef typename this_type::calculus_policy calculus_policy;$/;"	t	class:simpla::Field
calculus_policy	core/field/FieldFunction.h	/^    typedef typename this_type::calculus_policy calculus_policy;$/;"	t	class:simpla::Field
calculus_policy	core/manifold/policy/FvmStructuredPolicy.h	/^    typedef this_type calculus_policy;$/;"	t	struct:simpla::manifold::policy::FiniteVolume
call	core/gtl/design_pattern/signal.h	/^    std::vector<result_type> call(std::false_type, Args &&... args) const$/;"	f	struct:simpla::Signal
call	core/gtl/design_pattern/signal.h	/^    void call(std::true_type, Args &&... args) const$/;"	f	struct:simpla::Signal
callFunc	core/gtl/design_pattern/visitor.h	/^    inline void callFunc(TFUN const &fun, integer_sequence<int, S...>)$/;"	f	struct:simpla::Visitor
callback_type	core/gtl/design_pattern/signal.h	/^    typedef std::function<result_type(Args...)> callback_type;$/;"	t	struct:simpla::Signal
callback_type	core/gtl/utilities/parser_configure.h	/^	typedef std::function<void(dict_type const &)> callback_type;$/;"	t	class:simpla::ParserConfigure
callbacks_	core/gtl/design_pattern/factory.h	/^	CallbackMap callbacks_;$/;"	m	struct:simpla::Factory
callbacks_	core/gtl/utilities/parser_configure.h	/^	std::map<std::string, callback_type> callbacks_;$/;"	m	class:simpla::ParserConfigure
cat_tuple	core/gtl/mpl.h	/^struct cat_tuple<>$/;"	s	namespace:simpla::mpl
cat_tuple	core/gtl/mpl.h	/^struct cat_tuple<T0, T...>$/;"	s	namespace:simpla::mpl
cat_tuple	core/gtl/mpl.h	/^struct cat_tuple<T0>$/;"	s	namespace:simpla::mpl
cat_tuple	core/gtl/mpl.h	/^struct cat_tuple<std::tuple<T...>>$/;"	s	namespace:simpla::mpl
cat_tuple	core/gtl/mpl.h	/^struct cat_tuple<std::tuple<T0...>, std::tuple<T1...>>$/;"	s	namespace:simpla::mpl
cbegin	core/gtl/containers/sp_indirect_container.h	/^	const_iterator cbegin() const$/;"	f	struct:simpla::indirect_container
cbegin	core/gtl/containers/unordered_set.h	/^    const_iterator cbegin() const$/;"	f	class:simpla::UnorderedSet
cbegin	core/gtl/containers/unordered_set.h	/^    constexpr const_local_iterator cbegin(key_type const &id) const$/;"	f	class:simpla::UnorderedSet
cbegin	core/gtl/iterator/sp_indirect_iterator.h	/^    const_iterator cbegin() const$/;"	f	struct:simpla::sp_indirect_range
cd	core/io/IO.cpp	/^std::string cd(std::string const &url)$/;"	f	namespace:simpla::io
cell_box	core/manifold/mesh/MeshBlock.h	/^    box_type cell_box(id_type const &s) const$/;"	f	struct:simpla::mesh::MeshBlock
cell_id	core/particle/obsolete/kinetic_particle.h	/^    static constexpr size_t cell_id = (iform == VOLUME) ? 7 : 0;$/;"	m	struct:simpla::_impl::particle_hasher
cell_id	core/particle/obsolete/kinetic_particle.h	/^template<typename TDomain, typename TPoint_s> constexpr size_t particle_hasher<TDomain, TPoint_s>::cell_id;$/;"	m	class:simpla::_impl::particle_hasher
cend	core/gtl/containers/sp_indirect_container.h	/^	const_iterator cend() const$/;"	f	struct:simpla::indirect_container
cend	core/gtl/containers/unordered_set.h	/^    const_iterator cend() const$/;"	f	class:simpla::UnorderedSet
cend	core/gtl/containers/unordered_set.h	/^    constexpr const_local_iterator cend(key_type const &id) const$/;"	f	class:simpla::UnorderedSet
cend	core/gtl/iterator/sp_indirect_iterator.h	/^    const_iterator cend() const$/;"	f	struct:simpla::sp_indirect_range
center_box	core/manifold/mesh/MeshBlock.h	/^    index_box_type const &center_box() const { return m_center_box_; }$/;"	f	struct:simpla::mesh::MeshBlock
center_type	core/base/Attribute.h	/^    virtual int center_type() const { return 0; }$/;"	f	class:simpla::base::AttributeObject
center_type	core/base/Attribute.h	/^    virtual int center_type() const { return IFORM; };$/;"	f	class:simpla::base::Attribute
cfg_str	core/gtl/test/sp_iterator_test.cpp	/^	std::string cfg_str;$/;"	m	class:TestIterator	file:
charge	core/phy_solver/em_fluid.h	/^        Real charge;$/;"	m	struct:simpla::phy_solver::EMFluid::fluid_s
charge	example/em_tokamak/tokamak.cpp	/^        Real charge;$/;"	m	struct:simpla::EMTokamak::fluid_s	file:
check	core/gtl/utilities/lua_object.h	/^namespace check$/;"	n	namespace:simpla
check_B_type	applications/particle_solver/fluid_cold_engine.h	/^	bool check_B_type(std::type_info const & t_info) const$/;"	f	class:simpla::Particle
check_E_type	applications/particle_solver/fluid_cold_engine.h	/^	bool check_E_type(std::type_info const & t_info) const$/;"	f	class:simpla::Particle
check_context_type	core/task_flow/task.h	/^    virtual bool check_context_type(std::type_info const &info)$/;"	f	class:simpla::task_flow::Task
check_inside	core/geometry/obsolete/polygon.h	/^bool PolyGon<TM>::check_inside(T const & coord) const$/;"	f	class:simpla::PolyGon
check_mesh_type	applications/particle_solver/fluid_cold_engine.h	/^	bool check_mesh_type(std::type_info const & t_info) const$/;"	f	class:simpla::Particle
check_point	core/phy_solver/em_fluid.h	/^void EMFluid<TM>::check_point()$/;"	f	class:simpla::phy_solver::EMFluid
check_point	core/task_flow/use_case.h	/^    virtual void check_point() { }$/;"	f	class:simpla::use_case::UseCase
check_point	example/em_tokamak/tokamak.cpp	/^void EMTokamak::check_point()$/;"	f	class:simpla::EMTokamak
check_type	core/gtl/design_pattern/visitor.h	/^    virtual bool check_type(std::type_info const &)$/;"	f	struct:simpla::AcceptorBase
cholesky_decomposition	core/numeric/cholesky.h	/^nTuple<T, N, N> && cholesky_decomposition(nTuple<T, N, N> &a)$/;"	f	namespace:simpla
clear	core/base/Attribute.h	/^    virtual void clear()$/;"	f	class:simpla::base::Attribute
clear	core/field/FieldDense.h	/^    void clear() { data()->clear(); }$/;"	f	class:simpla::Field
clear	core/field/obsoleted/field_sparse.h	/^	void clear()$/;"	f	struct:simpla::Field
clear	core/field/test/trash/field_continue.h	/^	void clear()$/;"	f	struct:simpla::Field
clear	core/geometry/model.h	/^	inline void clear()$/;"	f	struct:simpla::geometry::model::Polygon
clear	core/gtl/containers/container_dense.h	/^	void clear()$/;"	f	class:simpla::DenseContainer
clear	core/gtl/containers/container_sparse.h	/^    void clear()$/;"	f	class:simpla::SparseContainer
clear	core/gtl/containers/container_traits.h	/^	static void clear(T &&...)$/;"	f	struct:simpla::container_traits
clear	core/gtl/containers/container_traits.h	/^	static void clear(std::shared_ptr<TV> d, size_t s)$/;"	f	struct:simpla::container_traits
clear	core/gtl/containers/unordered_set.h	/^    void clear()$/;"	f	class:simpla::UnorderedSet
clear	core/gtl/iterator/sp_ntuple_range.h	/^    void clear()$/;"	f	struct:simpla::sp_nTuple_range
clear	core/gtl/utilities/memory_pool.cpp	/^void MemoryPool::clear()$/;"	f	class:simpla::MemoryPool
clear	core/gtl/utilities/memory_pool.cpp	/^void MemoryPool::pimpl_s::clear()$/;"	f	class:simpla::MemoryPool::pimpl_s
clear	core/model/obsoleted/model.h	/^    void clear()$/;"	f	class:simpla::Model
clear	core/particle/Particle.h	/^    virtual void clear() { m_data_->clear(); }$/;"	f	struct:simpla::particle::Particle
clear	core/particle/ParticleContainer.h	/^ParticleContainer<P, M>::clear()$/;"	f	class:simpla::particle::ParticleContainer
clear_selected	core/data_model/DataSpace.cpp	/^void DataSpace::clear_selected()$/;"	f	class:simpla::data_model::DataSpace
clen	core/geometry/obsolete/polygons.h	171;"	d
click	core/base/Object.h	/^    inline size_t click() const { return m_click_; }$/;"	f	class:simpla::base::Object
clipRegion	core/geometry/obsolete/line_cliping.h	/^	pnt2d clipRegion[3];$/;"	m	class:simpla::polygon_clip
clone	core/field/obsoleted/field_sparse.h	/^	cloneField_type<TU> clone() const$/;"	f	struct:simpla::Field
clone	core/field/test/trash/field_continue.h	/^	cloneField_type<TU> clone() const$/;"	f	struct:simpla::Field
clone	core/gtl/any.h	/^    BasePtr clone() const$/;"	f	struct:simpla::any
clone	core/gtl/any.h	/^    std::unique_ptr<Base> clone() const { return std::unique_ptr<Base>(new Derived<T>(m_value)); }$/;"	f	struct:simpla::Derived
clone	core/gtl/containers/container_container.h	/^	this_type clone() const$/;"	f	class:simpla::ContainerContainer
close	core/gtl/utilities/log.cpp	/^void LoggerStreams::close()$/;"	f	class:simpla::logger::LoggerStreams
close	core/gtl/utilities/log.cpp	/^void close()$/;"	f	namespace:simpla::logger
close	core/io/HDF5Stream.cpp	/^void HDF5Stream::close()$/;"	f	class:simpla::io::HDF5Stream
close	core/io/IO.cpp	/^void close()$/;"	f	namespace:simpla::io
close	core/io/XDMFStream.cpp	/^void XDMFStream::close()$/;"	f	class:simpla::io::XDMFStream
close	core/parallel/MPIComm.cpp	/^void MPIComm::close()$/;"	f	class:simpla::parallel::MPIComm
close	core/parallel/Parallel.cpp	/^void close()$/;"	f	namespace:simpla::parallel
close_file	core/io/HDF5Stream.cpp	/^void HDF5Stream::close_file()$/;"	f	class:simpla::io::HDF5Stream
close_grid	core/io/XDMFStream.cpp	/^void XDMFStream::close_grid()$/;"	f	class:simpla::io::XDMFStream
close_group	core/io/HDF5Stream.cpp	/^void HDF5Stream::close_group()$/;"	f	class:simpla::io::HDF5Stream
closure	core/geometry/boost_gemetry_adapted.h	/^struct closure<sgm::Polyline<CS, Others ...> >$/;"	s	namespace:boost::geometry::traits
closure	core/geometry/chains.h	/^struct closure<model::Chains<PrimitiveType, Others...>>$/;"	s	namespace:simpla::geometry::traits
cmr_	applications/fokker_planck/lhw.cpp	/^	Real cmr_, q_kT_;$/;"	m	struct:PICDeltaF	file:
cmr_	applications/particle_solver/pic_engine_deltaf.h	/^	Real cmr_, q_kT_;$/;"	m	struct:simpla::ParticleEngine
cmr_	applications/particle_solver/pic_engine_deltaf2.h	/^	Real m, cmr_, q, q_k_;$/;"	m	struct:simpla::PICEngineDeltaF
cmr_	applications/particle_solver/pic_engine_fullf.h	/^	Real cmr_;$/;"	m	class:simpla::PICEngineFullF
cmr_	applications/particle_solver/pic_engine_ggauge.h	/^	Real cmr_, T_, vT_;$/;"	m	class:simpla::PICEngineGGauge
cmr_	applications/particle_solver/pic_engine_implicit.h	/^	Real cmr_;$/;"	m	struct:simpla::PICEngineImplicit
cmr_	core/particle/obsolete/simple_particle.h	/^	Real cmr_, q_kT_;$/;"	m	struct:simpla::SimpleParticleEngine
cmr_	example/probe_particle/demo_probe_particle.h	/^	Real cmr_, q_kT_;$/;"	m	struct:simpla::ProbeDemo
coarsen	core/base/Patch.h	/^    virtual void coarsen() { }$/;"	f	class:simpla::base::Patch
coarsen	core/field/obsoleted/field_patch.h	/^    virtual void coarsen(size_t id)$/;"	f	class:simpla::FieldAMRPolicy
coarsen	core/manifold/obsoleted/amr_policy.h	/^AMR<TM>::coarsen(size_t id)$/;"	f	class:simpla::manifold::policy::AMR
collide	example/pic/collision_pic.cpp	/^void collide(Real dt, Real coeff, Real m0, pic_mark &p0, Real m1, pic_mark &p1)$/;"	f
comm	core/parallel/MPIComm.cpp	/^MPI_Comm MPIComm::comm()$/;"	f	class:simpla::parallel::MPIComm
commandToB_	applications/contexts/explicit_em.h	/^    std::list<std::function<void()> > commandToB_;$/;"	m	struct:simpla::ExplicitEMContext
commandToE_	applications/contexts/explicit_em.h	/^    std::list<std::function<void()> > commandToE_;$/;"	m	struct:simpla::ExplicitEMContext
commandToJ_	applications/contexts/explicit_em.h	/^    std::list<std::function<void()> > commandToJ_;$/;"	m	struct:simpla::ExplicitEMContext
compact	applications/particle_solver/pic_engine_ggauge.h	/^		static compact_type compact(Point_s const& p)$/;"	f	struct:simpla::PICEngineGGauge::Point_s
compact_type	applications/particle_solver/pic_engine_fullf.h	/^		typedef std::tuple<coordinate_tuple, vector_type, scalar_type> compact_type;$/;"	t	struct:simpla::PICEngineFullF::Point_s
compact_type	applications/particle_solver/pic_engine_ggauge.h	/^		typedef std::tuple<coordinate_tuple, Vec3, Real, nTuple<NMATE, scalar_type>> compact_type;$/;"	t	struct:simpla::PICEngineGGauge::Point_s
compact_type	applications/particle_solver/pic_engine_implicit.h	/^		typedef std::tuple<coordinate_tuple, Vec3, Real> compact_type;$/;"	t	struct:simpla::PICEngineImplicit::Point_s
compound_distribution	core/numeric/compound_distribution.h	/^struct compound_distribution$/;"	s	namespace:simpla
conatiner_type	core/gtl/iterator/sp_iterator_mapped.h	/^	typedef TContainer conatiner_type;$/;"	t	struct:simpla::Iterator
conatiner_type	core/gtl/iterator/sp_iterator_mapped.h	/^	typedef std::map<TKey, TMapped> conatiner_type;$/;"	t	struct:simpla::Iterator
conatiner_type	core/gtl/iterator/sp_iterator_shared_container.h	/^	typedef TContainer conatiner_type;$/;"	t	class:simpla::TransformIterator
concurrent_unordered_set	core/parallel/concurrent_unordered_multiset.h	/^class concurrent_unordered_set$/;"	c	namespace:simpla::parallel
connect	core/gtl/design_pattern/observer.h	/^	void connect(Observable &subject)$/;"	f	struct:simpla::Observer
connect	core/gtl/design_pattern/observer.h	/^	void connect(std::shared_ptr<observer_type> observer)$/;"	f	struct:simpla::Observable
connect	core/gtl/design_pattern/signal.h	/^    iterator connect(T &&... args)$/;"	f	struct:simpla::Signal
connection_node	core/parallel/obsoleted/distributed_unordered_set.h	/^	struct connection_node$/;"	s	struct:simpla::Distributed
const_accessor	core/gtl/utilities/lua_object.h	/^            const_accessor(std::shared_ptr<lua_s> const &l) : m_l_(l) { m_l_->m_mutex_.lock(); }$/;"	f	struct:simpla::lua::LuaObject::LuaState::const_accessor
const_accessor	core/gtl/utilities/lua_object.h	/^        struct const_accessor$/;"	s	struct:simpla::lua::LuaObject::LuaState
const_holder	core/gtl/enable_create_from_this.h	/^	typedef std::shared_ptr<const object_type> const_holder;$/;"	t	struct:simpla::enable_create_from_this
const_iterator	core/gtl/containers/sp_indirect_container.h	/^	typedef indirect_iterator<const_key_iterator, value_conatinaer_type const> const_iterator;$/;"	t	struct:simpla::indirect_container
const_iterator	core/gtl/containers/unordered_set.h	/^    typedef typename base_container_type::const_iterator const_iterator;$/;"	t	class:simpla::UnorderedSet
const_iterator	core/gtl/iterator/range.h	/^    typedef Iterator const_iterator;$/;"	t	class:simpla::Range
const_iterator	core/gtl/iterator/sp_indirect_iterator.h	/^            Hasher> const_iterator;$/;"	t	struct:simpla::sp_indirect_range
const_iterator	core/gtl/iterator/sp_ntuple_range.h	/^    typedef iterator const_iterator;$/;"	t	struct:simpla::sp_nTuple_range
const_iterator	core/gtl/range/block_range.h	/^    typedef Iterator const_iterator;$/;"	t	class:simpla::BlockRange
const_iterator	core/manifold/mesh/MeshIds.h	/^        typedef iterator const_iterator;$/;"	t	struct:simpla::mesh::MeshEntityIdCoder::range_type
const_iterator	core/parallel/obsoleted/blocked_range.h	/^	typedef T const_iterator;$/;"	t	struct:simpla::BlockedRange
const_key_iterator	core/gtl/containers/sp_indirect_container.h	/^	typedef typename key_conatinaer_type::const_iterator const_key_iterator;$/;"	t	struct:simpla::indirect_container
const_local_iterator	core/gtl/containers/unordered_set.h	/^    typedef typename bucket_type::const_iterator const_local_iterator;$/;"	t	class:simpla::UnorderedSet
const_pointer	core/gtl/iterator/sp_iterator_mapped.h	/^	typedef value_type const* const_pointer;$/;"	t	struct:simpla::Iterator
const_reference	core/gtl/iterator/sp_iterator_mapped.h	/^	typedef value_type const& const_reference;$/;"	t	struct:simpla::Iterator
constant_	core/geometry/polygon.h	/^    std::vector<Real> constant_;$/;"	m	struct:simpla::geometry::Polygon
constraint_type_choice	core/model/Constraint.h	/^struct constraint_type_choice<TM, Arg0, Args ...>$/;"	s	namespace:simpla::model::_impl
constraint_type_choice	core/model/Constraint.h	/^struct constraint_type_choice<TM, Arg>$/;"	s	namespace:simpla::model::_impl
constraint_type_choice	core/model/Constraint.h	/^struct constraint_type_choice<TM>$/;"	s	namespace:simpla::model::_impl
container_traits	core/gtl/containers/container_traits.h	/^struct container_traits$/;"	s	namespace:simpla
container_traits	core/gtl/containers/container_traits.h	/^template<typename TV> struct container_traits<std::shared_ptr<TV>>$/;"	s	namespace:simpla
container_type	core/field/obsoleted/field_sparse.h	/^	typedef std::map<id_type, value_type> container_type;$/;"	t	struct:simpla::Field
container_type	core/field/test/trash/field_cartesian_map_test.cpp	/^typedef std::unordered_map<typename mesh_type::id_type, double> container_type;$/;"	t	file:
container_type	core/field/test/trash/field_continue.h	/^	typedef TContainer container_type;$/;"	t	struct:simpla::Field
container_type	core/field/test/trash/field_simple_mesh_map_test.cpp	/^typedef std::unordered_map<typename SimpleMesh::id_type, double, hash_id> container_type;$/;"	t	file:
container_type	core/geometry/obsolete/polygon.h	/^	typedef std::list<coordinate_tuple> container_type;$/;"	t	struct:simpla::PolyGon
container_type	core/gtl/containers/container_save_cache.h	/^	typedef std::vector<TV> container_type;$/;"	t	class:simpla::ContainerSaveCache
container_type	core/gtl/containers/container_traits.h	/^	typedef TContainer container_type;$/;"	t	struct:simpla::container_traits
container_type	core/gtl/containers/container_traits.h	/^	typedef std::shared_ptr<TV> container_type;$/;"	t	struct:simpla::container_traits
container_type	core/gtl/iterator/sp_indirect_iterator.h	/^    typedef Container container_type;$/;"	t	struct:simpla::sp_indirect_iterator
container_type	core/gtl/iterator/sp_iterator.h	/^	typedef T * container_type;$/;"	t	class:simpla::sp_back_insert_iterator
container_type	core/gtl/iterator/sp_iterator_shared_container.h	/^	typedef T container_type;$/;"	t	struct:simpla::_impl::StorageSharedContainer
container_type	core/gtl/iterator/sp_iterator_shared_container.h	/^	typedef T* container_type;$/;"	t	struct:simpla::_impl::StorageSharedContainer
container_type	core/numeric/interpolation.h	/^    typedef std::map<TX, TV> container_type;$/;"	t	class:simpla::Interpolation
container_type	core/particle/Particle.h	/^    typedef ParticleContainer<P, M> container_type;$/;"	t	struct:simpla::particle::Particle
container_type	core/particle/ParticleContainer.h	/^    typedef typename parallel::concurrent_hash_map<id_type, bucket_type> container_type;$/;"	t	struct:simpla::particle::ParticleContainer
context_factory	applications/contexts/context_factory.h	/^typedef Factory<std::string, ContextBase, LuaObject> context_factory;$/;"	t	namespace:simpla
context_type	core/task_flow/task.h	/^    typedef TContext context_type;$/;"	t	class:simpla::task_flow::Task
context_type	core/task_flow/task.h	/^    typedef TContext context_type;$/;"	t	struct:simpla::task_flow::_impl::TaskRegistry
conversionFactors	plugins/vtk_reader/vtkAMRSimPlaReader.h	/^    std::map<int, double> conversionFactors;$/;"	m	class:vtkAMRSimPlaReader
convert	core/gtl/iterator/sp_iterator_shared_container.h	/^	static T const &convert(T const &it)$/;"	f	struct:simpla::_impl::IteratorConvert
convert	core/gtl/iterator/sp_iterator_shared_container.h	/^	static T* convert(T** it)$/;"	f	struct:simpla::_impl::IteratorConvert
convert_data_space_h5_to_sp	core/io/HDF5Stream.cpp	/^data_model::DataSpace convert_data_space_h5_to_sp(hid_t)$/;"	f	namespace:simpla::io
convert_data_space_sp_to_h5	core/io/HDF5Stream.cpp	/^hid_t convert_data_space_sp_to_h5(data_model::DataSpace const &ds, size_t flag)$/;"	f	namespace:simpla::io
convert_data_type_h5_to_sp	core/io/HDF5Stream.cpp	/^data_model::DataType convert_data_type_h5_to_sp(hid_t t_id)$/;"	f	namespace:simpla::io
convert_data_type_sp_to_h5	core/io/HDF5Stream.cpp	/^hid_t convert_data_type_sp_to_h5(data_model::DataType const &d_type, size_t is_compact_array)$/;"	f	namespace:simpla::io
convert_datatype_sp_to_xdmf	core/io/XDMFIO.cpp	/^XdmfInt32 convert_datatype_sp_to_xdmf(DataType const &d_type)$/;"	f	namespace:simpla::io
convert_ntuple	core/gtl/utilities/lua_object.cpp	/^bool convert_ntuple(LuaObject const &obj, Properties *res) { return false; };$/;"	f	namespace:simpla::lua::_impl
convert_ntuple	core/gtl/utilities/lua_object.cpp	/^bool convert_ntuple(LuaObject const &obj, Properties *res)$/;"	f	namespace:simpla::lua::_impl
convert_type	core/gtl/iterator/sp_iterator_shared_container.h	/^	typedef IteratorConvertPolicy<key_iterator_type, typename ContainerTraits<container_type>::index_type> convert_type;$/;"	t	class:simpla::TransformIterator
coord_offset	core/parallel/obsoleted/distributed_unordered_set.h	/^		nTuple<int, 3> coord_offset;$/;"	m	struct:simpla::Distributed::connection_node
coordinate	core/parallel/MPIComm.cpp	/^nTuple<int, 3> MPIComm::coordinate(int rank) const$/;"	f	class:simpla::parallel::MPIComm
coordinate_system	core/geometry/CoordinateSystem.h	/^namespace coordinate_system$/;"	n	namespace:simpla::geometry
coordinate_system	core/geometry/boost_gemetry_adapted.h	/^struct coordinate_system<sgm::Primitive<N, sgcs::Cartesian<M>, TAG> >$/;"	s	namespace:boost::geometry::traits
coordinate_system	core/geometry/boost_gemetry_adapted.h	/^struct coordinate_system<sgm::Primitive<N, sgcs::Polar, TAG> >$/;"	s	namespace:boost::geometry::traits
coordinate_system	core/geometry/boost_gemetry_adapted.h	/^struct coordinate_system<sgm::Primitive<N, sgcs::Spherical, TAG> >$/;"	s	namespace:boost::geometry::traits
coordinate_system	core/geometry/box.h	/^struct coordinate_system<model::Box<CoordinateSystem>>$/;"	s	namespace:simpla::geometry::traits
coordinate_system	core/geometry/chains.h	/^    typedef typename traits::coordinate_system<primitive_type>::type coordinate_system;$/;"	t	struct:simpla::geometry::model::Chains
coordinate_system	core/geometry/chains.h	/^struct coordinate_system<model::Chains<PrimitiveType, Others...>>$/;"	s	namespace:simpla::geometry::traits
coordinate_system	core/geometry/model.h	/^struct coordinate_system<model::Polygon<CS> >$/;"	s	namespace:simpla::geometry::traits
coordinate_system	core/geometry/primitive.h	/^struct coordinate_system<model::Primitive<Dimension, CoordinateSystem, Tag>>$/;"	s	namespace:simpla::geometry::traits
coordinate_system_type	core/geometry/CoordinateSystem.h	/^struct coordinate_system_type<Metric<CS, Others...> >$/;"	s	namespace:simpla::geometry::traits
coordinate_system_type	core/geometry/CoordinateSystem.h	/^template<typename T> struct coordinate_system_type<T>$/;"	s	namespace:simpla::geometry::traits
coordinate_system_type	core/manifold/ManifoldTraits.h	/^struct coordinate_system_type<Manifold<TM, Policies...>>$/;"	s	namespace:simpla::geometry::traits
coordinate_system_type	core/manifold/mesh/CylindricalCoRect.h	/^    typedef typename metric_type::cs coordinate_system_type;$/;"	t	class:simpla::mesh::CylindricalCoRect
coordinate_system_type	core/manifold/mesh/Mesh.h	/^struct coordinate_system_type<::simpla::mesh::Mesh<T...>>$/;"	s	namespace:simpla::geometry::traits
coordinate_tuple	applications/field_solver/pml.h	/^	typedef typename mesh_type::coordinate_tuple coordinate_tuple;$/;"	t	class:simpla::PML
coordinate_tuple	applications/fokker_planck/lhw.cpp	/^	typedef nTuple<3, Real> coordinate_tuple;$/;"	t	struct:PICDeltaF	file:
coordinate_tuple	applications/particle_solver/fluid_cold_engine.h	/^	typedef typename mesh_type::coordinate_tuple coordinate_tuple;$/;"	t	class:simpla::Particle
coordinate_tuple	applications/particle_solver/pic_engine_deltaf.h	/^	typedef Vec3 coordinate_tuple;$/;"	t	struct:simpla::ParticleEngine
coordinate_tuple	applications/particle_solver/pic_engine_deltaf2.h	/^	typedef typename mesh_type::coordinate_tuple coordinate_tuple;$/;"	t	struct:simpla::PICEngineDeltaF
coordinate_tuple	applications/particle_solver/pic_engine_fullf.h	/^	typedef Vec3 coordinate_tuple;$/;"	t	class:simpla::PICEngineFullF
coordinate_tuple	applications/particle_solver/pic_engine_ggauge.h	/^	typedef typename mesh_type::coordinate_tuple coordinate_tuple;$/;"	t	class:simpla::PICEngineGGauge
coordinate_tuple	applications/particle_solver/pic_engine_implicit.h	/^	typedef typename mesh_type::coordinate_tuple coordinate_tuple;$/;"	t	struct:simpla::PICEngineImplicit
coordinate_tuple	core/field/obsoleted/field_sparse.h	/^	typedef typename mesh_type::coordinate_tuple coordinate_tuple;$/;"	t	struct:simpla::Field
coordinate_tuple	core/field/test/field_dummy.cpp	/^	typedef typename mesh_type::coordinate_tuple coordinate_tuple;$/;"	t	class:FieldTest	file:
coordinate_tuple	core/field/test/field_io_test.h	/^	typedef typename mesh_type::coordinate_tuple coordinate_tuple;$/;"	t	class:simpla::TestFieldIO
coordinate_tuple	core/field/test/trash/fetl_test3.h	/^	typedef typename manifold_type::coordinate_tuple coordinate_tuple;$/;"	t	class:TestFETL
coordinate_tuple	core/field/test/trash/fetl_test3.h	/^typedef nTuple<3, Real> coordinate_tuple;$/;"	t
coordinate_tuple	core/field/test/trash/field_continue.h	/^	typedef typename mesh_type::coordinate_tuple coordinate_tuple;$/;"	t	struct:simpla::Field
coordinate_tuple	core/geometry/obsolete/polygon.h	/^	typedef typename mesh_type::coordinate_tuple coordinate_tuple;$/;"	t	struct:simpla::PolyGon
coordinate_tuple	core/geometry/obsolete/surface.h	/^	typedef typename mesh_type::coordinate_tuple coordinate_tuple;$/;"	t	class:simpla::Surface
coordinate_tuple	core/geometry/test/geometry_test.cpp	/^	typedef typename manifold_type::coordinate_tuple coordinate_tuple;$/;"	t	class:TestModel	file:
coordinate_tuple	core/particle/obsolete/simple_particle.h	/^	typedef nTuple<scalar_type, 3> coordinate_tuple;$/;"	t	struct:simpla::SimpleParticleEngine
coordinate_tuple	core/particle/test/kinetic_particle_test.cpp	/^	typedef typename mesh_type::coordinate_tuple coordinate_tuple;$/;"	t	class:TestKineticParticle	file:
coordinate_tuple	example/probe_particle/demo_probe_particle.h	/^	typedef Vec3 coordinate_tuple;$/;"	t	struct:simpla::ProbeDemo
coordinate_type	core/geometry/boost_gemetry_adapted.h	/^struct coordinate_type<sgm::Primitive<N, CS, TAG> >$/;"	s	namespace:boost::geometry::traits
coordinates_global_to_local	core/manifold/mesh/MeshBlock.h	/^    virtual std::tuple<id_type, point_type> coordinates_global_to_local(point_type const &x, int n_id = 0) const$/;"	f	struct:simpla::mesh::MeshBlock
coordinates_global_to_local	core/manifold/mesh/MeshIds.h	/^    static std::tuple<id_type, point_type> coordinates_global_to_local($/;"	f	struct:simpla::mesh::MeshEntityIdCoder
coordinates_global_to_local	core/manifold/mesh/RectMesh.h	/^    virtual std::tuple<id_type, point_type> coordinates_global_to_local(point_type x, int n_id = 0) const$/;"	f	struct:simpla::mesh::Mesh
coordinates_local_to_global	core/manifold/mesh/MeshBlock.h	/^    virtual point_type coordinates_local_to_global(id_type s, point_type const &x) const$/;"	f	struct:simpla::mesh::MeshBlock
coordinates_local_to_global	core/manifold/mesh/MeshBlock.h	/^    virtual point_type coordinates_local_to_global(std::tuple<id_type, point_type> const &t) const$/;"	f	struct:simpla::mesh::MeshBlock
coordinates_local_to_global	core/manifold/mesh/MeshIds.h	/^    static point_type coordinates_local_to_global(id_type s, point_type const &x) { return point(s) + x * _R * 2; }$/;"	f	struct:simpla::mesh::MeshEntityIdCoder
coordinates_local_to_global	core/manifold/mesh/MeshIds.h	/^    static point_type coordinates_local_to_global(std::tuple<id_type, point_type> const &t)$/;"	f	struct:simpla::mesh::MeshEntityIdCoder
coordinates_local_to_global	core/manifold/mesh/RectMesh.h	/^    virtual point_type coordinates_local_to_global(std::tuple<id_type, point_type> const &t) const$/;"	f	struct:simpla::mesh::Mesh
coordinates_type	core/field/obsoleted/field_constant.h	/^	typedef typename mesh_type::coordinates_type coordinates_type;$/;"	t	class:simpla::Field
coordinates_type	core/manifold/obsoleted/block.h	/^    typedef nTuple<Real, 3> coordinates_type;$/;"	t	struct:simpla::Block
coordinates_type	core/model/test/model_test.cpp	/^	typedef typename manifold_type::coordinates_type coordinates_type;$/;"	t	class:TestModel	file:
coords	scripts/PostProcesse/particle_time_scripts.py	/^coords=algs.make_vector(x,y,z)$/;"	v
coords	scripts/PostProcesse/pv_prog_source.py	/^coords=algs.make_vector(x[:,0],x[:,1],x[:,2])$/;"	v
copy_out	core/gtl/containers/UnorderedSet.h	/^UnorderedSet<ValueType, Key>::copy_out(OutputIT out_it, TRange const &r) const$/;"	f	class:simpla::gtl::UnorderedSet
copy_out	core/gtl/containers/UnorderedSet.h	/^UnorderedSet<ValueType, Key>::copy_out(OutputIterator out_it) const$/;"	f	class:simpla::gtl::UnorderedSet
copy_out	core/gtl/containers/UnorderedSet.h	/^UnorderedSet<ValueType, Key>::copy_out(OutputIterator out_it, key_type const &s) const$/;"	f	class:simpla::gtl::UnorderedSet
copy_out	core/particle/ParticleContainer.h	/^ParticleContainer<V, K>::copy_out(OutputIT out_it, TRange const &r) const$/;"	f	class:simpla::particle::ParticleContainer
copy_out	core/particle/ParticleContainer.h	/^ParticleContainer<V, K>::copy_out(OutputIterator out_it) const$/;"	f	class:simpla::particle::ParticleContainer
copy_out	core/particle/ParticleContainer.h	/^ParticleContainer<V, K>::copy_out(OutputIterator out_it, id_type const &s) const$/;"	f	class:simpla::particle::ParticleContainer
cosdq	applications/particle_solver/pic_engine_ggauge.h	/^	Real cosdq[NMATE], sindq[NMATE];$/;"	m	class:simpla::PICEngineGGauge
count	core/gtl/containers/UnorderedSet.h	/^UnorderedSet<ValueType, Key>::count() const$/;"	f	class:simpla::gtl::UnorderedSet
count	core/gtl/containers/UnorderedSet.h	/^UnorderedSet<ValueType, Key>::count(TRange const &r) const$/;"	f	class:simpla::gtl::UnorderedSet
count	core/gtl/containers/UnorderedSet.h	/^UnorderedSet<ValueType, Key>::count(key_type const &s) const$/;"	f	class:simpla::gtl::UnorderedSet
count	core/gtl/containers/UnorderedSet.h	/^UnorderedSet<ValueType, Key>::count(typename base_type::value_type const &item) const { return item.second.size(); }$/;"	f	class:simpla::gtl::UnorderedSet
count	core/parallel/ParallelRandomGenerator.h	/^    size_t count() const { return m_count_; }$/;"	f	struct:simpla::parallel::DistributedCounter::input_iterator
count	core/particle/ParticleContainer.h	/^    template<typename ...Others> size_t count(Others &&...others) const$/;"	f	struct:simpla::particle::ParticleContainer
count	core/particle/ParticleGenerator.h	/^        size_t count() const { return m_count_; }$/;"	f	struct:simpla::particle::ParticleGenerator::input_iterator
count_	core/numeric/sobol_engine.h	/^	size_t count_;$/;"	m	class:simpla::sobol_engine
count_	core/particle/ParticleContainer.h	/^ParticleContainer<V, K>::count_(container_type const &d)$/;"	f	class:simpla::particle::ParticleContainer
count_	core/particle/ParticleContainer.h	/^ParticleContainer<V, K>::count_(container_type const &d, TRange const &r0)$/;"	f	class:simpla::particle::ParticleContainer
count_	core/particle/ParticleContainer.h	/^ParticleContainer<V, K>::count_(container_type const &d, id_type const &s)$/;"	f	class:simpla::particle::ParticleContainer
count_	core/particle/ParticleContainer.h	/^ParticleContainer<V, K>::count_(container_type const &d, typename container_type::value_type const &item)$/;"	f	class:simpla::particle::ParticleContainer
count_bits	core/gtl/type_traits_ext.h	/^inline unsigned long count_bits(unsigned long s)$/;"	f	namespace:simpla
covector_type	core/geometry/CoordinateSystem.h	/^struct covector_type$/;"	s	namespace:simpla::geometry::traits
covector_type	core/geometry/csCartesian.h	/^    typedef nTuple<scalar_type, 3> covector_type;$/;"	t	struct:simpla::geometry::CartesianMetric
covector_type	core/geometry/csCylindrical.h	/^    typedef nTuple<scalar_type, 3> covector_type;$/;"	t	struct:simpla::geometry::Metric
create	applications/contexts/explicit_em.h	/^    static std::shared_ptr<base_type> create(Args &&... args)$/;"	f	struct:simpla::ExplicitEMContext
create	core/data_model/DataSet.h	/^DataSet DataSet::create(Args &&...args)$/;"	f	class:simpla::data_model::DataSet
create	core/data_model/DataType.h	/^    static DataType create(std::string const &name = "")$/;"	f	struct:simpla::data_model::DataType::create_helper
create	core/data_model/DataType.h	/^    static DataType create(std::string const &s_name = "")$/;"	f	struct:simpla::data_model::DataType
create	core/field/FieldFunction.h	/^    static this_type create(mesh_type const &m, TFun const &fun)$/;"	f	class:simpla::Field
create	core/gtl/design_pattern/factory.h	/^	product_type create(identifier_type const &id, Args ... args) const$/;"	f	struct:simpla::Factory
create	core/gtl/enable_create_from_this.h	/^	static holder create()$/;"	f	struct:simpla::enable_create_from_this
create	core/gtl/enable_create_from_this.h	/^	static holder create(Args && ...args)$/;"	f	struct:simpla::enable_create_from_this
create	core/parallel/MPIDataType.cpp	/^MPIDataType MPIDataType::create(data_model::DataType const &data_type, \/\/$/;"	f	class:simpla::MPIDataType
create	core/parallel/MPIDataType.cpp	/^MPIDataType MPIDataType::create(data_model::DataType const &data_type, data_model::DataSpace const &d_space,$/;"	f	class:simpla::MPIDataType
create	core/parallel/MPIDataType.h	/^    static MPIDataType create(Others &&... others)$/;"	f	struct:simpla::MPIDataType
create	core/particle/ParticleFactory.h	/^create(TMesh &mesh, TDict const &dict)$/;"	f	namespace:simpla::particle
create	core/particle/ParticleProxy.h	/^    static std::shared_ptr<this_type> create(std::shared_ptr<TP> p)$/;"	f	struct:simpla::particle::ParticleProxyBase
createVisitor	core/gtl/design_pattern/visitor.h	/^std::shared_ptr<VisitorBase> createVisitor(std::string const &name, Args ...args)$/;"	f	namespace:simpla
create_	core/data_model/DataType.h	/^    static DataType create_(std::string const &name, std::integral_constant<bool, false>)$/;"	f	struct:simpla::data_model::DataType::create_helper
create_	core/data_model/DataType.h	/^    static DataType create_(std::string const &name, std::integral_constant<bool, true>)$/;"	f	struct:simpla::data_model::DataType::create_helper
create_attribute	core/manifold/Manifold.h	/^    std::shared_ptr<Attribute<TV, IFORM>> create_attribute() const$/;"	f	class:simpla::Manifold
create_attribute	core/manifold/Manifold.h	/^    std::shared_ptr<Attribute<TV, IFORM>> create_attribute(std::string const &s_name = "")$/;"	f	class:simpla::Manifold
create_child	core/gtl/containers/container_container.h	/^	value_type create_child() const$/;"	f	class:simpla::ContainerContainer
create_data_set	core/data_model/DataSet.h	/^DataSet create_data_set(DataType const &dtype)$/;"	f	namespace:simpla::data_model::_impl
create_data_set	core/data_model/DataSet.h	/^DataSet create_data_set(DataType const &dtype, std::shared_ptr<void> const &data, Args &&...args)$/;"	f	namespace:simpla::data_model::_impl
create_data_set	core/data_model/DataSet.h	/^DataSet create_data_set(T const *p, Args &&...args)$/;"	f	namespace:simpla::data_model::_impl
create_data_set	core/data_model/DataSet.h	/^DataSet create_data_set(T const *p, int ndims, typename DataSpace::index_type const *d)$/;"	f	namespace:simpla::data_model::_impl
create_data_set	core/data_model/DataSet.h	/^DataSet create_data_set(std::shared_ptr<T> &p, Args &&...args)$/;"	f	namespace:simpla::data_model::_impl
create_data_set	core/data_model/DataSet.h	/^DataSet create_data_set(std::vector<T> const &p)$/;"	f	namespace:simpla::data_model::_impl
create_data_set	core/data_model/DataSet.h	/^create_data_set(std::shared_ptr<T> const &p, Args &&...args)$/;"	f	namespace:simpla::data_model::_impl
create_datadesc	applications/particle_solver/pic_engine_fullf.h	/^		static DataType create_datadesc()$/;"	f	struct:simpla::PICEngineFullF::Point_s
create_datadesc	applications/particle_solver/pic_engine_implicit.h	/^		static DataType create_datadesc()$/;"	f	struct:simpla::PICEngineImplicit::Point_s
create_from_config	core/field/FieldFunction.h	/^    static this_type create_from_config(mesh_type const &m, TDict const &dict)$/;"	f	class:simpla::Field
create_from_this	core/gtl/enable_create_from_this.h	/^	std::shared_ptr<TOther> create_from_this(Args && ...args) const$/;"	f	struct:simpla::enable_create_from_this
create_from_this	core/gtl/enable_create_from_this.h	/^	std::shared_ptr<TOther> create_from_this(Args && ...args)$/;"	f	struct:simpla::enable_create_from_this
create_fun_callback	core/gtl/design_pattern/factory.h	/^	typedef std::function<product_type(Args ...)> create_fun_callback;$/;"	t	struct:simpla::Factory
create_helper	core/data_model/DataType.h	/^struct DataType::create_helper$/;"	s	class:simpla::data_model::DataType
create_id_set	core/model/Constraint.h	/^void create_id_set(TM const &m, TRange const &r0, TSet *res)$/;"	f	namespace:simpla::model
create_observer	core/gtl/design_pattern/observer.h	/^			std::shared_ptr<T>>::type create_observer(Args &&...args)$/;"	f	struct:simpla::Observable
create_particle	core/particle/ParticleFactory.h	/^create_particle(std::string const &key, TDict const &dict)$/;"	f	namespace:simpla::particle
create_particle	example/em_tokamak/tokamak.cpp	/^EMTokamak::create_particle(std::string const &key, TDict const &dict, TRange const &r0)$/;"	f	class:simpla::EMTokamak
create_patch	core/base/Attribute.h	/^    virtual std::shared_ptr<this_type> create_patch(size_t id)$/;"	f	class:simpla::base::Attribute
create_simple	core/data_model/DataSpace.cpp	/^DataSpace DataSpace::create_simple(int ndims, const index_type *dims)$/;"	f	class:simpla::data_model::DataSpace
create_simple_unordered	core/data_model/DataSpace.cpp	/^std::tuple<DataSpace, DataSpace> DataSpace::create_simple_unordered(size_t count)$/;"	f	class:simpla::data_model::DataSpace
cross	core/geometry/obsolete/polygons.h	/^inline double cross(vec a, vec b)$/;"	f
cross	core/geometry/primitive.h	/^Vector<CS> cross(Vector<CS> const &x1, T2 const &v)$/;"	f	namespace:simpla::geometry::model
cross_product	core/geometry/boost_gemetry_adapted.h	/^model::Point<CS> cross_product(const bg::model::segment<model::Point<CS>>& p1,$/;"	f	namespace:simpla::geometry::detail
cross_product	core/geometry/boost_gemetry_adapted.h	/^model::Point<CS> cross_product(const model::Point<CS>& p1,$/;"	f	namespace:simpla::geometry::detail
cs	core/field/test/field_diff_calculus_test.h	/^typedef geometry::traits::coordinate_system_t<mesh_type> cs;$/;"	t
cs	core/geometry/csCylindrical.h	/^    typedef ::simpla::geometry::coordinate_system::Cylindrical<IPhiAxis> cs;$/;"	t	struct:simpla::geometry::Metric
cs	example/em/em.cpp	/^typedef geometry::coordinate_system::Cylindrical<2> cs;$/;"	t	file:
ctx	scripts/configure/test.py	/^ctx=SimPla.Context()$/;"	v
current_line_char_count_	core/gtl/utilities/log.h	/^    int current_line_char_count_;$/;"	m	class:simpla::logger::Logger
cut	core/geometry/obsolete/polygon.h	/^bool PolyGon<TM>::cut(id_type s, std::list<coordinate_tuple>* res)$/;"	f	class:simpla::PolyGon
cycle_length	core/gtl/iterator/iterator_cycle.h	/^	size_t cycle_length() const$/;"	f	struct:simpla::iterator_cycle
d	core/gtl/test/ntuple_perf_test.cpp	/^	value_type a, b, c, d;$/;"	m	class:nTuplePerf1	file:
d	core/gtl/test/ntuple_perf_test.cpp	/^	value_type a, b, c, d;$/;"	m	class:nTuplePerf2	file:
d	core/gtl/test/ntuple_reduce_test.cpp	/^	value_type a, b, c, d;$/;"	m	class:TestNtupleReduce	file:
dB	applications/contexts/explicit_em.h	/^    field<scalar_type, FACE> B1, dB;$/;"	m	struct:simpla::ExplicitEMContext
darray	core/parallel/test/distributed_array_test.cpp	/^	DistributedArray darray;$/;"	m	class:TestDistArray	file:
data	core/data_model/DataSet.h	/^    std::shared_ptr<void> data;$/;"	m	struct:simpla::data_model::DataSet
data	core/field/FieldDense.h	/^    std::shared_ptr<attribute_type> data() { return m_data_; }$/;"	f	class:simpla::Field
data	core/geometry/chains.h	/^    data_type &data()$/;"	f	struct:simpla::geometry::model::Chains
data	core/geometry/chains.h	/^    data_type const &data() const$/;"	f	struct:simpla::geometry::model::Chains
data	core/geometry/polygon.h	/^    std::vector<point2d_type> &data() { return m_polygon_; };$/;"	f	struct:simpla::geometry::Polygon
data	core/geometry/polygon.h	/^    std::vector<point2d_type> const &data() const { return m_polygon_; };$/;"	f	class:simpla::geometry::Polygon::std
data	core/gtl/any.h	/^    void *data() { return ptr_ != nullptr ? ptr_->data() : nullptr; }$/;"	f	struct:simpla::any
data	core/gtl/any.h	/^    void *data() { return reinterpret_cast<void *>(&m_value); }$/;"	f	struct:simpla::Derived
data	core/gtl/any.h	/^    void const *data() const { return ptr_ != nullptr ? ptr_->data() : nullptr; }$/;"	f	struct:simpla::any
data	core/gtl/any.h	/^    void const *data() const { return reinterpret_cast<void const *>(&m_value); }$/;"	f	struct:simpla::Derived
data	core/gtl/containers/container_dense.h	/^	const std::shared_ptr<value_type> data() const$/;"	f	class:simpla::DenseContainer
data	core/gtl/containers/container_dense.h	/^	std::shared_ptr<value_type> data()$/;"	f	class:simpla::DenseContainer
data	core/gtl/containers/sp_hash_container.h	/^	std::shared_ptr<value_type> data()$/;"	f	struct:simpla::SpHashContainer
data	core/manifold/policy/StoragePolicy.h	/^    std::shared_ptr<TV> data() const$/;"	f	struct:simpla::manifold::policy::StoragePolicy
data	core/numeric/interpolation.h	/^    const std::shared_ptr<value_type> data() const$/;"	f	class:simpla::MultiDimesionInterpolation
data	core/numeric/interpolation.h	/^    inline container_type &data()$/;"	f	class:simpla::Interpolation
data	core/numeric/interpolation.h	/^    inline container_type const &data() const$/;"	f	class:simpla::Interpolation
data	core/numeric/interpolation.h	/^    std::shared_ptr<value_type> data()$/;"	f	class:simpla::MultiDimesionInterpolation
data	core/parallel/obsoleted/distributed_comm.h	/^	DataSet data;$/;"	m	struct:simpla::parallel::link_node
data_	core/field/test/trash/field_continue.h	/^	std::shared_ptr<container_type> data_;$/;"	m	struct:simpla::Field
data_	core/gtl/containers/container_dense.h	/^	std::shared_ptr<value_type> data_;$/;"	m	class:simpla::DenseContainer
data_	core/gtl/iterator/sp_iterator_mapped.h	/^	storage_type data_;$/;"	m	struct:simpla::Iterator
data_	core/gtl/iterator/sp_iterator_shared_container.h	/^	std::shared_ptr<T> data_;$/;"	m	struct:simpla::_impl::StorageSharedContainer
data_	core/gtl/iterator/sp_iterator_shared_container.h	/^	value_type* data_;$/;"	m	struct:simpla::_impl::StorageSharedContainer
data_	core/gtl/ntuple.h	/^    sub_type data_[m_extent];$/;"	m	struct:simpla::nTuple
data_	core/numeric/interpolation.h	/^    std::shared_ptr<container_type> data_;$/;"	m	class:simpla::Interpolation
data_	core/numeric/interpolation.h	/^    std::shared_ptr<value_type> data_;$/;"	m	class:simpla::MultiDimesionInterpolation
data_	core/particle/obsolete/kinetic_particle.h	/^    std::vector<Point_s> data_;$/;"	m	struct:KineticParticle
data_	core/particle/obsolete/probe_particle.h	/^    std::vector<Point_s> data_;$/;"	m	struct:simpla::ProbeParticle
data_container_type	core/gtl/containers/iterator_proxy.h	/^	typedef TD data_container_type;$/;"	t	struct:simpla::iterator_proxy
data_model	core/data_model/DataSet.cpp	/^namespace simpla { namespace data_model$/;"	n	namespace:simpla	file:
data_model	core/data_model/DataSet.h	/^namespace simpla { namespace data_model$/;"	n	namespace:simpla
data_model	core/data_model/DataSpace.cpp	/^namespace simpla { namespace data_model$/;"	n	namespace:simpla	file:
data_model	core/data_model/DataSpace.h	/^namespace simpla { namespace data_model$/;"	n	namespace:simpla
data_model	core/data_model/DataType.cpp	/^namespace data_model$/;"	n	namespace:simpla	file:
data_model	core/data_model/DataType.h	/^namespace simpla { namespace data_model$/;"	n	namespace:simpla
data_model	core/parallel/DistributedObject.h	/^namespace simpla { namespace data_model { class DataSet; }}$/;"	n	namespace:simpla
data_set	core/base/Attribute.h	/^    virtual data_model::DataSet data_set() const { return this->mesh().template data_set<TV, IFORM>(m_data_); };$/;"	f	class:simpla::base::Attribute
data_set	core/field/FieldDense.h	/^    data_model::DataSet data_set() const { return attribute()->data_set(); }$/;"	f	class:simpla::Field
data_set	core/field/FieldDense.h	/^    data_model::DataSet data_set() { return data()->data_set(); }$/;"	f	class:simpla::Field
data_set	core/manifold/policy/StoragePolicy.h	/^    data_model::DataSet data_set(std::shared_ptr<TV> d = nullptr) const$/;"	f	struct:simpla::manifold::policy::StoragePolicy
data_set	core/particle/Particle.h	/^    virtual data_model::DataSet data_set() const { return m_data_->data_set(); }$/;"	f	struct:simpla::particle::Particle
data_set	core/particle/ParticleContainer.h	/^ParticleContainer<P, M>::data_set() const$/;"	f	class:simpla::particle::ParticleContainer
data_set	core/particle/ParticleProxy.h	/^    virtual data_model::DataSet data_set() const { return m_self_->data_set(); }$/;"	f	class:simpla::particle::ParticleProxy
data_shape_s	core/data_model/DataSpace.h	/^    > data_shape_s;$/;"	t	class:simpla::data_model::DataSpace
data_space	core/data_model/DataSet.h	/^    DataSpace data_space;$/;"	m	struct:simpla::data_model::DataSet
data_space	core/manifold/policy/StoragePolicy.h	/^    std::tuple<data_model::DataSpace, data_model::DataSpace> data_space($/;"	f	struct:simpla::manifold::policy::StoragePolicy
data_space	core/manifold/policy/StoragePolicy.h	/^    std::tuple<data_model::DataSpace, data_model::DataSpace> data_space() const$/;"	f	struct:simpla::manifold::policy::StoragePolicy
data_type	core/data_model/DataSet.h	/^    DataType data_type;$/;"	m	struct:simpla::data_model::DataSet
data_type	core/geometry/chains.h	/^    typedef std::map<id_type, indices_tuple> data_type;$/;"	t	struct:simpla::geometry::model::Chains
data_type	core/gtl/any.h	/^    data_model::DataType data_type() const { return data_model::DataType::template create<T>(); }$/;"	f	struct:simpla::Derived
data_type	core/gtl/any.h	/^    data_model::DataType data_type() const { return ptr_->data_type(); }$/;"	f	struct:simpla::any
data_type	core/io/WriteBuffer.h	/^    void data_type(data_model::DataType const &d_type) { m_data_type_ = d_type; }$/;"	f	class:simpla::io::WriteBuffer
data_view	core/data_model/data_view.h	/^	data_view(index_range_type const &r) :$/;"	f	struct:simpla::data_view
data_view	core/data_model/data_view.h	/^	data_view(this_type &other, tags::split) :$/;"	f	struct:simpla::data_view
data_view	core/data_model/data_view.h	/^	data_view(this_type const &other) :$/;"	f	struct:simpla::data_view
data_view	core/data_model/data_view.h	/^struct data_view<TV, IndexRange, Tags...>$/;"	s	namespace:simpla
dataset	core/gtl/containers/sp_ndarray.h	/^	DataSet dataset() const$/;"	f	class:simpla::ndArray
dataset	core/gtl/containers/unordered_set.h	/^DataSet UnorderedSet<T, BucketKeyType, Allocator>::dataset() const$/;"	f	class:simpla::UnorderedSet
dataset	core/gtl/containers/unordered_set.h	/^void UnorderedSet<T, BucketKeyType, Allocator>::dataset(DataSet const &ds)$/;"	f	class:simpla::UnorderedSet
dataset	core/particle/obsolete/probe_particle.h	/^DataSet ProbeParticle<Engine>::dataset() const$/;"	f	class:simpla::ProbeParticle
decltype	core/gtl/expression_template.h	/^    static constexpr auto eval(TL const &l) -> decltype((l * l)) { return l * l; }$/;"	f	struct:simpla::_impl::_pow2
declval	core/geometry/algorithm.h	/^            std::declval<typename traits::coordinate_type<CS>::type>())$/;"	f	class:simpla::geometry::std
declval	core/geometry/boost_gemetry_adapted.h	/^		std::declval<typename traits::coordinate_type<CS>::type>())$/;"	f	class:simpla::geometry::detail::std
decompact	applications/particle_solver/pic_engine_ggauge.h	/^		static Point_s decompact(compact_type const & t)$/;"	f	struct:simpla::PICEngineGGauge::Point_s
decompose	core/manifold/mesh/MeshBlock.cpp	/^void MeshBlock::decompose(index_tuple const &dist_dimensions, index_tuple const &dist_coord)$/;"	f	class:simpla::mesh::MeshBlock
default_time_integral	core/manifold/obsoleted/amr_policy.h	/^void default_time_integral(AMR<TMesh> const &m, TFun const &fun, Real dt, Args &&...args)$/;"	f	namespace:simpla::manifold::policy
default_time_integral	core/manifold/obsoleted/patch/mesh_patch.h	/^void default_time_integral(MeshPatch<TM> const &m, TFun const &fun, Real dt, Args &&...args)$/;"	f	namespace:simpla::mesh
default_value	core/field/test/field_basic_algebra_test.h	/^    value_type default_value;$/;"	m	class:TestField
default_value	core/field/test/field_io_test.h	/^	value_type default_value;$/;"	m	class:simpla::TestFieldIO
default_value	core/field/test/trash/fetl_test2.h	/^	value_type default_value;$/;"	m	class:TestField
default_value	core/gtl/containers/container_container.h	/^	value_type const & default_value() const$/;"	f	class:simpla::ContainerContainer
default_value	core/gtl/containers/container_dense.h	/^	value_type const & default_value() const$/;"	f	class:simpla::DenseContainer
default_value	core/gtl/containers/container_sparse.h	/^    value_type const &default_value() const$/;"	f	class:simpla::SparseContainer
default_value_	core/gtl/containers/container_container.h	/^	value_type default_value_;$/;"	m	class:simpla::ContainerContainer
default_value_	core/gtl/containers/container_dense.h	/^	const value_type default_value_;$/;"	m	class:simpla::DenseContainer
default_value_	core/gtl/containers/container_sparse.h	/^    value_type default_value_;$/;"	m	class:simpla::SparseContainer
delete_attribute	core/io/HDF5Stream.cpp	/^void HDF5Stream::delete_attribute(std::string const &url)$/;"	f	class:simpla::io::HDF5Stream
deleter_s	core/gtl/utilities/memory_pool.h	/^        deleter_s(void *p, size_t s)$/;"	f	struct:simpla::MemoryPool::deleter_s
deleter_s	core/gtl/utilities/memory_pool.h	/^    struct deleter_s$/;"	s	class:simpla::MemoryPool
delta_index	core/manifold/mesh/MeshIds.h	/^    static constexpr id_type delta_index(id_type s)$/;"	f	struct:simpla::mesh::MeshEntityIdCoder
delta_t	core/geometry/csCylindrical.h	/^    typedef nTuple<Real, 3> delta_t;$/;"	t	struct:simpla::geometry::Metric
density	core/particle/ParticleGenerator.h	/^    template<typename TFun> void density(TFun const &fun) { m_density_ = fun; }$/;"	f	class:simpla::particle::ParticleGeneratorPerCell
deploy	core/base/Attribute.h	/^    virtual void deploy() { if (empty()) { m_data_ = this->mesh().template data<value_type, IFORM>(); }}$/;"	f	class:simpla::base::Attribute
deploy	core/field/FieldDense.h	/^    void deploy() { data()->deploy(); }$/;"	f	class:simpla::Field
deploy	core/geometry/polygon.cpp	/^void Polygon<2>::deploy()$/;"	f	class:simpla::geometry::Polygon
deploy	core/gtl/containers/sp_hash_container.h	/^	void deploy()$/;"	f	struct:simpla::SpHashContainer
deploy	core/gtl/containers/sp_ndarray.h	/^	void deploy()$/;"	f	class:simpla::ndArray
deploy	core/manifold/Manifold.h	/^    virtual void deploy()$/;"	f	class:simpla::Manifold
deploy	core/manifold/mesh/CartesianCoRect.h	/^    virtual void deploy()$/;"	f	struct:simpla::mesh::CartesianCoRect
deploy	core/manifold/mesh/CoRectMesh.h	/^    virtual void deploy()$/;"	f	struct:simpla::mesh::Mesh
deploy	core/manifold/mesh/CylindricalCoRect.h	/^void CylindricalCoRect::deploy()$/;"	f	class:simpla::mesh::CylindricalCoRect
deploy	core/manifold/mesh/MeshBlock.h	/^    virtual void deploy() { deploy2(); }$/;"	f	struct:simpla::mesh::MeshBlock
deploy	core/manifold/mesh/RectMesh.h	/^void Mesh<TMetric, tags::rect_linear, TMap>::deploy()$/;"	f	class:simpla::mesh::Mesh
deploy	core/manifold/obsoleted/patch/mesh_patch.h	/^    virtual void deploy() { };$/;"	f	class:simpla::mesh::MeshPatch
deploy	core/manifold/obsoleted/time_integrator_policy.h	/^    void deploy() { }$/;"	f	struct:simpla::manifold::policy::TimeIntegrator
deploy	core/manifold/policy/IOPolicy.h	/^    virtual void deploy()$/;"	f	struct:simpla::manifold::policy::IOPolicy
deploy	core/manifold/policy/ParallelPolicy.h	/^void ParallelPolicy<TMesh>::deploy()$/;"	f	class:simpla::manifold::policy::ParallelPolicy
deploy	core/manifold/policy/StoragePolicy.h	/^    void deploy() { }$/;"	f	struct:simpla::manifold::policy::StoragePolicy
deploy	core/model/obsoleted/revolve_polygon.h	/^    void deploy()$/;"	f	struct:simpla::RevolvePolygon
deploy	core/parallel/obsoleted/distributed_array.cpp	/^void Distributed<DataSet>::deploy()$/;"	f	class:simpla::Distributed
deploy	core/parallel/obsoleted/distributed_unordered_set.h	/^void Distributed<UnorderedSet<TV, Others...>>::deploy(TCoonection const &conns)$/;"	f	class:simpla::Distributed
deploy	core/parallel/trash/distributed_unordered_set.cpp	/^void DistributedUnorderedSetBase::deploy(std::vector<dist_sync_connection> const &ghost_shape)$/;"	f	class:simpla::DistributedUnorderedSetBase
deploy	core/particle/Particle.h	/^    virtual void deploy() { m_data_->deploy(); }$/;"	f	struct:simpla::particle::Particle
deploy	core/particle/ParticleContainer.h	/^ParticleContainer<P, M>::deploy()$/;"	f	class:simpla::particle::ParticleContainer
deploy	core/particle/ParticleProxy.h	/^    virtual void deploy() { m_self_->deploy(); }$/;"	f	class:simpla::particle::ParticleProxy
deploy	core/particle/obsolete/probe_particle.h	/^bool ProbeParticle<Engine>::deploy()$/;"	f	class:simpla::ProbeParticle
deploy	core/particle/pre_define/GuidingCenter.h	/^    void deploy()$/;"	f	struct:simpla::particle::engine::GuidingCenterEngine
deploy	core/particle/pre_define/PICBoris.h	/^    void deploy()$/;"	f	struct:simpla::particle::engine::BorisEngine
deploy	core/particle/pre_define/PICGyro.h	/^    void deploy()$/;"	f	struct:simpla::particle::engine::GyroParticleWithCylindricalCoord
deploy2	core/manifold/mesh/MeshBlock.cpp	/^void MeshBlock::deploy2()$/;"	f	class:simpla::mesh::MeshBlock
deploy_pip	core/geometry/obsolete/polygon.h	/^void PolyGon<TM>::deploy_pip()$/;"	f	class:simpla::PolyGon
description	applications/contexts/explicit_em.h	/^    std::string description;$/;"	m	struct:simpla::ExplicitEMContext
description	core/model/GEqdsk.cpp	/^std::string const &GEqdsk::description() const { return m_pimpl_->m_desc_; }$/;"	f	class:simpla::std::GEqdsk
description_	core/gtl/utilities/parser_configure.h	/^	std::map<std::string, std::string> description_;$/;"	m	class:simpla::ParserConfigure
descritpion	applications/fokker_planck/lhw.cpp	/^static const char descritpion[] = "Example for fokker_planck";$/;"	v	file:
dest_id	core/parallel/obsoleted/distributed_comm.h	/^	int dest_id;$/;"	m	struct:simpla::parallel::link_node
detail	core/geometry/boost_gemetry_adapted.h	/^namespace detail$/;"	n	namespace:simpla::geometry
dh	core/geometry/test/geometry_test.cpp	/^	nTuple<Real, ndims> dh;$/;"	m	class:TestModel	file:
dh	core/model/test/model_test.cpp	/^	nTuple<Real, ndims> dh;$/;"	m	class:TestModel	file:
dict_type	core/gtl/utilities/parser_configure.h	/^	typedef TDict dict_type;$/;"	t	class:simpla::ParserConfigure
diff_type	core/gtl/iterator/iterator_sequence.h	/^			std::minus<value_type>(value_type, value_type)>::type diff_type;$/;"	t	class:simpla::IteratorSequence
difference_type	core/gtl/iterator/iterator.h	/^	typedef typename iterator::difference_type difference_type;$/;"	t	struct:std::iterator_traits
difference_type	core/gtl/iterator/sp_iterator_shared_container.h	/^	typedef typename std::iterator_traits<key_iterator_type>::difference_type difference_type;$/;"	t	class:simpla::TransformIterator
difference_type	core/manifold/mesh/MeshIds.h	/^    typedef long difference_type;$/;"	t	struct:simpla::mesh::MeshEntityIdCoder
dimension	core/geometry/CoordinateSystem.h	/^struct dimension$/;"	s	namespace:simpla::geometry::traits
dimension	core/geometry/CoordinateSystem.h	/^struct dimension<coordinate_system::Cartesian<N>>$/;"	s	namespace:simpla::geometry::traits
dimension	core/geometry/CoordinateSystem.h	/^struct dimension<coordinate_system::Polar>$/;"	s	namespace:simpla::geometry::traits
dimension	core/geometry/boost_gemetry_adapted.h	/^struct dimension<sgm::Primitive<N, CS, TAG>> : boost::mpl::int_<$/;"	s	namespace:boost::geometry::traits
dimension	core/geometry/chains.h	/^    static constexpr size_t dimension = traits::dimension<primitive_type>::value;$/;"	m	struct:simpla::geometry::model::Chains
dimension	core/geometry/chains.h	/^struct dimension<model::Chains<PrimitiveType, Others...>>$/;"	s	namespace:simpla::geometry::traits
dimension	core/geometry/primitive.h	/^struct dimension<model::Primitive<Dimension, CoordinateSystem, Tag>>$/;"	s	namespace:simpla::geometry::traits
dimensions	core/gtl/containers/sp_ndarray.h	/^	index_tuple const & dimensions() const$/;"	f	class:simpla::ndArray
dimensions	core/gtl/containers/sp_ndarray.h	/^	void dimensions(TD const & d)$/;"	f	class:simpla::ndArray
dimensions	core/gtl/containers/sp_ndarray.h	/^	void dimensions(index_tuple const & d)$/;"	f	class:simpla::ndArray
dimensions	core/manifold/mesh/MeshBlock.cpp	/^void MeshBlock::dimensions(index_tuple const &d)$/;"	f	class:simpla::mesh::MeshBlock
dimensions	core/manifold/mesh/MeshBlock.h	/^    index_tuple const &dimensions() const { return m_dimensions_; }$/;"	f	struct:simpla::mesh::MeshBlock
dimensions	core/model/GEqdsk.cpp	/^nTuple<int, 3> const &GEqdsk::dimensions() const$/;"	f	class:simpla::GEqdsk
dimensions	core/numeric/interpolation.h	/^    inline nTuple <size_t, NDIMS> dimensions() const$/;"	f	class:simpla::BiLinearInterpolation
dimensions	core/numeric/interpolation.h	/^    inline void dimensions(nTuple <size_t, NDIMS> const &dims)$/;"	f	class:simpla::BiLinearInterpolation
dims	core/field/test/field_diff_calculus_test.h	/^    nTuple<size_t, 3> dims;$/;"	m	class:FETLTest
dims	core/field/test/trash/fetl_test3.h	/^	nTuple<NDIMS, size_t> dims;$/;"	m	class:TestFETL
dims	core/geometry/test/geometry_test.cpp	/^	nTuple<size_t, ndims> dims\/* = { 50, 60, 10 }*\/;$/;"	m	class:TestModel	file:
dims	core/gtl/test/sp_iterator_test.cpp	/^	nTuple<3, size_t> dims;$/;"	m	class:TestIterator	file:
dims	core/model/test/model_test.cpp	/^	nTuple<size_t, ndims> dims\/* = { 50, 60, 10 }*\/;$/;"	m	class:TestModel	file:
dims	core/particle/test/kinetic_particle_test.h	/^	nTuple<size_t, 3> dims;$/;"	m	class:TestKineticParticle
dims0	core/gtl/test/ntuple_perf_test.cpp	/^	size_t dims0, dims1;$/;"	m	class:nTuplePerf1	file:
dims0	core/gtl/test/ntuple_perf_test.cpp	/^	size_t dims0, dims1;$/;"	m	class:nTuplePerf2	file:
dims1	core/gtl/test/ntuple_perf_test.cpp	/^	size_t dims0, dims1;$/;"	m	class:nTuplePerf1	file:
dims1	core/gtl/test/ntuple_perf_test.cpp	/^	size_t dims0, dims1;$/;"	m	class:nTuplePerf2	file:
dims_	core/numeric/interpolation.h	/^    nTuple <size_t, NDIMS> dims_;$/;"	m	class:simpla::BiLinearInterpolation
disable_field	example/em_tokamak/tokamak.cpp	/^    bool disable_field = false;$/;"	m	struct:simpla::EMTokamak	file:
disable_particle	example/em_tokamak/tokamak.cpp	/^    bool disable_particle = false;$/;"	m	struct:simpla::EMTokamak	file:
discard	core/numeric/sobol_engine.h	/^	inline void discard(size_t u)$/;"	f	class:simpla::sobol_engine
disconnect	core/gtl/design_pattern/observer.h	/^	void disconnect()$/;"	f	struct:simpla::Observer
disconnect	core/gtl/design_pattern/observer.h	/^	void disconnect(observer_type *observer)$/;"	f	struct:simpla::Observable
disconnect	core/gtl/design_pattern/signal.h	/^    void disconnect(iterator it)$/;"	f	struct:simpla::Signal
distance	core/geometry/cube.h	/^typename traits::length_type<CS>::type distance($/;"	f	namespace:simpla::geometry
distance	core/geometry/model.h	/^	length_type distance(point_type const & x) const$/;"	f	struct:simpla::geometry::model::Primitive
distance	core/geometry/model.h	/^typename traits::length_type<CS>::type distance(TPoint const & p,$/;"	f	namespace:simpla::geometry::model
distance	core/geometry/obsolete/surface.h	/^	std::tuple<Real, Vec3> distance(coordinate_tuple const & x) const$/;"	f	class:simpla::Surface
distance	core/geometry/simplex.h	/^typename traits::length_type<CS>::type distance($/;"	f	namespace:simpla::geometry
distance	core/gtl/iterator/block_iterator.h	/^    ptrdiff_t distance() const$/;"	f	struct:simpla::block_iterator
distance	core/gtl/iterator/sp_ntuple_range.h	/^IndexType distance($/;"	f	namespace:simpla
distance_from_line_to_plane	core/geometry/GeoAlgorithm.h	/^std::tuple<Real, Real, Real, Real> distance_from_line_to_plane(T0 const &P0, T1 const &P1, T2 const &Q0, T3 const &Q1,$/;"	f	namespace:simpla::geometry
distance_from_point_to_plane	core/geometry/GeoAlgorithm.h	/^std::tuple<Real, Real, Real> distance_from_point_to_plane(T0 const &P0,$/;"	f	namespace:simpla::geometry
distance_from_point_to_plane	core/geometry/GeoAlgorithm.h	/^std::tuple<Real, Vec3> distance_from_point_to_plane(T0 const &x0,$/;"	f	namespace:simpla::geometry
distance_from_point_to_polylines	core/geometry/GeoAlgorithm.h	/^std::tuple<Real, Real, TI, TI> distance_from_point_to_polylines(TX const &x,$/;"	f	namespace:simpla::geometry
divide	core/geometry/obsolete/surface.h	/^	bool divide(id_type s)$/;"	f	class:simpla::Surface
divide_box	core/geometry/cut_cell.h	/^size_t divide_box(TMesh const & mesh, DistFunction const & dist_fun, TRes )$/;"	f	namespace:simpla
do_not_excute	core/field/FieldExpression.h	/^    void do_not_excute()$/;"	f	struct:simpla::Field
do_nothing	core/gtl/type_traits.h	/^struct do_nothing$/;"	s	namespace:simpla::tags
domain	core/field/test/trash/fetl_test2.h	/^	domain_type domain;$/;"	m	class:TestField
domain_	core/particle/obsolete/kinetic_particle.h	/^    domain_type domain_;$/;"	m	struct:KineticParticle
domain_type	core/field/test/trash/fetl_test2.h	/^	typedef typename TField::domain_type domain_type;$/;"	t	class:TestField
domain_type	core/particle/obsolete/kinetic_particle.h	/^    typedef TDomain domain_type;$/;"	t	struct:simpla::_impl::particle_hasher
done	core/gtl/utilities/log.h	/^inline Logger &done(Logger &self)$/;"	f	namespace:simpla::logger
dot	core/geometry/obsolete/polygons.h	/^inline double dot(vec a, vec b)$/;"	f
dot	core/gtl/ntuple.h	/^inline constexpr double dot(double const &l, double const &r) { return r * l; }$/;"	f	namespace:simpla
dot	core/gtl/ntuple.h	/^inline constexpr float dot(float const &l, float const &r) { return r * l; }$/;"	f	namespace:simpla
download_cache	core/particle/obsolete/probe_particle.h	/^void ProbeParticle<Engine>::download_cache()$/;"	f	class:simpla::ProbeParticle
dt	core/manifold/Manifold.h	/^    double dt() const { return m_dt_; }$/;"	f	class:simpla::Manifold
dt	core/manifold/Manifold.h	/^    void dt(double p_dt) { m_dt_ = p_dt; }$/;"	f	class:simpla::Manifold
dt	core/manifold/obsoleted/time_integrator_policy.h	/^    double dt() const { return m_dt_; }$/;"	f	struct:simpla::manifold::policy::TimeIntegrator
dt	core/manifold/obsoleted/time_integrator_policy.h	/^    void dt(double p_dt) { m_dt_ = p_dt; }$/;"	f	struct:simpla::manifold::policy::TimeIntegrator
dual	core/manifold/mesh/MeshIds.h	/^    static constexpr id_type dual(id_type s)$/;"	f	struct:simpla::mesh::MeshEntityIdCoder
dual_volume	core/manifold/mesh/CartesianCoRect.h	/^    virtual Real dual_volume(id_type s) const { return m_dual_volume_[node_id(s)]; }$/;"	f	struct:simpla::mesh::CartesianCoRect
dual_volume	core/manifold/mesh/CoRectMesh.h	/^    virtual Real dual_volume(id_type s) const { return m_dual_volume_[node_id(s)]; }$/;"	f	struct:simpla::mesh::Mesh
dual_volume	core/manifold/mesh/CylindricalCoRect.h	/^    virtual Real dual_volume(id_type s) const$/;"	f	class:simpla::mesh::CylindricalCoRect
dual_volume	core/manifold/mesh/RectMesh.h	/^    virtual Real dual_volume(id_type s) const$/;"	f	struct:simpla::mesh::Mesh
dump	core/task_flow/use_case.h	/^    virtual void dump() { }$/;"	f	class:simpla::use_case::UseCase
dx	core/manifold/mesh/CoRectMesh.h	/^    vector_type const &dx() const { return m_dx_; }$/;"	f	struct:simpla::mesh::Mesh
dx	core/manifold/mesh/MeshBlock.h	/^    vector_type const &dx() const { return m_dx_; }$/;"	f	struct:simpla::mesh::MeshBlock
dx	core/manifold/mesh/MeshIds.h	/^    static constexpr Vec3 dx()$/;"	f	struct:simpla::mesh::MeshEntityIdCoder
ebd	core/gtl/containers/sp_indirect_container.h	/^	iterator ebd()$/;"	f	struct:simpla::indirect_container
edge_boundary	core/phy_solver/em_fluid.h	/^    model::IdSet<mesh_type> edge_boundary;$/;"	m	class:simpla::phy_solver::EMFluid
edge_boundary	example/em_tokamak/tokamak.cpp	/^    model::IdSet<mesh_type> edge_boundary;$/;"	m	struct:simpla::EMTokamak	file:
ele_size_in_byte	core/data_model/DataType.cpp	/^size_t DataType::ele_size_in_byte() const$/;"	f	class:simpla::data_model::DataType
element_type	core/data_model/DataType.cpp	/^DataType DataType::element_type() const$/;"	f	class:simpla::data_model::DataType
emplac_back	core/particle/obsolete/kinetic_particle.h	/^    void emplac_back(Args &&...args)$/;"	f	struct:KineticParticle
emplac_back	core/particle/obsolete/probe_particle.h	/^    void emplac_back(Args &&...args)$/;"	f	struct:simpla::ProbeParticle
empty	applications/contexts/explicit_em.h	/^    bool empty() const$/;"	f	struct:simpla::ExplicitEMContext
empty	applications/field_solver/pml.h	/^	bool empty() const$/;"	f	class:simpla::PML
empty	core/base/Attribute.h	/^    virtual bool empty() const { return m_data_ == nullptr; }$/;"	f	class:simpla::base::Attribute
empty	core/data_model/DataSet.h	/^    virtual bool empty() const { return data == nullptr; }$/;"	f	struct:simpla::data_model::DataSet
empty	core/field/FieldDense.h	/^    bool empty() { return m_data_ == nullptr || m_data_->empty(); }$/;"	f	class:simpla::Field
empty	core/field/obsoleted/field_sparse.h	/^	bool empty() const$/;"	f	struct:simpla::Field
empty	core/field/test/trash/field_continue.h	/^	bool empty() const$/;"	f	struct:simpla::Field
empty	core/gtl/Properties.h	/^    inline bool empty() const { return any::empty() && map_type::empty(); }$/;"	f	class:simpla::Properties
empty	core/gtl/any.h	/^    virtual bool empty() const { return ptr_ == nullptr; }$/;"	f	struct:simpla::any
empty	core/gtl/array_view.h	/^    bool empty() const { return m_data_ == nullptr; };$/;"	f	class:simpla::gtl::ArrayView
empty	core/gtl/containers/container_dense.h	/^	bool empty() const$/;"	f	class:simpla::DenseContainer
empty	core/gtl/containers/sp_hash_container.h	/^	bool empty() const$/;"	f	struct:simpla::SpHashContainer
empty	core/gtl/containers/sp_ndarray.h	/^	bool empty() const$/;"	f	class:simpla::ndArray
empty	core/gtl/containers/unordered_set.h	/^    bool empty() const$/;"	f	class:simpla::UnorderedSet
empty	core/gtl/iterator/range.h	/^    bool empty() const { return m_begin_ == m_end_; };$/;"	f	class:simpla::Range
empty	core/gtl/iterator/sp_indirect_iterator.h	/^    constexpr bool empty() const$/;"	f	struct:simpla::sp_indirect_range
empty	core/gtl/iterator/sp_ntuple_range.h	/^    bool empty() const$/;"	f	struct:simpla::sp_nTuple_range
empty	core/gtl/range/block_range.h	/^    bool empty() const { return m_begin_ == m_end_; };$/;"	f	class:simpla::BlockRange
empty	core/gtl/utilities/lua_object.h	/^        bool empty() const { return m_l_ == nullptr; }$/;"	f	struct:simpla::lua::LuaObject::LuaState
empty	core/gtl/utilities/lua_object.h	/^    inline bool empty() const { return L_.empty(); }$/;"	f	class:simpla::lua::LuaObject
empty	core/io/WriteBuffer.h	/^    bool empty() const { return m_buffer_depth_ == 0; }$/;"	f	class:simpla::io::WriteBuffer
empty	core/manifold/mesh/MeshIds.h	/^        bool empty() const { return m_min_ == m_max_; }$/;"	f	struct:simpla::mesh::MeshEntityIdCoder::range_type
empty	core/model/obsoleted/model.h	/^    bool empty() const$/;"	f	class:simpla::Model
empty	core/parallel/obsoleted/blocked_range.h	/^	bool empty() const$/;"	f	struct:simpla::BlockedRange
empty	core/particle/obsolete/probe_particle.h	/^    bool empty() const$/;"	f	struct:simpla::ProbeParticle
enable_create_from_this	core/gtl/enable_create_from_this.h	/^	enable_create_from_this()$/;"	f	struct:simpla::enable_create_from_this
enable_create_from_this	core/gtl/enable_create_from_this.h	/^	enable_create_from_this(this_type & other)$/;"	f	struct:simpla::enable_create_from_this
enable_create_from_this	core/gtl/enable_create_from_this.h	/^struct enable_create_from_this: public std::enable_shared_from_this<TObject>$/;"	s	namespace:simpla
enable_if	core/gtl/utilities/lua_object.cpp	/^-> typename std::enable_if<(sizeof...(M) >= 3), bool>::type$/;"	m	class:simpla::lua::_impl::std	file:
enable_sorting	core/gtl/test/sp_iterator_test.cpp	/^	bool enable_sorting;$/;"	m	class:TestIterator	file:
enable_tracking	core/particle/ParticleTracker.h	/^    enable_tracking(Args &&...args) : P(std::forward<Args>(args)...) { }$/;"	f	class:simpla::particle::enable_tracking
enable_tracking	core/particle/ParticleTracker.h	/^class enable_tracking : public P$/;"	c	namespace:simpla::particle
end	core/gtl/array_view.h	/^    const_iterator end() const { return m_end_; }$/;"	f	class:simpla::gtl::ArrayView
end	core/gtl/containers/sp_indirect_container.h	/^	const_iterator end() const$/;"	f	struct:simpla::indirect_container
end	core/gtl/containers/unordered_set.h	/^    const_iterator end() const$/;"	f	class:simpla::UnorderedSet
end	core/gtl/containers/unordered_set.h	/^    constexpr const_local_iterator end(key_type const &id) const$/;"	f	class:simpla::UnorderedSet
end	core/gtl/containers/unordered_set.h	/^    local_iterator end(key_type const &id)$/;"	f	class:simpla::UnorderedSet
end	core/gtl/iterator/block_iterator.h	/^    this_type end() const$/;"	f	struct:simpla::block_iterator
end	core/gtl/iterator/range.h	/^    const_iterator const &end() const { return m_end_; }$/;"	f	class:simpla::Range
end	core/gtl/iterator/sp_indirect_iterator.h	/^    const_iterator end() const$/;"	f	struct:simpla::sp_indirect_range
end	core/gtl/iterator/sp_indirect_iterator.h	/^    iterator end()$/;"	f	struct:simpla::sp_indirect_range
end	core/gtl/iterator/sp_ntuple_range.h	/^    const_iterator end() const$/;"	f	struct:simpla::sp_nTuple_range
end	core/gtl/iterator/sp_range_filter.h	/^	iterator end() const$/;"	f	struct:simpla::FilterRange
end	core/gtl/iterator/sp_range_filter.h	/^	iterator end()$/;"	f	struct:simpla::FilterRange
end	core/gtl/range/block_range.h	/^    const_iterator end() const { return m_end_; }$/;"	f	class:simpla::BlockRange
end	core/gtl/utilities/lua_object.h	/^    iterator end() const { return iterator(); }$/;"	f	class:simpla::lua::LuaObject
end	core/gtl/utilities/lua_object.h	/^    iterator end() { return iterator(); }$/;"	f	class:simpla::lua::LuaObject
end	core/manifold/mesh/MeshIds.h	/^        const_iterator end() const { return const_iterator(m_min_, m_min_, m_max_, m_iform_).end(); }$/;"	f	struct:simpla::mesh::MeshEntityIdCoder::range_type
end	core/manifold/mesh/MeshIds.h	/^        iterator end() const$/;"	f	struct:simpla::mesh::MeshEntityIdCoder::iterator
end	core/parallel/obsoleted/blocked_range.h	/^	const_iterator end() const$/;"	f	struct:simpla::BlockedRange
end	core/parallel/obsoleted/blocked_range.h	/^	iterator end() const$/;"	f	struct:simpla::range
endC	core/geometry/obsolete/line_cliping.h	/^	size_t endC; \/* code for end point *\/$/;"	m	class:simpla::polygon_clip
endPt	core/geometry/obsolete/line_cliping.h	/^	pnt2d endPt; \/*end point of segment *\/$/;"	m	class:simpla::polygon_clip
end_	core/parallel/obsoleted/blocked_range.h	/^	const_iterator end_;$/;"	m	struct:simpla::BlockedRange
end_	core/parallel/obsoleted/blocked_range.h	/^	index_tuple begin_, end_;$/;"	m	struct:simpla::range
end_	core/parallel/obsoleted/blocked_range.h	/^	nTuple<index_type, ndims> self_, begin_, end_;$/;"	m	struct:simpla::iterator
end_	core/particle/obsolete/probe_particle.h	/^    size_t begin_ = 0, end_ = 0;$/;"	m	struct:simpla::ProbeParticle
endl	core/gtl/utilities/log.cpp	/^void Logger::endl()$/;"	f	class:simpla::logger::Logger
endl	core/gtl/utilities/log.h	/^inline Logger &endl(Logger &self)$/;"	f	namespace:simpla::logger
endl_	core/gtl/utilities/log.h	/^    bool endl_;$/;"	m	class:simpla::logger::Logger
engine	core/particle/Particle.h	/^    engine_type &engine() { return *std::dynamic_pointer_cast<engine_type>(m_data_); }$/;"	f	struct:simpla::particle::Particle
engine	core/particle/Particle.h	/^    engine_type const &engine() const { return *std::dynamic_pointer_cast<const engine_type>(m_data_); }$/;"	f	struct:simpla::particle::Particle
engine	core/particle/pre_define/GuidingCenter.h	/^namespace simpla { namespace particle { namespace engine$/;"	n	namespace:simpla::particle
engine	core/particle/pre_define/PICBoris.h	/^namespace simpla { namespace particle { namespace engine$/;"	n	namespace:simpla::particle
engine	core/particle/pre_define/PICGyro.h	/^namespace simpla { namespace particle { namespace engine$/;"	n	namespace:simpla::particle
engine_	core/particle/ParticleContainer.h	/^        engine_type const *engine_;$/;"	m	struct:simpla::particle::ParticleContainer::Hash
engine_type	applications/particle_solver/fluid_cold_engine.h	/^	typedef ColdFluid engine_type;$/;"	t	class:simpla::Particle
engine_type	core/particle/Particle.h	/^    typedef P engine_type;$/;"	t	struct:simpla::particle::Particle
engine_type	core/particle/ParticleContainer.h	/^    typedef ParticleEngine engine_type;$/;"	t	struct:simpla::particle::ParticleContainer
engine_type	core/particle/obsolete/kinetic_particle.h	/^    typedef Engine engine_type;$/;"	t	struct:KineticParticle
engine_type	core/particle/obsolete/probe_particle.h	/^    typedef Engine engine_type;$/;"	t	struct:simpla::ProbeParticle
engine_type	core/particle/test/kinetic_particle_test.cpp	/^	typedef SimpleParticleEngine engine_type;$/;"	t	class:TestKineticParticle	file:
engine_type	core/particle/test/kinetic_particle_test.h	/^	typedef SimpleParticleEngine engine_type;$/;"	t	class:TestKineticParticle
enroll	core/manifold/Manifold.h	/^    void enroll(std::string const &name, std::shared_ptr<TF> p)$/;"	f	class:simpla::Manifold
entity_type	core/manifold/obsoleted/amr_policy.h	/^    typedef TMesh entity_type;$/;"	t	class:simpla::manifold::policy::AMR
equal_to	core/gtl/expression_template.h	/^struct equal_to$/;"	s	namespace:simpla::_impl
erase	core/gtl/containers/UnorderedSet.h	/^UnorderedSet<ValueType, Key>::erase(TRange const &r)$/;"	f	class:simpla::gtl::UnorderedSet
erase	core/gtl/containers/UnorderedSet.h	/^UnorderedSet<ValueType, Key>::erase(typename base_type::range_type const &r)$/;"	f	class:simpla::gtl::UnorderedSet
erase	core/gtl/containers/unordered_set.h	/^    void erase(TRange const &range)$/;"	f	class:simpla::UnorderedSet
erase	core/gtl/containers/unordered_set.h	/^    void erase(key_type const &key)$/;"	f	class:simpla::UnorderedSet
erase	core/model/obsoleted/model.h	/^    void erase(TR const &r)$/;"	f	class:simpla::Model
erase	core/particle/ParticleContainer.h	/^    void erase(id_type const &s) { container_type::erase(s); }$/;"	f	struct:simpla::particle::ParticleContainer
erase	core/particle/ParticleContainer.h	/^ParticleContainer<V, K>::erase(TRange const &r0)$/;"	f	class:simpla::particle::ParticleContainer
erase	core/particle/ParticleContainer.h	/^ParticleContainer<V, K>::erase(typename container_type::range_type const &r)$/;"	f	class:simpla::particle::ParticleContainer
erase_all	core/gtl/containers/UnorderedSet.h	/^    void erase_all() { base_type::clear(); }$/;"	f	class:simpla::gtl::UnorderedSet
erase_all	core/gtl/containers/unordered_set.h	/^    void erase_all()$/;"	f	class:simpla::UnorderedSet
erase_all	core/particle/ParticleContainer.h	/^    void erase_all() { container_type::clear(); }$/;"	f	struct:simpla::particle::ParticleContainer
erase_if	core/gtl/containers/unordered_set.h	/^    void erase_if(TFun const &fun, key_type hint = 0)$/;"	f	class:simpla::UnorderedSet
erase_patch	core/field/obsoleted/field_patch.h	/^    virtual void erase_patch(size_t id)$/;"	f	class:simpla::FieldAMRPolicy
erase_patch	core/manifold/obsoleted/patch/mesh_patch.h	/^MeshPatch<TM>::erase_patch(size_t id)$/;"	f	class:simpla::mesh::MeshPatch
error	core/field/test/field_diff_calculus_test.h	/^    Real error;$/;"	m	class:FETLTest
eval	core/gtl/expression_template.h	/^    -> decltype(_identify::eval(traits::index(l, s))) { return _identify::eval(traits::index(l, s)); }$/;"	f	struct:simpla::_impl::_identify
eval	core/gtl/expression_template.h	/^    -> decltype(_pow2::eval(traits::index(l, s))) { return _identify::eval(traits::index(l, s)); }$/;"	f	struct:simpla::_impl::_identify
eval	core/gtl/expression_template.h	/^    -> decltype(_pow2::eval(traits::index(l, s))) { return _pow2(traits::index(l, s)); }$/;"	f	struct:simpla::_impl::_pow2
eval	core/gtl/expression_template.h	/^    -> decltype(_pow2::eval(traits::index(l, s))) { return _pow2::eval(traits::index(l, s)); }$/;"	f	struct:simpla::_impl::_pow2
eval	core/gtl/expression_template.h	/^    static constexpr TL const &eval(TL const &l) { return l; }$/;"	f	struct:simpla::_impl::_identify
eval	core/gtl/integer_sequence.h	/^    static inline void eval(TOP const &op, Args &&... args)$/;"	f	struct:simpla::mpl::_seq_for
eval	core/gtl/integer_sequence.h	/^    static inline void eval(TOP const &op, integer_sequence<size_t, L...>,$/;"	f	struct:simpla::mpl::_seq_for
eval	core/gtl/ntuple.h	/^    static bool eval(T0 const &b, T1 const &e, T2 const &x)$/;"	f	struct:simpla::_impl::value_in_range
eval	core/gtl/ntuple_ext.h	/^    static nTuple<T, N> eval(std::string const &s)$/;"	f	struct:simpla::traits::type_cast
eval	core/gtl/ntuple_ext.h	/^    static std::string eval(nTuple<T, N> const &v)$/;"	f	struct:simpla::traits::type_cast
eval	core/gtl/type_cast.h	/^	static T eval(std::string const &s)$/;"	f	struct:simpla::traits::type_cast
eval	core/gtl/type_cast.h	/^	static TSrc const& eval(TSrc const &v)$/;"	f	struct:simpla::traits::type_cast
eval	core/gtl/type_cast.h	/^	static constexpr TDesc eval(TSrc const &v)$/;"	f	struct:simpla::traits::type_cast
eval	core/gtl/type_cast.h	/^	static std::string const & eval(std::string const &v)$/;"	f	class:simpla::traits::type_cast::std
eval	core/gtl/type_cast.h	/^	static std::string eval(TSrc const &v)$/;"	f	struct:simpla::traits::type_cast
eval	core/gtl/utilities/lua_object.h	/^    static constexpr TDest eval(lua::LuaObject const &v)$/;"	f	struct:simpla::traits::type_cast
excute	core/field/FieldExpression.h	/^    void excute()$/;"	f	struct:simpla::Field
execute	core/gtl/design_pattern/visitor.h	/^    inline void execute(TFUN const &f)$/;"	f	struct:simpla::Visitor
expired	core/gtl/design_pattern/signal.h	/^        bool expired() const$/;"	f	struct:simpla::Signal::Slot::Tracker
expression_type	core/field/FieldExpression.h	/^    typedef AssignmentExpression<TOP, TL, TR> expression_type;$/;"	t	struct:simpla::Field
extent	core/base/Attribute.h	/^    virtual int extent(int i) const { return 1; }$/;"	f	class:simpla::base::AttributeObject
extent	core/base/Attribute.h	/^    virtual int extent(int i) const { return traits::seq_value<typename traits::extents<TV>::type>::value[i]; }$/;"	f	class:simpla::base::Attribute
extent	core/data_model/DataType.cpp	/^size_t DataType::extent(int n) const$/;"	f	class:simpla::data_model::DataType
extent	core/data_model/DataType.cpp	/^void DataType::extent(int rank, size_t const *d)$/;"	f	class:simpla::data_model::DataType
extent	core/data_model/DataType.cpp	/^void DataType::extent(size_t *d) const$/;"	f	class:simpla::data_model::DataType
extent	core/field/FieldTraits.h	/^struct extent<Field<T ...>, M> : public std::integral_constant<int,$/;"	s	namespace:simpla::traits
extent	core/gtl/ntuple.h	/^struct extent<nTuple<TV, M...>, N> : public mpl::unpack_int_seq<N, int, M...>::type$/;"	s	namespace:simpla::traits
extent	core/gtl/type_traits.h	/^struct extent : public std::integral_constant<int, std::extent<T, N>::value>$/;"	s	namespace:simpla::traits
extent	core/gtl/type_traits.h	/^struct extent<integer_sequence<_Tp, N...>, 0>$/;"	s	namespace:simpla::traits
extent_box	core/geometry/GeoAlgorithm.h	/^void extent_box(nTuple<TS, N> *x0, nTuple<TS, N> *x1, T1 const &y0, Others &&...others)$/;"	f	namespace:simpla::geometry
extent_box	core/geometry/GeoAlgorithm.h	/^void extent_box(nTuple<TS, N> *x0, nTuple<TS, N> *x1, TOther const &x)$/;"	f	namespace:simpla::geometry
extent_flag_bit	core/manifold/mesh/MeshIds.h	/^    static constexpr id_type extent_flag_bit(id_type const &s, int n = ID_DIGITS - 2)$/;"	f	struct:simpla::mesh::MeshEntityIdCoder
extents	applications/field_solver/pml.h	/^void PML<TM>::extents(coordinate_tuple xmin, coordinate_tuple xmax)$/;"	f	class:simpla::PML
extents	core/data_model/DataType.cpp	/^std::vector<size_t> const &DataType::extents() const$/;"	f	class:simpla::data_model::std::DataType
extents	core/gtl/ntuple.h	/^    typedef integer_sequence<int> extents;$/;"	t	struct:simpla::nTuple
extents	core/gtl/ntuple.h	/^struct extents<nTuple<BooleanExpression<TOP, T...> > > : public traits::extents_t<$/;"	s	namespace:simpla::traits
extents	core/gtl/ntuple.h	/^struct extents<nTuple<Expression<TOP, T...> > > : public _impl::extents_helper<$/;"	s	namespace:simpla::traits
extents	core/gtl/ntuple.h	/^struct extents<nTuple<TV, M...> > : public simpla::traits::seq_concat<$/;"	s	namespace:simpla::traits
extents	core/gtl/test/ntuple_reduce_test.cpp	/^	typedef traits::extents_t<type> extents;$/;"	t	class:TestNtupleReduce	file:
extents	core/gtl/type_traits.h	/^struct extents : public integer_sequence<int>$/;"	s	namespace:simpla::traits
extents	core/gtl/type_traits.h	/^struct extents<T[N]> : public simpla::traits::seq_concat<$/;"	s	namespace:simpla::traits
extents	core/numeric/interpolation.h	/^    inline std::tuple<nTuple < Real, NDIMS>, nTuple <Real, NDIMS>> extents() const$/;"	f	class:simpla::BiLinearInterpolation
extents	core/numeric/interpolation.h	/^    inline void extents(nTuple <Real, NDIMS> const &xmin,$/;"	f	class:simpla::BiLinearInterpolation
extents_helper	core/gtl/ntuple.h	/^struct extents_helper<TOP, First, Others...>$/;"	s	namespace:simpla::traits::_impl
extents_helper	core/gtl/ntuple.h	/^struct extents_helper<TOP, integer_sequence<_Tp, N...>, integer_sequence<_Tp> >$/;"	s	namespace:simpla::traits::_impl
extents_helper	core/gtl/ntuple.h	/^struct extents_helper<TOP, integer_sequence<_Tp, N...>,$/;"	s	namespace:simpla::traits::_impl
extents_helper	core/gtl/ntuple.h	/^struct extents_helper<TOP, integer_sequence<_Tp>, integer_sequence<_Tp, N...> >$/;"	s	namespace:simpla::traits::_impl
extents_helper	core/gtl/ntuple.h	/^struct extents_helper<TOP, integer_sequence<_Tp>, integer_sequence<_Tp> >$/;"	s	namespace:simpla::traits::_impl
extents_helper	core/gtl/ntuple.h	/^struct extents_helper<TOP>$/;"	s	namespace:simpla::traits::_impl
exterior_ring	core/geometry/boost_gemetry_adapted.h	/^struct exterior_ring<sgm::Polygon<CS>>$/;"	s	namespace:boost::geometry::traits
f	applications/fokker_planck/lhw.cpp	/^		Real f;$/;"	m	struct:PICDeltaF::Point_s	file:
f	applications/particle_solver/pic_engine_deltaf2.h	/^		Real f;$/;"	m	struct:simpla::PICEngineDeltaF::Point_s
f	applications/particle_solver/pic_engine_fullf.h	/^		scalar_type f;$/;"	m	struct:simpla::PICEngineFullF::Point_s
f	applications/particle_solver/pic_engine_ggauge.h	/^		Real f;$/;"	m	struct:simpla::PICEngineGGauge::Point_s
f	applications/particle_solver/pic_engine_implicit.h	/^		Real f;$/;"	m	struct:simpla::PICEngineImplicit::Point_s
f1	example/probe_particle/draw.py	/^f1=H5.File("0016.h5")$/;"	v
f1	scripts/PostProcesse/particle_time_scripts.py	/^f1=h5.File("\/pkg\/clion\/etc\/clion\/system\/cmake\/generated\/2774870a\/2774870a\/Debug\/example\/em\/tokamak.h5")$/;"	v
f1	scripts/PostProcesse/pv_prog_source.py	/^f1=h5.File("\/pkg\/etc\/clion\/system\/cmake\/generated\/2774870a\/2774870a\/Debug\/example\/em\/tokamak0007.h5")$/;"	v
f1	scripts/animation.py	/^f1=H5.File("data_dump\/geqdsk0027.h5","r")$/;"	v
f_	core/gtl/cache.h	/^	T & f_;$/;"	m	struct:simpla::Cache
f_	core/gtl/cache.h	/^	T * f_;$/;"	m	struct:simpla::Cache
f_	core/gtl/cache.h	/^	T const & f_;$/;"	m	struct:simpla::Cache
f_	core/gtl/containers/container_cache.h	/^	T & f_;$/;"	m	struct:simpla::CacheContainer
f_	core/gtl/containers/container_cache.h	/^	T * f_;$/;"	m	struct:simpla::CacheContainer
f_	core/gtl/containers/container_cache.h	/^	T const & f_;$/;"	m	struct:simpla::CacheContainer
f_type	core/field/test/trash/field_cartesian_map_test.cpp	/^typedef Field<mesh_type, container_type> f_type;$/;"	t	file:
face_boundary	core/phy_solver/em_fluid.h	/^    model::IdSet<mesh_type> face_boundary;$/;"	m	class:simpla::phy_solver::EMFluid
face_boundary	example/em_tokamak/tokamak.cpp	/^    model::IdSet<mesh_type> face_boundary;$/;"	m	struct:simpla::EMTokamak	file:
facet	core/geometry/cube.h	/^struct facet<model::Primitive<1, CS, tags::cube>>$/;"	s	namespace:simpla::geometry::traits
facet	core/geometry/cube.h	/^struct facet<model::Primitive<2, CS, tags::cube>>$/;"	s	namespace:simpla::geometry::traits
facet	core/geometry/primitive.h	/^struct facet<model::Primitive<Dimension, Others...>>$/;"	s	namespace:simpla::geometry::traits
facet	core/geometry/simplex.h	/^struct facet<model::Primitive<1, CS, tags::simplex>>$/;"	s	namespace:simpla::geometry::traits
facet	core/geometry/simplex.h	/^struct facet<model::Primitive<2, CS, tags::simplex>>$/;"	s	namespace:simpla::geometry::traits
failed	core/gtl/utilities/log.h	/^inline Logger &failed(Logger &self)$/;"	f	namespace:simpla::logger
field_type	core/field/obsoleted/field_patch.h	/^    typedef TF field_type;$/;"	t	class:simpla::FieldAMRPolicy
field_type	core/field/test/field_basic_algebra_test.h	/^    typedef TField field_type;$/;"	t	class:TestField
field_type	core/field/test/trash/fetl_test2.h	/^	typedef Field<domain_type, value_type> field_type;$/;"	t	class:TestField
field_type	core/field/test/trash/field_basic_test.h	/^	typedef typename TFieldParam::field_type field_type;$/;"	t	class:TestField
field_type	core/field/test/trash/field_simple_mesh_shared_ptr_test.cpp	/^	typedef TField field_type;$/;"	t	struct:TestFieldParam	file:
field_type	core/field/test/trash/field_simple_mesh_shared_ptr_test.cpp	/^typedef Field<SimpleMesh, std::shared_ptr<double>> field_type;$/;"	t	file:
field_value_type	core/field/FieldDense.h	/^    typedef typename traits::field_value_type<this_type>::type field_value_type;$/;"	t	class:simpla::Field
field_value_type	core/field/FieldExpression.h	/^struct field_value_type<Field<BooleanExpression<TOP, T...> > >$/;"	s	namespace:simpla::traits
field_value_type	core/field/FieldFunction.h	/^    typedef typename traits::field_value_type<this_type>::type field_value_type;$/;"	t	class:simpla::Field
field_value_type	core/field/FieldTraits.h	/^struct field_value_type$/;"	s	namespace:simpla::traits
field_value_type	core/field/obsoleted/field_sparse.h	/^	typedef typename mesh_type::template field_value_type<value_type> field_value_type;$/;"	t	struct:simpla::Field
field_value_type	core/field/test/trash/field_continue.h	/^	typedef typename mesh_type::template field_value_type<value_type> field_value_type;$/;"	t	struct:simpla::Field
fig	scripts/animation.py	/^fig=figure()$/;"	v
fill	core/gtl/containers/container_dense.h	/^	void fill(value_type v)$/;"	f	class:simpla::DenseContainer
fill	core/gtl/containers/container_sparse.h	/^    void fill(value_type v)$/;"	f	class:simpla::SparseContainer
fill	core/gtl/containers/sp_hash_container.h	/^	void fill(value_type const & v)$/;"	f	struct:simpla::SpHashContainer
fill	core/gtl/containers/sp_ndarray.h	/^	void fill(value_type const & v)$/;"	f	class:simpla::ndArray
filter	core/gtl/containers/UnorderedSet.h	/^    void filter(std::tuple<TFun, TRange> const &f) const { filter(std::get<0>(f), std::get<1>(f)); }$/;"	f	class:simpla::gtl::UnorderedSet
filter	core/gtl/containers/UnorderedSet.h	/^    void filter(std::tuple<TFun, TRange> const &f) { filter(std::get<0>(f), std::get<1>(f)); }$/;"	f	class:simpla::gtl::UnorderedSet
filter	core/gtl/containers/UnorderedSet.h	/^UnorderedSet<ValueType, Key>::filter(TFun const &fun) const$/;"	f	class:simpla::gtl::UnorderedSet
filter	core/gtl/containers/UnorderedSet.h	/^UnorderedSet<ValueType, Key>::filter(TFun const &fun)$/;"	f	class:simpla::gtl::UnorderedSet
filter	core/gtl/containers/UnorderedSet.h	/^UnorderedSet<ValueType, Key>::filter(TFun const &fun, TRange const &r0) const$/;"	f	class:simpla::gtl::UnorderedSet
filter	core/gtl/containers/UnorderedSet.h	/^UnorderedSet<ValueType, Key>::filter(TFun const &fun, TRange const &r0)$/;"	f	class:simpla::gtl::UnorderedSet
filter	core/gtl/containers/UnorderedSet.h	/^UnorderedSet<ValueType, Key>::filter(TFun const &fun, key_type const &s) const$/;"	f	class:simpla::gtl::UnorderedSet
filter	core/gtl/containers/UnorderedSet.h	/^UnorderedSet<ValueType, Key>::filter(TFun const &fun, key_type const &s)$/;"	f	class:simpla::gtl::UnorderedSet
filter	core/gtl/containers/UnorderedSet.h	/^UnorderedSet<ValueType, Key>::filter(TFun const &fun, typename base_type::value_type const &item) const$/;"	f	class:simpla::gtl::UnorderedSet
filter	core/gtl/containers/UnorderedSet.h	/^UnorderedSet<ValueType, Key>::filter(TFun const &fun, typename base_type::value_type const &item)$/;"	f	class:simpla::gtl::UnorderedSet
filter	core/gtl/iterator/sp_iterator_filter.h	/^	void filter()$/;"	f	struct:simpla::sp_fliter_iterator
filter	core/particle/ParticleContainer.h	/^ParticleContainer<V, K>::filter(TFun const &fun) const { filter(fun, container_type::range()); };$/;"	f	class:simpla::particle::ParticleContainer
filter	core/particle/ParticleContainer.h	/^ParticleContainer<V, K>::filter(TFun const &fun) { filter(fun, container_type::range()); };$/;"	f	class:simpla::particle::ParticleContainer
filter	core/particle/ParticleContainer.h	/^ParticleContainer<V, K>::filter(TFun const &fun, TRange const &r0) const$/;"	f	class:simpla::particle::ParticleContainer
filter	core/particle/ParticleContainer.h	/^ParticleContainer<V, K>::filter(TFun const &fun, TRange const &r0)$/;"	f	class:simpla::particle::ParticleContainer
filter	core/particle/ParticleContainer.h	/^ParticleContainer<V, K>::filter(TFun const &fun, id_type const &s) const$/;"	f	class:simpla::particle::ParticleContainer
filter	core/particle/ParticleContainer.h	/^ParticleContainer<V, K>::filter(TFun const &fun, id_type const &s)$/;"	f	class:simpla::particle::ParticleContainer
filter	core/particle/ParticleContainer.h	/^ParticleContainer<V, K>::filter(TFun const &fun, typename container_type::value_type &item)$/;"	f	class:simpla::particle::ParticleContainer
filter	core/particle/ParticleContainer.h	/^ParticleContainer<V, K>::filter(TFun const &fun, typename container_type::value_type const &item) const$/;"	f	class:simpla::particle::ParticleContainer
filter_by_config	core/geometry/select.h	/^void filter_by_config(TDict const & dict, TDomain * domain)$/;"	f	namespace:simpla
filter_by_config	core/model/obsoleted/select.h	/^void filter_by_config(TDict const & dict, TDomain * domain)$/;"	f	namespace:simpla
filter_reverse	core/gtl/iterator/sp_iterator_filter.h	/^	void filter_reverse()$/;"	f	struct:simpla::sp_fliter_iterator
find	core/gtl/containers/unordered_set.h	/^    iterator find(key_type const &key)$/;"	f	class:simpla::UnorderedSet
find	core/numeric/interpolation.h	/^    inline iterator find(key_x_type const &x) const$/;"	f	class:simpla::Interpolation
find_option_from_cmd_line	core/gtl/utilities/parse_command_line.cpp	/^std::tuple<bool, std::string> find_option_from_cmd_line(int argc, char ** argv,$/;"	f	namespace:simpla
find_root	core/numeric/find_root.h	/^bool find_root(std::function<TY(TX const &)> const &f, TY const &y_m, TX x0, TX *xio,$/;"	f	namespace:simpla
find_root	core/numeric/find_root.h	/^bool find_root(std::function<bool(TX const &)> const &f, TX x0, TX *xio, double resolution = 0.001,$/;"	f	namespace:simpla
find_same	core/gtl/utilities/misc_utilities.h	/^bool find_same(T const & left)$/;"	f	namespace:simpla
find_same	core/gtl/utilities/misc_utilities.h	/^bool find_same(T const & left, T const & first, Others && ... others)$/;"	f	namespace:simpla
find_type_in_list	core/gtl/mpl.h	/^struct find_type_in_list<T, U, Others...>$/;"	s	namespace:simpla::mpl
find_type_in_list	core/gtl/mpl.h	/^struct find_type_in_list<T, U>$/;"	s	namespace:simpla::mpl
find_type_in_list	core/gtl/mpl.h	/^struct find_type_in_list<T>$/;"	s	namespace:simpla::mpl
fix_to_bound	core/geometry/obsolete/surface.h	/^	void fix_to_bound()$/;"	f	class:simpla::Surface
fluid_s	core/phy_solver/em_fluid.h	/^    struct fluid_s$/;"	s	class:simpla::phy_solver::EMFluid
fluid_s	example/em_tokamak/tokamak.cpp	/^    struct fluid_s$/;"	s	struct:simpla::EMTokamak	file:
fluid_sp	core/phy_solver/em_fluid.h	/^    std::map<std::string, fluid_s> fluid_sp;$/;"	m	class:simpla::phy_solver::EMFluid
fluid_sp	example/em_tokamak/tokamak.cpp	/^    std::map<std::string, fluid_s> fluid_sp;$/;"	m	struct:simpla::EMTokamak	file:
flush	core/gtl/containers/container_save_cache.h	/^	std::string flush()$/;"	f	class:simpla::ContainerSaveCache
flush	core/gtl/utilities/log.cpp	/^void Logger::flush()$/;"	f	class:simpla::logger::Logger
flush	core/gtl/utilities/log.h	/^inline Logger &flush(Logger &self)$/;"	f	namespace:simpla::logger
flush	core/io/HDF5Stream.cpp	/^void HDF5Stream::flush()$/;"	f	class:simpla::io::HDF5Stream
flush	core/io/WriteBuffer.cpp	/^void WriteBuffer::flush() { write(true); }$/;"	f	class:simpla::io::WriteBuffer
following	core/gtl/mpl.h	/^	typedef std::tuple<> following;$/;"	t	struct:simpla::mpl::split_tuple
following	core/gtl/mpl.h	/^	typedef std::tuple<T0, T...> following;$/;"	t	struct:simpla::mpl::split_tuple
following	core/gtl/mpl.h	/^	typedef typename split_tuple<I - 1, T...>::following following;$/;"	t	struct:simpla::mpl::split_tuple
foo	example/misc/demo_misc.cpp	/^	int foo(int a)$/;"	f	struct:U
foo	example/misc/demo_misc.cpp	/^	int foo(int a)$/;"	f	struct:W
for_each	core/gtl/containers/unordered_set.h	/^    void for_each(TFun const &fun)$/;"	f	class:simpla::UnorderedSet
for_each	core/gtl/ntuple.h	/^void for_each(TOP const &op, integer_sequence<int, N, M...>,$/;"	f	namespace:simpla
for_each	core/gtl/ntuple.h	/^void for_each(TOP const &op, integer_sequence<int>, Args &&... args)$/;"	f	namespace:simpla
for_each	core/manifold/policy/ParallelPolicy.h	/^void  ParallelPolicy<TMesh>::for_each(Func const &fun) const$/;"	f	class:simpla::manifold::policy::ParallelPolicy
for_each_boundary	core/manifold/policy/ParallelPolicy.h	/^void  ParallelPolicy<TMesh>::for_each_boundary(Func const &fun) const$/;"	f	class:simpla::manifold::policy::ParallelPolicy
for_each_center	core/manifold/policy/ParallelPolicy.h	/^void  ParallelPolicy<TMesh>::for_each_center(Func const &fun) const$/;"	f	class:simpla::manifold::policy::ParallelPolicy
for_each_ghost	core/manifold/policy/ParallelPolicy.h	/^void  ParallelPolicy<TMesh>::for_each_ghost(Func const &fun) const$/;"	f	class:simpla::manifold::policy::ParallelPolicy
for_each_value	core/manifold/policy/ParallelPolicy.h	/^void  ParallelPolicy<TMesh>::for_each_value(TF &f, TRange const &r0, Func const &fun) const$/;"	f	class:simpla::manifold::policy::ParallelPolicy
foreach	core/particle/obsolete/kinetic_particle.h	/^void KineticParticle<Engine, TDomain>::foreach(TFun const &fun,$/;"	f	class:KineticParticle
foreach	core/particle/obsolete/probe_particle.h	/^void ProbeParticle<Engine>::foreach(TFun const &fun, Args &&... args)$/;"	f	class:simpla::ProbeParticle
foreach_bucket	core/particle/ParticleContainer.h	/^    void foreach_bucket(TFun const &fun, TRange const &r0)$/;"	f	struct:simpla::particle::ParticleContainer
foreach_bucket	core/particle/ParticleContainer.h	/^    void foreach_bucket(TFun const &fun, id_type const &s)$/;"	f	struct:simpla::particle::ParticleContainer
from	core/gtl/utilities/lua_object.cpp	/^Converter<Properties>::from(lua_State *L, unsigned int idx, Properties *v)$/;"	f	class:simpla::lua::Converter
from	core/gtl/utilities/lua_object_ext.h	/^    static inline unsigned int from(lua_State *L, unsigned int idx, value_type *v)$/;"	f	struct:simpla::lua::Converter
from_	core/gtl/utilities/lua_object_ext.h	/^    static inline unsigned int from_(lua_State *L, unsigned int idx, value_type *v,$/;"	f	struct:simpla::lua::Converter
from_	core/gtl/utilities/lua_object_ext.h	/^    static inline unsigned int from_(lua_State *L,$/;"	f	struct:simpla::lua::Converter
fs	core/gtl/utilities/log.cpp	/^    std::ofstream fs;$/;"	m	struct:simpla::logger::LoggerStreams	file:
function_type	core/geometry/implicit_function.h	/^	typedef TF function_type;$/;"	t	class:simpla::ImplicitFunction
function_type	core/gtl/function_cache.h	/^	typedef TFun function_type;$/;"	t	struct:simpla::FunctionCache
function_value	core/particle/test/particle_generator_test.cpp	/^    Real function_value(sample_type const &p) const { return p.f * p.w; }$/;"	f	struct:simpla::PICDemo
gather	core/field/FieldDense.h	/^    field_value_type gather(Args &&...args) const$/;"	f	class:simpla::Field
gather	core/field/obsoleted/field_sparse.h	/^	field_value_type gather(coordinate_tuple const& x) const$/;"	f	struct:simpla::Field
gather	core/field/test/trash/field_continue.h	/^	field_value_type gather(coordinate_tuple const& x) const$/;"	f	struct:simpla::Field
gather	core/particle/Particle.h	/^Particle<P, M>::gather(TField *J) const$/;"	f	class:simpla::particle::Particle
gather	core/particle/Particle.h	/^Particle<P, M>::gather(TField *J, TRange const &r0) const$/;"	f	class:simpla::particle::Particle
gen_seq	core/gtl/type_traits.h	/^struct gen_seq$/;"	s	namespace:simpla::_impl
gen_seq	core/gtl/type_traits.h	/^struct gen_seq<TP, 0UL>$/;"	s	namespace:simpla::_impl
generate	core/particle/Particle.h	/^Particle<P, M>::generate(TGen &gen)$/;"	f	class:simpla::particle::Particle
generate	core/particle/Particle.h	/^Particle<P, M>::generate(TGen &gen, const TRange &r0)$/;"	f	class:simpla::particle::Particle
generate	core/particle/Particle.h	/^Particle<P, M>::generate(TGen &gen, id_type s)$/;"	f	class:simpla::particle::Particle
generate	core/particle/ParticleGenerator.h	/^    generate(size_t num, TFunc const &func)$/;"	f	struct:simpla::particle::ParticleGenerator
generate_object_id	core/parallel/MPIComm.cpp	/^int MPIComm::generate_object_id()$/;"	f	class:simpla::parallel::MPIComm
generator	core/parallel/ParallelRandomGenerator.h	/^    generator(size_t num) \/\/ thread safe$/;"	f	struct:simpla::parallel::DistributedCounter
geo	core/field/test/trash/field_cartesian_map_test.cpp	/^auto geo = CartesianCoordinate<RectMesh, CARTESIAN_ZAXIS>::create($/;"	v
geo	core/geometry/primitive.h	/^    typedef model::Primitive<Dimension, CoordinateSystem, Tag> geo;$/;"	t	struct:simpla::geometry::traits::value_type
geometry	core/geometry/CoordinateSystem.h	/^namespace simpla { namespace geometry$/;"	n	namespace:simpla
geometry	core/geometry/GeoAlgorithm.h	/^namespace geometry$/;"	n	namespace:simpla
geometry	core/geometry/GeoObject.h	/^namespace simpla { namespace geometry$/;"	n	namespace:simpla
geometry	core/geometry/algorithm.h	/^namespace geometry {$/;"	n	namespace:simpla
geometry	core/geometry/boost_gemetry_adapted.h	/^namespace geometry$/;"	n	namespace:boost
geometry	core/geometry/boost_gemetry_adapted.h	/^namespace geometry$/;"	n	namespace:simpla
geometry	core/geometry/box.h	/^namespace geometry$/;"	n	namespace:simpla
geometry	core/geometry/chains.h	/^namespace geometry {$/;"	n	namespace:simpla
geometry	core/geometry/csCartesian.h	/^namespace simpla { namespace geometry$/;"	n	namespace:simpla
geometry	core/geometry/csCylindrical.h	/^namespace geometry$/;"	n	namespace:simpla
geometry	core/geometry/cube.h	/^namespace geometry$/;"	n	namespace:simpla
geometry	core/geometry/geometry.h	/^namespace simpla { namespace geometry$/;"	n	namespace:simpla
geometry	core/geometry/model.h	/^namespace geometry$/;"	n	namespace:simpla
geometry	core/geometry/polygon.cpp	/^namespace simpla { namespace geometry$/;"	n	namespace:simpla	file:
geometry	core/geometry/polygon.h	/^namespace simpla { namespace geometry$/;"	n	namespace:simpla
geometry	core/geometry/primitive.h	/^namespace simpla { namespace geometry$/;"	n	namespace:simpla
geometry	core/geometry/primitive_ext.h	/^namespace simpla { namespace geometry$/;"	n	namespace:simpla
geometry	core/geometry/simplex.h	/^namespace geometry$/;"	n	namespace:simpla
geometry	core/manifold/ManifoldTraits.h	/^namespace geometry$/;"	n	namespace:simpla
geometry	core/manifold/mesh/Mesh.h	/^namespace simpla { namespace geometry { namespace traits$/;"	n	namespace:simpla
geometry_object	core/geometry/obsolete/geometry_object.h	/^namespace geometry_object$/;"	n	namespace:simpla
geometry_type	core/manifold/ManifoldTraits.h	/^template<typename T> struct geometry_type$/;"	s	namespace:simpla::traits
geometry_type	core/manifold/obsoleted/embedded_policy.h	/^    typedef TGeo geometry_type;$/;"	t	struct:simpla::manifold::policy::EmbeddedPolicy
geometry_type	core/manifold/obsoleted/time_integrator_policy.h	/^    typedef TGeo geometry_type;$/;"	t	struct:simpla::manifold::policy::TimeIntegrator
geometry_type	core/manifold/policy/IOPolicy.h	/^    typedef TGeo geometry_type;$/;"	t	struct:simpla::manifold::policy::IOPolicy
geometry_type	core/manifold/policy/StoragePolicy.h	/^    typedef TGeo geometry_type;$/;"	t	struct:simpla::manifold::policy::StoragePolicy
get	core/geometry/boost_gemetry_adapted.h	/^	static inline typename polygon_type::inner_container_type const& get($/;"	f	class:boost::geometry::traits::interior_rings::polygon_type
get	core/geometry/boost_gemetry_adapted.h	/^	static inline typename polygon_type::inner_container_type& get($/;"	f	struct:boost::geometry::traits::interior_rings
get	core/geometry/boost_gemetry_adapted.h	/^	static inline typename polygon_type::ring_type const& get($/;"	f	class:boost::geometry::traits::exterior_ring::polygon_type
get	core/geometry/boost_gemetry_adapted.h	/^	static inline typename polygon_type::ring_type& get(polygon_type& p)$/;"	f	struct:boost::geometry::traits::exterior_ring
get	core/geometry/boost_gemetry_adapted.h	/^	static inline value_type const & get(sgm::Primitive<N, CS, TAG> const& b)$/;"	f	struct:boost::geometry::traits::indexed_access
get	core/geometry/boost_gemetry_adapted.h	/^	static inline value_type const &get(sgm::Primitive<N, CS, TAG>const& point)$/;"	f	struct:boost::geometry::traits::access
get	core/gtl/Properties.h	/^    Properties &get(std::string const &key)$/;"	f	class:simpla::Properties
get	core/gtl/Properties.h	/^    Properties const &get(std::string const &key) const$/;"	f	class:simpla::Properties
get	core/gtl/Properties.h	/^    T get(std::string const &key, T const &default_v) const$/;"	f	class:simpla::Properties
get	core/gtl/Properties.h	/^    bool get(std::string const &key, T *v) const$/;"	f	class:simpla::Properties
get	core/gtl/any.h	/^    template<class U> U &get()$/;"	f	struct:simpla::any
get	core/gtl/any.h	/^    template<class U> U const &get() const$/;"	f	struct:simpla::any
get	core/gtl/any.h	/^    virtual std::shared_ptr<Base> get(int n) const { return _index_of(m_value, n); }$/;"	f	struct:simpla::Derived
get	core/gtl/array_view.h	/^    T &get(size_t *const idx)$/;"	f	struct:simpla::gtl::ArrayViewBase
get	core/gtl/array_view.h	/^    T const &get(size_t *const idx) const$/;"	f	struct:simpla::gtl::ArrayViewBase
get	core/gtl/array_view.h	/^    value_type &get(Args &&...args)$/;"	f	class:simpla::gtl::ArrayView
get	core/gtl/array_view.h	/^    value_type const &get(Args &&...args) const$/;"	f	class:simpla::gtl::ArrayView
get	core/gtl/containers/container_container.h	/^	inline value_type & get(key_type s)$/;"	f	class:simpla::ContainerContainer
get	core/gtl/containers/container_container.h	/^	inline value_type const & get(key_type s) const$/;"	f	class:simpla::ContainerContainer
get	core/gtl/containers/container_dense.h	/^	inline value_type & get(key_type s)$/;"	f	class:simpla::DenseContainer
get	core/gtl/containers/container_dense.h	/^	inline value_type const & get(key_type s) const$/;"	f	class:simpla::DenseContainer
get	core/gtl/containers/container_sparse.h	/^    inline value_type &get(key_type s)$/;"	f	class:simpla::SparseContainer
get	core/gtl/containers/container_sparse.h	/^    inline value_type const &get(key_type s) const$/;"	f	class:simpla::SparseContainer
get	core/gtl/iterator/sp_iterator.h	/^	value_type * get() const$/;"	f	class:simpla::sp_back_insert_iterator
get	core/gtl/iterator/sp_iterator_mapped.h	/^	const_reference get(std::false_type) const$/;"	f	struct:simpla::Iterator
get	core/gtl/iterator/sp_iterator_mapped.h	/^	const_reference get(std::true_type) const$/;"	f	struct:simpla::Iterator
get	core/gtl/iterator/sp_iterator_mapped.h	/^	reference get(std::false_type)$/;"	f	struct:simpla::Iterator
get	core/gtl/iterator/sp_iterator_mapped.h	/^	reference get(std::true_type)$/;"	f	struct:simpla::Iterator
get	core/gtl/iterator/sp_iterator_shared_container.h	/^	const reference get() const$/;"	f	class:simpla::TransformIterator
get	core/gtl/iterator/sp_iterator_shared_container.h	/^	const reference get(TI const& it) const$/;"	f	struct:simpla::_impl::StorageSharedContainer
get	core/gtl/iterator/sp_iterator_shared_container.h	/^	const reference get(size_t it) const$/;"	f	struct:simpla::_impl::StorageSharedContainer
get	core/gtl/iterator/sp_iterator_shared_container.h	/^	reference get()$/;"	f	class:simpla::TransformIterator
get	core/gtl/iterator/sp_iterator_shared_container.h	/^	reference get(TI const& it)$/;"	f	struct:simpla::_impl::StorageSharedContainer
get	core/gtl/iterator/sp_iterator_shared_container.h	/^	static const reference get(this_type const* self, TI const& it)$/;"	f	struct:simpla::_impl::StorageSharedContainer
get	core/gtl/iterator/sp_iterator_shared_container.h	/^	static reference get(this_type * self, TI const& it)$/;"	f	struct:simpla::_impl::StorageSharedContainer
get	core/gtl/iterator/sp_iterator_shared_container.h	/^	static reference get(this_type const* self, TI const& it)$/;"	f	struct:simpla::_impl::StorageSharedContainer
get	core/gtl/type_traits.h	/^    static constexpr T &get(T &v)$/;"	f	struct:simpla::traits::_impl::access_helper
get	core/gtl/type_traits.h	/^    static constexpr T const &get(T const &v)$/;"	f	struct:simpla::traits::_impl::access_helper
get	core/gtl/utilities/lua_object.h	/^            std::shared_ptr<lua_s> get() const { return m_l_; }$/;"	f	struct:simpla::lua::LuaObject::LuaState::const_accessor
get	core/gtl/utilities/lua_object.h	/^            std::shared_ptr<lua_s> get() { return m_l_; }$/;"	f	struct:simpla::lua::LuaObject::LuaState::accessor
get	core/gtl/utilities/lua_object.h	/^        lua_State *get() const { return const_cast<lua_State *>(m_l_->m_state_); }$/;"	f	struct:simpla::lua::LuaObject::LuaState
get	core/gtl/utilities/lua_object.h	/^        lua_State *get() { return m_l_->m_state_; }$/;"	f	struct:simpla::lua::LuaObject::LuaState
get	core/manifold/policy/LinearInterpolatorPolicy.h	/^    std::get<1>(idx)[0])$/;"	f	class:simpla::manifold::policy::LinearInterpolator::std
get	core/model/obsoleted/model.h	/^    tag_type get(TR const &r, tag_type const &tag) const$/;"	f	class:simpla::Model
get	core/model/obsoleted/model.h	/^    tag_type get(id_type const &s) const$/;"	f	class:simpla::Model
get	core/parallel/DistributedCounter.h	/^    size_t get(size_t num) { return (m_start_ += num) - num; };$/;"	f	struct:simpla::parallel::DistributedCounter
get_	core/gtl/utilities/pretty_stream.h	/^get_(std::istream &is, size_t num, std::map<TX, TY, Others...> &a)$/;"	f	namespace:simpla
get_J	applications/particle_solver/fluid_cold_engine.h	/^	void const * get_J() const$/;"	f	class:simpla::Particle
get_MPI_Op	core/parallel/MPIAuxFunctions.cpp	/^inline MPI_Op get_MPI_Op(std::string const &op_c)$/;"	f	namespace:simpla::parallel
get_adjacent_cells	core/manifold/mesh/MeshIds.h	/^    static int get_adjacent_cells(size_t IFORM, id_type s, id_type *res = nullptr)$/;"	f	struct:simpla::mesh::MeshEntityIdCoder
get_adjacent_cells	core/manifold/mesh/MeshIds.h	/^    static int get_adjacent_cells(size_t IFORM, size_t nodeid, id_type s, id_type *res = nullptr)$/;"	f	struct:simpla::mesh::MeshEntityIdCoder
get_allocator	core/gtl/containers/container_container.h	/^	allocator_type get_allocator() const$/;"	f	class:simpla::ContainerContainer
get_attribute	core/io/HDF5Stream.cpp	/^Properties HDF5Stream::get_attribute(std::string const &url) const$/;"	f	class:simpla::io::HDF5Stream
get_attribute	core/io/HDF5Stream.cpp	/^Properties HDF5Stream::pimpl_s::get_attribute(hid_t loc_id, int idx) const$/;"	f	class:simpla::io::HDF5Stream::pimpl_s
get_attribute	core/io/HDF5Stream.cpp	/^Properties HDF5Stream::pimpl_s::get_attribute(hid_t loc_id, std::string const &name) const$/;"	f	class:simpla::io::HDF5Stream::pimpl_s
get_attribute	core/manifold/Manifold.h	/^    std::shared_ptr<Attribute<TV, IFORM>> get_attribute() const$/;"	f	class:simpla::Manifold
get_attribute	core/manifold/Manifold.h	/^    std::shared_ptr<Attribute<TV, IFORM>> get_attribute(std::string const &s_name = "")$/;"	f	class:simpla::Manifold
get_buffer_length	core/gtl/utilities/log.cpp	/^int Logger::get_buffer_length() const$/;"	f	class:simpla::logger::Logger
get_cell_in_surface	core/model/Constraint.h	/^void get_cell_in_surface(TM const &m, CellCache<TM> const &cache, IdSet<TM> *res)$/;"	f	namespace:simpla::model
get_cell_in_surface	core/model/Constraint.h	/^void get_cell_in_surface(TM const &m, TRange const &r0, CellCache<TM> const &cache, IdSet<TM> *res)$/;"	f	namespace:simpla::model
get_cell_on_surface	core/model/Constraint.h	/^void get_cell_on_surface(TM const &m, CellCache<TM> const &cache, IdSet<TM> *surface,$/;"	f	namespace:simpla::model
get_cell_on_surface	core/model/Constraint.h	/^void get_cell_on_surface(TM const &m, CellCache<TM> const &cache, Surface<TM> *surface)$/;"	f	namespace:simpla::model
get_cell_on_surface	core/model/Constraint.h	/^void get_cell_on_surface(TM const &m, TRange const &r0, CellCache<TM> const &cache, IdSet<TM> *surface,$/;"	f	namespace:simpla::model
get_cell_on_surface	core/model/Constraint.h	/^void get_cell_on_surface(TM const &m, TRange const &r0, CellCache<TM> const &cache, Surface<TM> *surface)$/;"	f	namespace:simpla::model
get_cell_on_surface	core/model/Constraint.h	/^void get_cell_on_surface(TM const &m, geometry::GeoObject const &geo, Args &&...args)$/;"	f	namespace:simpla::model
get_cell_out_surface	core/model/Constraint.h	/^void get_cell_out_surface(TM const &m, CellCache<TM> const &cache, IdSet<TM> *res)$/;"	f	namespace:simpla::model
get_cell_out_surface	core/model/Constraint.h	/^void get_cell_out_surface(TM const &m, TRange const &r0, CellCache<TM> const &cache, IdSet<TM> *res)$/;"	f	namespace:simpla::model
get_charge	applications/particle_solver/fluid_cold_engine.h	/^	Real get_charge() const$/;"	f	class:simpla::Particle
get_charge	applications/particle_solver/pic_engine_deltaf2.h	/^	Real get_charge() const$/;"	f	struct:simpla::PICEngineDeltaF
get_charge	applications/particle_solver/pic_engine_fullf.h	/^	Real get_charge() const$/;"	f	class:simpla::PICEngineFullF
get_charge	applications/particle_solver/pic_engine_ggauge.h	/^	Real get_charge() const$/;"	f	class:simpla::PICEngineGGauge
get_charge	applications/particle_solver/pic_engine_implicit.h	/^	Real get_charge() const$/;"	f	struct:simpla::PICEngineImplicit
get_child	core/gtl/utilities/lua_object.h	/^    inline LuaObject get_child(T const &key) const$/;"	f	class:simpla::lua::LuaObject
get_class_name	core/base/Attribute.h	/^    virtual std::string get_class_name() const { return "Attribute<" + mesh().get_class_name() + ">"; }$/;"	f	class:simpla::base::Attribute
get_class_name	core/base/Attribute.h	/^    virtual std::string get_class_name() const$/;"	f	class:simpla::base::AttributeEntity
get_class_name	core/base/Object.cpp	/^std::string Object::get_class_name() const { return "base::LuaObject"; }$/;"	f	class:simpla::base::Object
get_class_name	core/manifold/Manifold.h	/^    virtual std::string get_class_name() const { return "Manifold< ... >"; }$/;"	f	class:simpla::Manifold
get_element_volume_in_cell	core/manifold/mesh/MeshIds.h	/^    static void get_element_volume_in_cell(TGeometry const &geo, id_type s0, Real *v, Real *inv_v, Real *dual_v,$/;"	f	struct:simpla::mesh::MeshEntityIdCoder
get_line_width	core/gtl/utilities/log.cpp	/^    int get_line_width() const$/;"	f	struct:simpla::logger::LoggerStreams
get_line_width	core/gtl/utilities/log.cpp	/^int get_line_width()$/;"	f	namespace:simpla::logger
get_mass	applications/particle_solver/fluid_cold_engine.h	/^	Real get_mass() const$/;"	f	class:simpla::Particle
get_mass	applications/particle_solver/pic_engine_deltaf2.h	/^	Real get_mass() const$/;"	f	struct:simpla::PICEngineDeltaF
get_mass	applications/particle_solver/pic_engine_fullf.h	/^	Real get_mass() const$/;"	f	class:simpla::PICEngineFullF
get_mass	applications/particle_solver/pic_engine_ggauge.h	/^	Real get_mass() const$/;"	f	class:simpla::PICEngineGGauge
get_mass	applications/particle_solver/pic_engine_implicit.h	/^	Real get_mass() const$/;"	f	struct:simpla::PICEngineImplicit
get_material	core/model/obsoleted/model.h	/^    int get_material(std::string const &name) const$/;"	f	class:simpla::Model
get_mesh	core/base/Attribute.h	/^    mesh_type &get_mesh()$/;"	f	class:simpla::base::AttributeEntity
get_neighbour	core/parallel/MPIComm.cpp	/^int MPIComm::get_neighbour(nTuple<int, 3> const &d) const$/;"	f	class:simpla::parallel::MPIComm
get_neighbour	core/parallel/MPIComm.h	/^    int get_neighbour(TI const &d) const$/;"	f	class:simpla::parallel::MPIComm
get_num_concurrency	core/parallel/obsoleted/multi_thread_openmp.h	/^int get_num_concurrency(unsigned int num_threads_hint = 0)$/;"	f	namespace:simpla
get_number_of_elements	core/numeric/interpolation.h	/^    size_t get_number_of_elements() const$/;"	f	class:simpla::BiLinearInterpolation
get_property	applications/particle_solver/fluid_cold_engine.h	/^	template<typename T> T get_property(std::string const & name) const$/;"	f	class:simpla::Particle
get_property_	applications/particle_solver/fluid_cold_engine.h	/^	any const & get_property_(std::string const &name) const$/;"	f	class:simpla::Particle
get_rank	core/parallel/MPIComm.cpp	/^int MPIComm::get_rank() const$/;"	f	class:simpla::parallel::MPIComm
get_rank	core/parallel/MPIComm.cpp	/^int MPIComm::get_rank(nTuple<int, 3> const &d) const$/;"	f	class:simpla::parallel::MPIComm
get_rank	core/parallel/MPIComm.h	/^    int get_rank(TD const &d) const$/;"	f	class:simpla::parallel::MPIComm
get_rho	applications/particle_solver/fluid_cold_engine.h	/^	void const * get_rho() const$/;"	f	class:simpla::Particle
get_string	core/gtl/any.h	/^bool get_string(T *v, std::string const &)$/;"	f	namespace:simpla::_impl
get_string	core/gtl/any.h	/^inline bool get_string(std::string *v, std::string const &other)$/;"	f	namespace:simpla::_impl
get_type_as_string	applications/contexts/explicit_em.h	/^    std::string get_type_as_string() const$/;"	f	struct:simpla::ExplicitEMContext
get_type_as_string	applications/particle_solver/fluid_cold_engine.h	/^	std::string get_type_as_string() const$/;"	f	class:simpla::Particle
get_type_as_string	applications/particle_solver/pic_engine_deltaf.h	/^	static std::string get_type_as_string()$/;"	f	struct:simpla::ParticleEngine
get_type_as_string	applications/particle_solver/pic_engine_deltaf2.h	/^	std::string get_type_as_string() const$/;"	f	struct:simpla::PICEngineDeltaF
get_type_as_string	applications/particle_solver/pic_engine_fullf.h	/^	static std::string get_type_as_string()$/;"	f	class:simpla::PICEngineFullF
get_type_as_string	applications/particle_solver/pic_engine_ggauge.h	/^	static std::string get_type_as_string()$/;"	f	class:simpla::PICEngineGGauge
get_type_as_string	applications/particle_solver/pic_engine_implicit.h	/^	static std::string get_type_as_string()$/;"	f	struct:simpla::PICEngineImplicit
get_type_as_string	core/field/obsoleted/field_sparse.h	/^	std::string get_type_as_string() const$/;"	f	struct:simpla::Field
get_type_as_string	core/field/test/trash/field_continue.h	/^	std::string get_type_as_string() const$/;"	f	struct:simpla::Field
get_type_as_string	core/gtl/design_pattern/visitor.h	/^    virtual std::string get_type_as_string() const { return "Custom"; }$/;"	f	struct:simpla::VisitorBase
get_type_as_string	core/particle/obsolete/kinetic_particle.h	/^    std::string get_type_as_string() const$/;"	f	struct:KineticParticle
get_type_as_string	core/particle/obsolete/probe_particle.h	/^    std::string get_type_as_string() const$/;"	f	struct:simpla::ProbeParticle
get_type_as_string	core/particle/obsolete/simple_particle.h	/^	static std::string get_type_as_string()$/;"	f	struct:simpla::SimpleParticleEngine
get_type_as_string	example/probe_particle/demo_probe_particle.h	/^	static std::string get_type_as_string()$/;"	f	struct:simpla::ProbeDemo
get_type_as_string_staic	core/particle/obsolete/kinetic_particle.h	/^    static std::string get_type_as_string_staic()$/;"	f	struct:KineticParticle
get_type_as_string_staic	core/particle/obsolete/probe_particle.h	/^    static std::string get_type_as_string_staic()$/;"	f	struct:simpla::ProbeParticle
get_type_as_string_static	applications/contexts/explicit_em.h	/^    static std::string get_type_as_string_static()$/;"	f	struct:simpla::ExplicitEMContext
get_type_as_string_static	applications/particle_solver/fluid_cold_engine.h	/^	static std::string get_type_as_string_static()$/;"	f	class:simpla::Particle
get_typename	core/gtl/utilities/lua_object.cpp	/^std::string LuaObject::get_typename() const$/;"	f	class:simpla::lua::LuaObject
get_unit	core/physics/PhysicalConstants.h	/^    std::string get_unit(std::string const &s) const$/;"	f	class:simpla::PhysicalConstants
get_value	core/data_model/DataSet.h	/^    template<typename T> T &get_value(size_t s) { return reinterpret_cast<T *>( data.get())[s]; }$/;"	f	struct:simpla::data_model::DataSet
get_value	core/data_model/DataSet.h	/^    template<typename T> T const &get_value(size_t s) const { return reinterpret_cast<T *>( data.get())[s]; }$/;"	f	struct:simpla::data_model::DataSet
get_vertices	core/manifold/mesh/CoRectMesh.h	/^    int get_vertices(int node_id, id_type s, point_type *p = nullptr) const$/;"	f	struct:simpla::mesh::Mesh
get_vertices	core/manifold/mesh/MeshBlock.h	/^    int get_vertices(size_t node_id, id_type s, point_type *p = nullptr) const$/;"	f	struct:simpla::mesh::MeshBlock
get_volumes	core/manifold/mesh/MeshBlock.cpp	/^void MeshBlock::get_volumes(Real *m_volume_, Real *m_inv_volume_, Real *m_dual_volume_, Real *m_inv_dual_volume_)$/;"	f	class:simpla::mesh::MeshBlock
ghost_box	core/manifold/mesh/MeshBlock.h	/^    std::vector<index_box_type> const &ghost_box() const { return m_ghost_box_; }$/;"	f	class:simpla::mesh::MeshBlock::std
ghost_width	core/manifold/mesh/MeshBlock.cpp	/^void MeshBlock::ghost_width(index_tuple const &g)$/;"	f	class:simpla::mesh::MeshBlock
ghost_width	core/manifold/mesh/MeshBlock.h	/^    index_tuple const &ghost_width() const { return m_ghost_width_; }$/;"	f	struct:simpla::mesh::MeshBlock
global_begin	core/parallel/test/distributed_array_test.cpp	/^	nTuple<size_t, 3> global_begin;$/;"	m	class:TestDistArray	file:
global_end	core/parallel/test/distributed_array_test.cpp	/^	nTuple<size_t, 3> global_end;$/;"	m	class:TestDistArray	file:
grad	core/numeric/interpolation.h	/^    inline nTuple <TV, NDIMS> grad(TV const *v, TX x, TX y,$/;"	f	class:simpla::BiLinearInterpolation
grad	core/numeric/interpolation.h	/^    inline typename container::mapped_type grad(container const &,$/;"	f	struct:simpla::LinearInterpolation
grad	core/numeric/interpolation.h	/^    nTuple <value_type, NDIMS> grad(TArgs const &... x) const$/;"	f	class:simpla::MultiDimesionInterpolation
grad	core/numeric/interpolation.h	/^    value_type grad(key_x_type const &x) const$/;"	f	class:simpla::Interpolation
gradT0	applications/particle_solver/pic_engine_deltaf2.h	/^	Field<mesh_type, EDGE, Real> gradT0;$/;"	m	struct:simpla::PICEngineDeltaF
grad_psi	core/model/GEqdsk.cpp	/^Vec3 GEqdsk::grad_psi(Real R, Real Z) const$/;"	f	class:simpla::GEqdsk
gradn0	applications/particle_solver/pic_engine_deltaf2.h	/^	Field<mesh_type, EDGE, Real> gradn0;$/;"	m	struct:simpla::PICEngineDeltaF
grainsize	core/gtl/array_view.h	/^    size_type grainsize() const { return m_grain_size_; }$/;"	f	class:simpla::gtl::ArrayView
grainsize	core/gtl/iterator/range.h	/^    ptrdiff_t grainsize() const { return m_grain_size_; }$/;"	f	class:simpla::Range
grainsize	core/gtl/range/block_range.h	/^    size_type grainsize() const { return m_grain_size_; }$/;"	f	class:simpla::BlockRange
grainsize	core/manifold/mesh/MeshIds.h	/^        index_tuple const &grainsize() const { return m_grain_size_; }$/;"	f	struct:simpla::mesh::MeshEntityIdCoder::range_type
grainsize	core/parallel/obsoleted/blocked_range.h	/^	size_type grainsize() const$/;"	f	struct:simpla::BlockedRange
grainsize	core/parallel/obsoleted/blocked_range.h	/^	void grainsize(size_type const &gs)$/;"	f	struct:simpla::BlockedRange
grainsize_	core/parallel/obsoleted/blocked_range.h	/^	size_type grainsize_;$/;"	m	struct:simpla::BlockedRange
grid_vertices	core/manifold/Manifold.h	/^    virtual data_model::DataSet grid_vertices() const$/;"	f	class:simpla::Manifold
gtl	core/gtl/array_view.h	/^namespace simpla { namespace gtl$/;"	n	namespace:simpla
gtl	core/gtl/containers/UnorderedSet.h	/^namespace gtl$/;"	n	namespace:simpla
half_split	core/numeric/half_split.h	/^nTuple<T, N> half_split(nTuple<T, N> & range)$/;"	f	namespace:simpla
half_split	core/numeric/half_split.h	/^std::tuple<T, T> half_split(std::tuple<T, T> & range)$/;"	f	namespace:simpla
has	core/gtl/Properties.h	/^    inline bool has(std::string const &s) const { return map_type::find(s) != map_type::end(); }$/;"	f	class:simpla::Properties
has_PlaceHolder	core/gtl/primitives.h	/^template<typename> struct has_PlaceHolder$/;"	s	namespace:simpla
hash	core/gtl/containers/sp_hash_container.h	/^	size_t hash(key_type const & s) const$/;"	f	struct:simpla::SpHashContainer
hash	core/gtl/containers/sp_ndarray.h	/^	constexpr size_t hash(index_type s) const$/;"	f	class:simpla::ndArray
hash	core/gtl/containers/sp_ndarray.h	/^	constexpr size_t hash(index_type s, index_type ...other) const$/;"	f	class:simpla::ndArray
hash	core/manifold/mesh/MeshBlock.h	/^    size_t hash(id_type const &s) const$/;"	f	struct:simpla::mesh::MeshBlock
hash	core/manifold/mesh/MeshIds.h	/^    static index_type hash(id_type const &s, index_tuple const &b, index_tuple const &e)$/;"	f	struct:simpla::mesh::MeshEntityIdCoder
hash_	core/gtl/array_view.h	/^    size_t hash_(size_t const *idx) const$/;"	f	struct:simpla::gtl::ArrayViewBase
hash_	core/manifold/mesh/CylindricalCoRect.h	/^    size_t hash_(id_type s) const$/;"	f	class:simpla::mesh::CylindricalCoRect
hash_	core/manifold/mesh/RectMesh.h	/^    size_t hash_(id_type s) const$/;"	f	struct:simpla::mesh::Mesh
hash_fun	core/gtl/function_cache.h	/^	typedef Hash hash_fun;$/;"	t	struct:simpla::FunctionCache
hash_fun_	core/gtl/containers/container_dense.h	/^	std::function<size_t(key_type)> hash_fun_;$/;"	m	class:simpla::DenseContainer
hash_function	core/gtl/containers/sp_hash_container.h	/^	typedef Hash hash_function;$/;"	t	struct:simpla::SpHashContainer
hash_id	core/field/test/trash/field_simple_mesh_map_test.cpp	/^struct hash_id$/;"	s	file:
hasher	core/gtl/containers/sp_hash_container.h	/^	hash_function const & hasher() const$/;"	f	struct:simpla::SpHashContainer
hasher	core/gtl/containers/sp_hash_container.h	/^	void hasher(Args && ...args) const$/;"	f	struct:simpla::SpHashContainer
hasher	core/gtl/containers/sp_hash_container.h	/^	void hasher(hash_function const & fun) const$/;"	f	struct:simpla::SpHashContainer
hasher_type	core/gtl/iterator/sp_indirect_iterator.h	/^    typedef Hasher hasher_type;$/;"	t	struct:simpla::sp_indirect_iterator
hdf5	core/io/XDMFStream.h	/^    HDF5Stream &hdf5() { return m_h5_stream_; }$/;"	f	class:simpla::io::XDMFStream
hdf5	core/io/XDMFStream.h	/^    HDF5Stream const &hdf5() const { return m_h5_stream_; }$/;"	f	class:simpla::io::XDMFStream
help_message	core/gtl/utilities/log.cpp	/^std::string LoggerStreams::help_message()$/;"	f	class:simpla::logger::LoggerStreams
help_message	core/gtl/utilities/log.cpp	/^std::string help_message()$/;"	f	namespace:simpla::logger
help_message	core/parallel/MPIComm.cpp	/^std::string MPIComm::help_message()$/;"	f	class:simpla::parallel::MPIComm
help_message	core/parallel/Parallel.cpp	/^std::string help_message()$/;"	f	namespace:simpla::parallel
histogram	example/pic/collision_pic.cpp	/^void histogram(int nx, int nbin, Real vmin, Real vmax, std::vector<pic_mark> const &data, std::vector<Real> *res)$/;"	f
holder	core/gtl/enable_create_from_this.h	/^	typedef std::shared_ptr<object_type> holder;$/;"	t	struct:simpla::enable_create_from_this
holder_type	core/gtl/containers/container_traits.h	/^	typedef std::shared_ptr<TV> holder_type;$/;"	t	struct:simpla::container_traits
holder_type	core/gtl/containers/container_traits.h	/^	typedef std::shared_ptr<container_type> holder_type;$/;"	t	struct:simpla::container_traits
i0	core/manifold/obsoleted/mesh_graph.h	/^    typename m::id_type i0, i1;$/;"	m	struct:simpla::mesh::MeshMapEdge
i1	core/manifold/obsoleted/mesh_graph.h	/^    typename m::id_type i0, i1;$/;"	m	struct:simpla::mesh::MeshMapEdge
id	core/manifold/mesh/MeshBlock.h	/^    virtual id_type id(point_type const &x, int n_id = 0) const$/;"	f	struct:simpla::mesh::MeshBlock
id	core/manifold/mesh/RectMesh.h	/^    virtual id_type id(point_type const &x, int n_id = 0) const$/;"	f	struct:simpla::mesh::Mesh
id	example/pic/demo_pic.h	/^	inline typename base_manifold::id_type id(point_type const &p, Args &&...args) const$/;"	f	struct:simpla::FiberBundle
id_mask	core/manifold/mesh/MeshBlock.h	/^    size_t id_mask() const$/;"	f	struct:simpla::mesh::MeshBlock
id_tuple	core/manifold/mesh/MeshIds.h	/^    typedef nTuple<id_type, ndims> id_tuple;$/;"	t	struct:simpla::mesh::MeshEntityIdCoder
id_type	core/base/Attribute.h	/^    typedef typename mesh_type::id_type id_type;$/;"	t	class:simpla::base::Attribute
id_type	core/base/Attribute.h	/^    typedef typename mesh_type::id_type id_type;$/;"	t	class:simpla::base::AttributeEntity
id_type	core/field/FieldDense.h	/^    typedef typename mesh_type::id_type id_type;$/;"	t	class:simpla::Field
id_type	core/field/FieldFunction.h	/^    typedef typename mesh_type::id_type id_type;$/;"	t	class:simpla::Field
id_type	core/field/obsoleted/field_constant.h	/^	typedef typename mesh_type::id_type id_type;$/;"	t	class:simpla::Field
id_type	core/field/obsoleted/field_sparse.h	/^	typedef typename mesh_type::id_type id_type;$/;"	t	struct:simpla::Field
id_type	core/field/test/trash/field_continue.h	/^	typedef typename mesh_type::id_type id_type;$/;"	t	struct:simpla::Field
id_type	core/geometry/chains.h	/^    typedef size_t id_type;$/;"	t	struct:simpla::geometry::model::Chains
id_type	core/geometry/obsolete/polygon.h	/^	typedef typename mesh_type::id_type id_type;$/;"	t	struct:simpla::PolyGon
id_type	core/geometry/obsolete/surface.h	/^	typedef typename mesh_type::id_type id_type;$/;"	t	class:simpla::Surface
id_type	core/manifold/ManifoldTraits.h	/^struct id_type<Manifold<TMesh, Policies...> >$/;"	s	namespace:simpla::traits
id_type	core/manifold/ManifoldTraits.h	/^template<typename T> struct id_type$/;"	s	namespace:simpla::traits
id_type	core/manifold/mesh/MeshIds.h	/^    typedef std::uint64_t id_type;$/;"	t	struct:simpla::mesh::MeshEntityIdCoder
id_type	core/manifold/obsoleted/amr_policy.h	/^    typedef typename mesh_type::id_type id_type;$/;"	t	class:simpla::manifold::policy::AMR
id_type	core/manifold/obsoleted/block.h	/^    typedef std::int64_t id_type;$/;"	t	struct:simpla::Block
id_type	core/manifold/obsoleted/embedded_policy.h	/^    typedef typename TGeo::id_type id_type;$/;"	t	struct:simpla::manifold::policy::EmbeddedPolicy
id_type	core/manifold/obsoleted/fiber_bundle.h	/^    typedef typename mesh_type::id_type id_type;$/;"	t	class:simpla::manifold::FiberBundle
id_type	core/manifold/policy/IOPolicy.h	/^    typedef typename TGeo::id_type id_type;$/;"	t	struct:simpla::manifold::policy::IOPolicy
id_type	core/manifold/policy/StoragePolicy.h	/^    typedef typename TGeo::id_type id_type;$/;"	t	struct:simpla::manifold::policy::StoragePolicy
id_type	core/model/obsoleted/model.h	/^    typedef typename Block::id_type id_type;$/;"	t	class:simpla::Model
id_type	core/particle/Particle.h	/^    typedef typename mesh_type::id_type id_type;$/;"	t	struct:simpla::particle::Particle
id_type	core/particle/ParticleContainer.h	/^    typedef typename mesh_type::id_type id_type;$/;"	t	struct:simpla::particle::ParticleContainer
id_type	core/particle/ParticleGenerator.h	/^    typedef typename mesh_type::id_type id_type;$/;"	t	class:simpla::particle::ParticleGeneratorPerCell
id_type	core/particle/obsolete/kinetic_particle.h	/^    typedef typename mesh_type::id_type id_type;$/;"	t	struct:simpla::_impl::particle_hasher
id_type	core/phy_solver/em_fluid.h	/^    typedef typename mesh_type::id_type id_type;$/;"	t	class:simpla::phy_solver::EMFluid
id_type	example/em_tokamak/tokamak.cpp	/^    typedef typename mesh_type::id_type id_type;$/;"	t	struct:simpla::EMTokamak	file:
identifier_type	core/gtl/design_pattern/factory.h	/^	typedef TId identifier_type;$/;"	t	struct:simpla::Factory
iform	core/field/FieldDense.h	/^    static constexpr int iform = IFORM;$/;"	m	class:simpla::Field
iform	core/field/FieldDense.h	/^struct iform<Field<TV, TM, TFORM, Others...> > : public TFORM$/;"	s	namespace:simpla::traits
iform	core/field/FieldExpression.h	/^struct iform<Field<Expression<TAG, T0, T...> > > : public traits::iform<T0>::type$/;"	s	namespace:simpla::traits
iform	core/field/FieldFunction.h	/^    static constexpr int iform = IFORM;$/;"	m	class:simpla::Field
iform	core/field/obsoleted/field_patch.h	/^    static constexpr int iform = field_type::iform;$/;"	m	class:simpla::FieldAMRPolicy
iform	core/field/test/field_basic_algebra_test.h	/^    static constexpr int iform = traits::iform<TField>::value;$/;"	m	class:TestField
iform	core/geometry/test/geometry_test.cpp	/^	static constexpr size_t iform = TInt::value;$/;"	m	class:TestModel	file:
iform	core/manifold/Calculus.h	/^struct iform<Field<Expression<calculus::tags::CodifferentialDerivative, T> > > : public std::integral_constant<$/;"	s	namespace:simpla::traits
iform	core/manifold/Calculus.h	/^struct iform<Field<Expression<calculus::tags::ExteriorDerivative, T> > > : public std::integral_constant<$/;"	s	namespace:simpla::traits
iform	core/manifold/Calculus.h	/^struct iform<Field<Expression<calculus::tags::HodgeStar, T> > > : public std::integral_constant<$/;"	s	namespace:simpla::traits
iform	core/manifold/Calculus.h	/^struct iform<Field<Expression<calculus::tags::InteriorProduct, T0, T1> > > : public std::integral_constant<$/;"	s	namespace:simpla::traits
iform	core/manifold/Calculus.h	/^struct iform<Field<Expression<calculus::tags::MapTo, T1, std::integral_constant<int, I>>> >$/;"	s	namespace:simpla::traits
iform	core/manifold/Calculus.h	/^struct iform<Field<Expression<calculus::tags::Wedge, T0, T1> > > : public std::integral_constant<$/;"	s	namespace:simpla::traits
iform	core/manifold/Calculus.h	/^struct iform<std::integral_constant<int, I> > : public std::integral_constant<int, I>$/;"	s	namespace:simpla::traits
iform	core/manifold/ManifoldTraits.h	/^template<typename> struct iform : public std::integral_constant<int, 0>$/;"	s	namespace:simpla::traits
iform	core/manifold/mesh/MeshIds.h	/^    static constexpr int iform(id_type s)$/;"	f	struct:simpla::mesh::MeshEntityIdCoder
iform	core/manifold/obsoleted/patch/mesh_patch.h	/^    static constexpr int iform = IFORM;$/;"	m	class:simpla::mesh::PatchPolicy
iform	core/model/test/model_test.cpp	/^	static constexpr size_t iform = TInt::value;$/;"	m	class:TestModel	file:
iform	core/particle/Particle.h	/^    static constexpr int iform = container_type::iform;$/;"	m	struct:simpla::particle::Particle
iform	core/particle/ParticleContainer.h	/^    static constexpr int iform = VOLUME;$/;"	m	struct:simpla::particle::ParticleContainer
iform	core/particle/obsolete/kinetic_particle.h	/^    static constexpr size_t iform = domain_type::iform;$/;"	m	struct:simpla::_impl::particle_hasher
iform	core/particle/obsolete/kinetic_particle.h	/^template<typename TDomain, typename TPoint_s> constexpr size_t particle_hasher<TDomain, TPoint_s>::iform;$/;"	m	class:simpla::_impl::particle_hasher
iform_list	core/manifold/ManifoldTraits.h	/^struct iform_list : public integer_sequence<int, iform<T>::value...>$/;"	s	namespace:simpla::traits
imag	core/gtl/complex.h	/^template<typename T> inline constexpr T imag(T const &)$/;"	f	namespace:std
imag	core/gtl/sp_complex.h	/^template<typename T> inline constexpr T imag(T const &)$/;"	f	namespace:std
implicit_push_E	applications/contexts/explicit_em.h	/^    ImplicitPushE<Model < mesh_type>> implicit_push_E;$/;"	m	struct:simpla::ExplicitEMContext
in	core/numeric/sobol_engine.h	/^	result_type in;$/;"	m	class:simpla::sobol_engine
in_box	core/geometry/GeoAlgorithm.h	/^bool in_box(T0 const &x0, T1 const &xmin, T2 const &xmax)$/;"	f	namespace:simpla::geometry
in_box	core/gtl/iterator/sp_ntuple_range.h	/^    bool in_box(T const &x) const$/;"	f	struct:simpla::sp_nTuple_range
in_box	core/manifold/mesh/MeshBlock.h	/^    bool in_box(id_type s) const { return in_box(m::unpack_index(s)); }$/;"	f	struct:simpla::mesh::MeshBlock
in_box	core/manifold/mesh/MeshBlock.h	/^    bool in_box(index_tuple const &x) const$/;"	f	struct:simpla::mesh::MeshBlock
in_set	core/geometry/geometry.h	/^bool in_set(TL const &l, TBox const &b) { return in_box(l, ::simpla::traits::get<0>(b), ::simpla::traits::get<1>(b)); }$/;"	f	namespace:simpla::geometry::traits
in_set	core/geometry/geometry.h	/^template<typename TL> bool in_set(TL const &l, GeoObject const &r) { return r.within(l); }$/;"	f	namespace:simpla::geometry::traits
increase_step_counter	core/particle/obsolete/probe_particle.h	/^void ProbeParticle<Engine>::increase_step_counter(size_t num_of_steps)$/;"	f	class:simpla::ProbeParticle
index	core/gtl/containers/container_traits.h	/^	static value_type & index(holder_type & data, key_type s)$/;"	f	struct:simpla::container_traits
index	core/gtl/containers/container_traits.h	/^	static value_type & index(holder_type & data, size_t s)$/;"	f	struct:simpla::container_traits
index	core/gtl/containers/container_traits.h	/^	static value_type const & index(holder_type const & data, key_type s)$/;"	f	struct:simpla::container_traits
index	core/gtl/containers/container_traits.h	/^	static value_type const & index(holder_type const & data, size_t s)$/;"	f	struct:simpla::container_traits
index_box	core/manifold/mesh/CoRectMesh.h	/^    std::tuple<index_tuple, index_tuple> index_box(std::tuple<point_type, point_type> const &b) const$/;"	f	struct:simpla::mesh::Mesh
index_box	core/manifold/mesh/MeshBlock.h	/^    index_box_type index_box() const$/;"	f	struct:simpla::mesh::MeshBlock
index_box	core/manifold/mesh/MeshBlock.h	/^    index_box_type index_box(box_type const &b) const$/;"	f	struct:simpla::mesh::MeshBlock
index_box	core/manifold/mesh/RectMesh.h	/^    index_box_type index_box(box_type const &b) const$/;"	f	struct:simpla::mesh::Mesh
index_box_type	core/manifold/mesh/MeshBlock.h	/^    typedef std::tuple<index_tuple, index_tuple> index_box_type;$/;"	t	struct:simpla::mesh::MeshBlock
index_of	core/gtl/type_traits_ext.h	/^struct index_of<TC, TI>$/;"	s	namespace:simpla
index_range	core/data_model/data_view.h	/^	index_range_type const &index_range() const { return m_index_range_; }$/;"	f	struct:simpla::data_view
index_range_type	core/data_model/data_view.h	/^	typedef IndexRange index_range_type;$/;"	t	struct:simpla::data_view
index_tuple	core/data_model/DataSpace.h	/^    typedef nTuple <index_type, MAX_NDIMS_OF_ARRAY> index_tuple;$/;"	t	class:simpla::data_model::DataSpace
index_tuple	core/field/test/field_diff_calculus_test.h	/^    typedef typename mesh_type::index_tuple index_tuple;$/;"	t	class:FETLTest
index_tuple	core/gtl/containers/sp_ndarray.h	/^	typedef long index_tuple;$/;"	t	class:simpla::ndArray
index_tuple	core/gtl/containers/sp_ndarray.h	/^	typedef nTuple<index_type, NDIMS> index_tuple;$/;"	t	class:simpla::ndArray
index_tuple	core/manifold/mesh/MeshIds.h	/^    typedef nTuple<index_type, ndims> index_tuple;$/;"	t	struct:simpla::mesh::MeshEntityIdCoder
index_tuple	core/manifold/obsoleted/amr_policy.h	/^    typedef typename mesh_type::index_tuple index_tuple;$/;"	t	class:simpla::manifold::policy::AMR
index_tuple	core/particle/Particle.h	/^    typedef typename mesh_type::index_tuple index_tuple;$/;"	t	struct:simpla::particle::Particle
index_tuple	core/particle/ParticleContainer.h	/^    typedef typename mesh_type::index_tuple index_tuple;$/;"	t	struct:simpla::particle::ParticleContainer
index_tuple	example/em_tokamak/tokamak.cpp	/^    typedef typename mesh_type::index_tuple index_tuple;$/;"	t	struct:simpla::EMTokamak	file:
index_type	core/data_model/DataSpace.h	/^    typedef size_t index_type;$/;"	t	class:simpla::data_model::DataSpace
index_type	core/gtl/containers/sp_ndarray.h	/^	typedef long index_type;$/;"	t	class:simpla::ndArray
index_type	core/gtl/iterator/sp_ntuple_range.h	/^    typedef IndexType index_type;$/;"	t	struct:simpla::sp_nTuple_range
index_type	core/manifold/mesh/MeshIds.h	/^    typedef long index_type;$/;"	t	struct:simpla::mesh::MeshEntityIdCoder
indexed_access	core/geometry/boost_gemetry_adapted.h	/^struct indexed_access<sgm::Box<CS>, I, Dimension>$/;"	s	namespace:boost::geometry::traits
indexed_access	core/geometry/boost_gemetry_adapted.h	/^struct indexed_access<sgm::Primitive<N, CS, TAG>, Index, M>$/;"	s	namespace:boost::geometry::traits
indices_tuple	core/geometry/chains.h	/^    typedef nTuple<id_type, max_number_of_points> indices_tuple;$/;"	t	struct:simpla::geometry::model::Chains
indirect_container	core/gtl/containers/sp_indirect_container.h	/^	indirect_container(value_conatinaer_type & d) :$/;"	f	struct:simpla::indirect_container
indirect_container	core/gtl/containers/sp_indirect_container.h	/^struct indirect_container: public KeyContainer$/;"	s	namespace:simpla
indirect_iterator	core/gtl/iterator/indirect_iterator.h	/^	indirect_iterator(src_iterator const & s_it) :$/;"	f	struct:simpla::indirect_iterator
indirect_iterator	core/gtl/iterator/indirect_iterator.h	/^struct indirect_iterator$/;"	s	namespace:simpla
indirect_iterator	core/gtl/iterator/sp_indirect_iterator.h	/^sp_indirect_iterator<BaseIterator, Container> indirect_iterator($/;"	f	namespace:simpla
info	core/parallel/MPIComm.cpp	/^MPI_Info MPIComm::info()$/;"	f	class:simpla::parallel::MPIComm
info	core/task_flow/use_case.h	/^    std::string info;$/;"	m	class:simpla::use_case::UseCase
init	applications/field_solver/pml.h	/^void PML<TM>::init(TDict const &dict, Others const & ...)$/;"	f	class:simpla::PML
init	core/gtl/utilities/config_parser.cpp	/^std::string ConfigParser::init(int pargc, char **pargv)$/;"	f	class:simpla::ConfigParser
init	core/gtl/utilities/log.cpp	/^void LoggerStreams::init(int argc, char **argv)$/;"	f	class:simpla::logger::LoggerStreams
init	core/gtl/utilities/log.cpp	/^void init(int argc, char **argv)$/;"	f	namespace:simpla::logger
init	core/gtl/utilities/lua_object.cpp	/^void LuaObject::init()$/;"	f	class:simpla::lua::LuaObject
init	core/gtl/utilities/lua_object.h	/^        void init() { m_l_ = std::make_shared<lua_s>(); }$/;"	f	struct:simpla::lua::LuaObject::LuaState
init	core/io/IO.cpp	/^void init(int argc, char **argv)$/;"	f	namespace:simpla::io
init	core/io/IOStream.cpp	/^void IOStream::init(int argc, char **argv)$/;"	f	class:simpla::io::IOStream
init	core/parallel/MPIComm.cpp	/^void MPIComm::init(int argc, char **argv)$/;"	f	class:simpla::parallel::MPIComm
init	core/parallel/Parallel.cpp	/^void init(int argc, char **argv)$/;"	f	namespace:simpla::parallel
init_particle	core/particle/obsolete/load_particle.h	/^void init_particle(TR const &domain, size_t pic, TN const &ns, TT const &Ts,$/;"	f	namespace:simpla
initialize	core/gtl/containers/container_dense.h	/^	void initialize()$/;"	f	class:simpla::DenseContainer
initialize	core/gtl/containers/container_sparse.h	/^    void initialize()$/;"	f	class:simpla::SparseContainer
initialize	core/phy_solver/em_fluid.h	/^void EMFluid<TM>::initialize(int argc, char **argv)$/;"	f	class:simpla::phy_solver::EMFluid
initialize	example/em_tokamak/tokamak.cpp	/^void EMTokamak::initialize(int argc, char **argv)$/;"	f	class:simpla::EMTokamak
inner_container_type	core/geometry/model.h	/^	typedef std::vector<ring_type> inner_container_type;$/;"	t	struct:simpla::geometry::model::Polygon
inner_product	core/geometry/csCylindrical.h	/^    static constexpr Real inner_product(T0 const &v0, T1 const &v1, TX const &r, Others &&... others)$/;"	f	struct:simpla::geometry::Metric
inner_range	core/manifold/mesh/MeshBlock.h	/^    range_type inner_range() const$/;"	f	struct:simpla::mesh::MeshBlock
inners	core/geometry/model.h	/^	inline inner_container_type & inners()$/;"	f	struct:simpla::geometry::model::Polygon
inners	core/geometry/model.h	/^	inline inner_container_type const& inners() const$/;"	f	struct:simpla::geometry::model::Polygon
input_iterator	core/parallel/ParallelRandomGenerator.h	/^    input_iterator(input_iterator const &other)$/;"	f	struct:simpla::parallel::DistributedCounter::input_iterator
input_iterator	core/parallel/ParallelRandomGenerator.h	/^    input_iterator(size_t start) : m_count_(0)$/;"	f	struct:simpla::parallel::DistributedCounter::input_iterator
input_iterator	core/parallel/ParallelRandomGenerator.h	/^struct DistributedCounter::input_iterator : public std::iterator<std::input_iterator_tag, size_t>$/;"	s	class:simpla::parallel::DistributedCounter
input_iterator	core/particle/ParticleGenerator.h	/^        input_iterator(input_iterator const &other) :$/;"	f	struct:simpla::particle::ParticleGenerator::input_iterator
input_iterator	core/particle/ParticleGenerator.h	/^        input_iterator(size_t start) : m_count_(start) { }$/;"	f	struct:simpla::particle::ParticleGenerator::input_iterator
input_iterator	core/particle/ParticleGenerator.h	/^        input_iterator(size_t start, TFun const &func)$/;"	f	struct:simpla::particle::ParticleGenerator::input_iterator
input_iterator	core/particle/ParticleGenerator.h	/^        input_iterator(size_t start, TFun const &func, seed_type const &seed)$/;"	f	struct:simpla::particle::ParticleGenerator::input_iterator
input_iterator	core/particle/ParticleGenerator.h	/^    struct input_iterator : public std::iterator<std::input_iterator_tag, value_type>$/;"	s	struct:simpla::particle::ParticleGenerator
insert	core/base/Patch.h	/^    insert(std::shared_ptr<object_type> p)$/;"	f	class:simpla::base::Patch
insert	core/gtl/containers/UnorderedSet.h	/^    void insert(InputIterator const &b, InputIterator const &e, Others &&...others)$/;"	f	class:simpla::gtl::UnorderedSet
insert	core/gtl/containers/UnorderedSet.h	/^    void insert(std::tuple<InputIterator, InputIterator> const &r, Others &&... others)$/;"	f	class:simpla::gtl::UnorderedSet
insert	core/gtl/containers/UnorderedSet.h	/^UnorderedSet<ValueType, Key>::insert(value_type const &v, key_type const &s)$/;"	f	class:simpla::gtl::UnorderedSet
insert	core/gtl/containers/unordered_set.h	/^    key_type insert(TV const &v, Hash const &hasher)$/;"	f	class:simpla::UnorderedSet
insert	core/gtl/containers/unordered_set.h	/^    void insert(InputIter first, InputIter last, Hash const &hasher)$/;"	f	class:simpla::UnorderedSet
insert	core/gtl/containers/unordered_set.h	/^    void insert(key_type const &key, InputIter first, InputIter last, Hash const &hasher)$/;"	f	class:simpla::UnorderedSet
insert	core/gtl/containers/unordered_set.h	/^    void insert(key_type const &key, TV &&v)$/;"	f	class:simpla::UnorderedSet
insert	core/gtl/containers/unordered_set.h	/^    void insert(key_type const &key, std::initializer_list<value_type> ilist, Hash const &hasher)$/;"	f	class:simpla::UnorderedSet
insert	core/gtl/containers/unordered_set.h	/^    void insert(std::initializer_list<value_type> ilist)$/;"	f	class:simpla::UnorderedSet
insert	core/manifold/obsoleted/amr_policy.h	/^    insert(size_t id, std::shared_ptr<entity_type> p)$/;"	f	class:simpla::manifold::policy::AMR
insert	core/particle/ParticleContainer.h	/^    void insert(value_type const &p) { insert(p, m_hash_(p)); }$/;"	f	struct:simpla::particle::ParticleContainer
insert	core/particle/ParticleContainer.h	/^ParticleContainer<V, K>::insert(InputIterator const &b, InputIterator const &e)$/;"	f	class:simpla::particle::ParticleContainer
insert	core/particle/ParticleContainer.h	/^ParticleContainer<V, K>::insert(InputIterator const &b, InputIterator const &e, id_type const &hint)$/;"	f	class:simpla::particle::ParticleContainer
insert	core/particle/ParticleContainer.h	/^ParticleContainer<V, K>::insert(value_type const &v, id_type const &s)$/;"	f	class:simpla::particle::ParticleContainer
insert	core/particle/obsolete/kinetic_particle.h	/^    void insert(TIterator const &b, TIterator const &e)$/;"	f	struct:KineticParticle
instance	core/gtl/design_pattern/singleton_holder.h	/^	static T & instance()$/;"	f	class:simpla::SingletonHolder
integer_sequence	core/gtl/type_traits.h	/^struct integer_sequence$/;"	s	namespace:simpla
integer_sequence	core/gtl/type_traits.h	/^struct integer_sequence<_Tp>$/;"	s	namespace:simpla
integral	core/manifold/obsoleted/fiber_bundle.h	/^    Real integral(id_type const &s, point_type const &z) const$/;"	f	class:simpla::manifold::FiberBundle
integral	core/manifold/obsoleted/fiber_bundle.h	/^    Real integral(mesh_type::point_type const &x0, point_type const &z, vector_type const &dx) const$/;"	f	class:simpla::manifold::FiberBundle
integral	core/particle/Particle.h	/^    virtual void integral() { for (auto &item:m_integral_list_) { item.second(item.first); }}$/;"	f	struct:simpla::particle::Particle
integral	core/particle/ParticleProxy.h	/^    virtual void integral(TJ *J) const { m_self_->integral(J); }$/;"	f	class:simpla::particle::ParticleProxy
integral	core/particle/ParticleProxy.h	/^    virtual void integral(TRho *n) const { m_self_->integral(n); }$/;"	f	class:simpla::particle::ParticleProxy
integral	core/particle/ParticleTracker.h	/^    void integral(point_type const &x, sample_type const &p, Args &&...args) const$/;"	f	class:simpla::particle::enable_tracking
integral	core/particle/pre_define/GuidingCenter.h	/^    void integral(point_type const &x, sample_type const &p, Real *f) const { *f = p.f * p.w; }$/;"	f	struct:simpla::particle::engine::GuidingCenterEngine
integral	core/particle/pre_define/GuidingCenter.h	/^    void integral(point_type const &x, sample_type const &p, nTuple<Real, 3> *v) const { *v = p.v * p.f * p.w; }$/;"	f	struct:simpla::particle::engine::GuidingCenterEngine
integral	core/particle/pre_define/PICBoris.h	/^    void integral(point_type const &x0, sample_type const &p, scalar_type *res) const$/;"	f	struct:simpla::particle::engine::BorisEngine
integral	core/particle/pre_define/PICBoris.h	/^    void integral(point_type const &x0, sample_type const &p, vector_type *res) const$/;"	f	struct:simpla::particle::engine::BorisEngine
integral	core/particle/pre_define/PICGyro.h	/^    void integral(point_type const &x0, sample_type const &p, Real *f) const$/;"	f	struct:simpla::particle::engine::GyroParticleWithCylindricalCoord
integral	core/particle/pre_define/PICGyro.h	/^    void integral(point_type const &x0, sample_type const &p, nTuple<Real, 3> *v) const$/;"	f	struct:simpla::particle::engine::GyroParticleWithCylindricalCoord
inter2d_type	core/model/GEqdsk.cpp	/^    typedef MultiDimesionInterpolation<BiLinearInterpolation, Real> inter2d_type;$/;"	t	struct:simpla::GEqdsk::pimpl_s	file:
inter_type	core/model/GEqdsk.cpp	/^    typedef Interpolation<LinearInterpolation, Real, Real> inter_type;$/;"	t	struct:simpla::GEqdsk::pimpl_s	file:
interior_const_type	core/geometry/boost_gemetry_adapted.h	/^struct interior_const_type<sgm::Polygon<CS>>$/;"	s	namespace:boost::geometry::traits
interior_mutable_type	core/geometry/boost_gemetry_adapted.h	/^struct interior_mutable_type<sgm::Polygon<CS>>$/;"	s	namespace:boost::geometry::traits
interior_rings	core/geometry/boost_gemetry_adapted.h	/^struct interior_rings<sgm::Polygon<CS>>$/;"	s	namespace:boost::geometry::traits
interpolate_op_	core/numeric/interpolation.h	/^    TInterpolator interpolate_op_;$/;"	m	class:simpla::Interpolation
interpolate_op_	core/numeric/interpolation.h	/^    TInterpolator interpolate_op_;$/;"	m	class:simpla::MultiDimesionInterpolation
interpolate_policy	core/field/FieldDense.h	/^    typedef typename this_type::interpolate_policy interpolate_policy;$/;"	t	class:simpla::Field
interpolate_policy	core/field/FieldFunction.h	/^    typedef typename this_type::interpolate_policy interpolate_policy;$/;"	t	class:simpla::Field
interpolate_policy	core/manifold/policy/LinearInterpolatorPolicy.h	/^    typedef LinearInterpolator interpolate_policy;$/;"	t	struct:simpla::manifold::policy::LinearInterpolator
interpolator_type	applications/particle_solver/pic_engine_ggauge.h	/^	typedef Interpolator interpolator_type;$/;"	t	class:simpla::PICEngineGGauge
interpolator_type	applications/particle_solver/pic_engine_implicit.h	/^	typedef TInterpolator interpolator_type;$/;"	t	struct:simpla::PICEngineImplicit
intersection	core/geometry/boost_gemetry_adapted.h	/^				!= 2, bool>::type intersection(TGeo const & geo,$/;"	f	namespace:simpla::geometry
intersection	core/geometry/boost_gemetry_adapted.h	/^				== 2, bool>::type intersection(TGeo const & geo,$/;"	f	namespace:simpla::geometry
intersection	core/geometry/cut_cell.h	/^size_t intersection(Vec3 const & min, Vec3 const & max,$/;"	f	namespace:simpla
intersection_line_to_polygons	core/geometry/GeoAlgorithm.h	/^Real intersection_line_to_polygons(T0 const &p0, T1 const &p1, T2 const &polygon)$/;"	f	namespace:simpla::geometry
intersects	core/geometry/boost_gemetry_adapted.h	/^				!= 2, bool>::type intersects(TGeo const & geo,$/;"	f	namespace:simpla::geometry
intersects	core/geometry/boost_gemetry_adapted.h	/^				== 2, bool>::type intersects(TGeo const & geo,$/;"	f	namespace:simpla::geometry
inv_dual_volume	core/manifold/mesh/CartesianCoRect.h	/^    virtual Real inv_dual_volume(id_type s) const { return m_inv_dual_volume_[node_id(s)]; }$/;"	f	struct:simpla::mesh::CartesianCoRect
inv_dual_volume	core/manifold/mesh/CoRectMesh.h	/^    virtual Real inv_dual_volume(id_type s) const { return m_inv_dual_volume_[node_id(s)]; }$/;"	f	struct:simpla::mesh::Mesh
inv_dual_volume	core/manifold/mesh/CylindricalCoRect.h	/^    virtual Real inv_dual_volume(id_type s) const$/;"	f	class:simpla::mesh::CylindricalCoRect
inv_dual_volume	core/manifold/mesh/RectMesh.h	/^    virtual Real inv_dual_volume(id_type s) const$/;"	f	struct:simpla::mesh::Mesh
inv_dx_	core/numeric/interpolation.h	/^    nTuple <Real, NDIMS> xmin_, xmax_, inv_dx_;$/;"	m	class:simpla::BiLinearInterpolation
inv_map	core/manifold/mesh/GeneralMap.h	/^    TP *inv_map(TP *y) const$/;"	f	struct:simpla::mesh::GeneralMap
inv_map	core/manifold/mesh/GeneralMap.h	/^    TP inv_map(TP const &y) const$/;"	f	struct:simpla::mesh::GeneralMap
inv_map	core/manifold/mesh/GeneralMap.h	/^    point_type *inv_map(point_type *x) const$/;"	f	struct:simpla::mesh::SquareMap
inv_map	core/manifold/mesh/GeneralMap.h	/^    point_type inv_map(U const &y) const$/;"	f	struct:simpla::mesh::SquareMap
inv_map	core/manifold/mesh/LinearMap.h	/^    point_type inv_map(point_type const &x) const$/;"	f	struct:simpla::mesh::LinearMap
inv_map	core/manifold/mesh/MeshBlock.h	/^    point_type inv_map(point_type const &x) const$/;"	f	struct:simpla::mesh::MeshBlock
inv_volume	core/manifold/mesh/CartesianCoRect.h	/^    virtual Real inv_volume(id_type s) const { return m_inv_volume_[node_id(s)]; }$/;"	f	struct:simpla::mesh::CartesianCoRect
inv_volume	core/manifold/mesh/CoRectMesh.h	/^    virtual Real inv_volume(id_type s) const { return m_inv_volume_[node_id(s)]; }$/;"	f	struct:simpla::mesh::Mesh
inv_volume	core/manifold/mesh/CylindricalCoRect.h	/^    virtual Real inv_volume(id_type s) const$/;"	f	class:simpla::mesh::CylindricalCoRect
inv_volume	core/manifold/mesh/RectMesh.h	/^    virtual Real inv_volume(id_type s) const$/;"	f	struct:simpla::mesh::Mesh
inverse_rotate	core/manifold/mesh/MeshIds.h	/^    static constexpr id_type inverse_rotate(id_type const &s)$/;"	f	struct:simpla::mesh::MeshEntityIdCoder
io	core/io/HDF5Stream.cpp	/^namespace simpla { namespace io$/;"	n	namespace:simpla	file:
io	core/io/HDF5Stream.h	/^namespace simpla { namespace io$/;"	n	namespace:simpla
io	core/io/IO.cpp	/^namespace simpla { namespace io$/;"	n	namespace:simpla	file:
io	core/io/IO.h	/^namespace simpla { namespace io$/;"	n	namespace:simpla
io	core/io/IOStream.cpp	/^namespace simpla { namespace io$/;"	n	namespace:simpla	file:
io	core/io/IOStream.h	/^namespace simpla { namespace io$/;"	n	namespace:simpla
io	core/io/WriteBuffer.cpp	/^namespace simpla { namespace io$/;"	n	namespace:simpla	file:
io	core/io/WriteBuffer.h	/^namespace simpla { namespace io$/;"	n	namespace:simpla
io	core/io/XDMFIO.cpp	/^namespace simpla { namespace io$/;"	n	namespace:simpla	file:
io	core/io/XDMFIO.h	/^namespace io$/;"	n	namespace:simpla
io	core/io/XDMFStream.cpp	/^namespace simpla { namespace io$/;"	n	namespace:simpla	file:
io	core/io/XDMFStream.h	/^namespace simpla { namespace io$/;"	n	namespace:simpla
io	core/io/xdmf_stream_samr.h	/^namespace simpla { namespace io$/;"	n	namespace:simpla
io_policy	core/manifold/policy/IOPolicy.h	/^    typedef this_type io_policy;$/;"	t	struct:simpla::manifold::policy::IOPolicy
ip	core/numeric/sobol_engine.h	/^	const result_type ip[MAXDIM] = \/\/MAXDIM$/;"	m	class:simpla::sobol_engine
isField	core/field/FieldTraits.h	/^struct isField : public std::integral_constant<bool, false>$/;"	s	namespace:simpla::traits
isField	core/field/FieldTraits.h	/^struct isField<Field<T...>> : public std::integral_constant<$/;"	s	namespace:simpla::traits
is_a	core/base/Attribute.h	/^    virtual bool is_a(std::type_info const &info) const { return typeid(this_type) == info || base_type::is_a(info); }$/;"	f	class:simpla::base::Attribute
is_a	core/base/Attribute.h	/^    virtual bool is_a(std::type_info const &info) const$/;"	f	class:simpla::base::AttributeEntity
is_a	core/base/Object.cpp	/^bool Object::is_a(std::type_info const &info) const { return typeid(Object) == info; }$/;"	f	class:simpla::base::Object
is_a	core/manifold/Manifold.h	/^    virtual bool is_a(std::type_info const &info) const { return typeid(this_type) == info || TMesh::is_a(info); }$/;"	f	class:simpla::Manifold
is_arithmetic_scalar	core/gtl/complex.h	/^struct is_arithmetic_scalar<std::complex<T>>$/;"	s	namespace:simpla
is_arithmetic_scalar	core/gtl/primitives.h	/^struct is_arithmetic_scalar$/;"	s	namespace:simpla
is_arithmetic_scalar	core/gtl/sp_complex.h	/^struct is_arithmetic_scalar<std::complex<T>>$/;"	s	namespace:simpla
is_array	core/data_model/DataType.cpp	/^bool DataType::is_array() const$/;"	f	class:simpla::data_model::DataType
is_associative_container	core/gtl/containers/container_traits.h	/^	static constexpr bool is_associative_container = false;$/;"	m	struct:simpla::container_traits
is_associative_container	core/gtl/containers/container_traits.h	/^	static constexpr bool is_associative_container = true;$/;"	m	struct:simpla::container_traits
is_bool	core/gtl/any.h	/^    virtual bool is_bool() const { return std::is_convertible<T, bool>::value; }$/;"	f	struct:simpla::Derived
is_boolean	core/gtl/any.h	/^    bool is_boolean() const { return ptr_ != nullptr && ptr_->is_bool(); }$/;"	f	struct:simpla::any
is_cached	core/gtl/cache.h	/^bool is_cached(T && first, Args && ...args)$/;"	f	namespace:simpla
is_cached	core/gtl/cache.h	/^constexpr bool is_cached(Cache<T> &&)$/;"	f	namespace:simpla
is_callable	core/gtl/check_concept.h	/^struct is_callable$/;"	s	namespace:simpla::traits
is_callable	core/gtl/concept_check.h	/^struct is_callable$/;"	s	namespace:simpla
is_callable	core/gtl/utilities/lua_object.h	/^struct is_callable<lua::LuaObject, Args ...>$/;"	s	namespace:simpla::check
is_chains	core/geometry/chains.h	/^struct is_chains<model::Chains<Others...>>$/;"	s	namespace:simpla::geometry::traits
is_chains	core/geometry/primitive.h	/^struct is_chains<model::Primitive<Dimension, Others...>>$/;"	s	namespace:simpla::geometry::traits
is_commited_	core/parallel/MPIDataType.h	/^    bool is_commited_ = false;$/;"	m	struct:simpla::MPIDataType
is_complex	core/gtl/complex.h	/^template<typename > struct is_complex$/;"	s	namespace:simpla
is_complex	core/gtl/complex.h	/^template<typename T> struct is_complex<std::complex<T> >$/;"	s	namespace:simpla
is_complex	core/gtl/sp_complex.h	/^template<typename > struct is_complex$/;"	s	namespace:simpla
is_complex	core/gtl/sp_complex.h	/^template<typename T> struct is_complex<std::complex<T> >$/;"	s	namespace:simpla
is_compound	core/data_model/DataType.cpp	/^bool DataType::is_compound() const$/;"	f	class:simpla::data_model::DataType
is_dense_storage	core/gtl/containers/container_dense.h	/^	static constexpr bool is_dense_storage = true;$/;"	m	class:simpla::DenseContainer
is_dense_storage	core/gtl/containers/container_sparse.h	/^    static constexpr bool is_dense_storage = false;$/;"	m	class:simpla::SparseContainer
is_divisable	core/gtl/iterator/sp_ntuple_range.h	/^    bool is_divisable() const$/;"	f	struct:simpla::sp_nTuple_range
is_divisible	core/field/obsoleted/field_sparse.h	/^	bool is_divisible() const$/;"	f	struct:simpla::Field
is_divisible	core/field/test/trash/field_continue.h	/^	bool is_divisible() const$/;"	f	struct:simpla::Field
is_divisible	core/gtl/array_view.h	/^    bool is_divisible() const { return m_count_ > m_grain_size_; }$/;"	f	class:simpla::gtl::ArrayView
is_divisible	core/gtl/containers/unordered_set.h	/^    bool is_divisible() const$/;"	f	class:simpla::UnorderedSet
is_divisible	core/gtl/iterator/range.h	/^    bool is_divisible() const { return size() > grainsize(); }$/;"	f	class:simpla::Range
is_divisible	core/gtl/iterator/sp_indirect_iterator.h	/^    constexpr bool is_divisible() const$/;"	f	struct:simpla::sp_indirect_range
is_divisible	core/gtl/range/block_range.h	/^    bool is_divisible() const { return size() > grainsize(); }$/;"	f	class:simpla::BlockRange
is_divisible	core/manifold/mesh/MeshIds.h	/^        bool is_divisible() const$/;"	f	struct:simpla::mesh::MeshEntityIdCoder::range_type
is_divisible	core/parallel/obsoleted/blocked_range.h	/^	bool is_divisible() const$/;"	f	struct:simpla::BlockedRange
is_divisible	core/particle/obsolete/probe_particle.h	/^    bool is_divisible() const$/;"	f	struct:simpla::ProbeParticle
is_empty	core/gtl/containers/container_traits.h	/^	static bool is_empty(container_type const& that)$/;"	f	struct:simpla::container_traits
is_equal	core/data_model/DataSet.cpp	/^bool DataSet::is_equal(void const *other) const$/;"	f	class:simpla::data_model::DataSet
is_expression	core/gtl/primitives.h	/^struct is_expression$/;"	s	namespace:simpla
is_expresson	core/gtl/expression_template.h	/^struct is_expresson$/;"	s	namespace:simpla::traits
is_expresson	core/gtl/expression_template.h	/^struct is_expresson<Expression<T...> >$/;"	s	namespace:simpla::traits
is_expresson	core/gtl/expression_template.h	/^struct is_expresson<F<Expression<T...> > >$/;"	s	namespace:simpla::traits
is_floating_point	core/gtl/any.h	/^    bool is_floating_point() const { return ptr_ != nullptr && ptr_->is_floating_point(); }$/;"	f	struct:simpla::any
is_floating_point	core/gtl/any.h	/^    virtual bool is_floating_point() const { return std::is_convertible<T, double>::value; }$/;"	f	struct:simpla::Derived
is_floating_point	core/gtl/utilities/lua_object.cpp	/^bool LuaObject::is_floating_point() const { return is_number()&&(!is_integer); }$/;"	f	class:simpla::lua::LuaObject
is_full	core/data_model/DataSpace.cpp	/^bool DataSpace::is_full() const { return size() == num_of_elements(); }$/;"	f	class:simpla::data_model::DataSpace
is_geometry	core/manifold/ManifoldTraits.h	/^template<typename T> struct is_geometry : public std::integral_constant<bool, false>$/;"	s	namespace:simpla::traits
is_global	core/gtl/utilities/lua_object.h	/^    bool is_global() const { return !L_.empty() && self_ == -1; }$/;"	f	class:simpla::lua::LuaObject
is_homogeneous	core/geometry/CoordinateSystem.h	/^struct is_homogeneous<coordinate_system::MagneticFLux>$/;"	s	namespace:simpla::geometry::traits
is_homogeneous	core/geometry/CoordinateSystem.h	/^template<> struct is_homogeneous<coordinate_system::Toroidal>$/;"	s	namespace:simpla::geometry::traits
is_homogeneous	core/geometry/CoordinateSystem.h	/^template<typename CS> struct is_homogeneous$/;"	s	namespace:simpla::geometry::traits
is_implicit	applications/particle_solver/fluid_cold_engine.h	/^	bool is_implicit() const$/;"	f	class:simpla::Particle
is_implicit	applications/particle_solver/pic_engine_implicit.h	/^		is_implicit = true$/;"	e	enum:simpla::PICEngineImplicit::__anon13
is_implicit_	applications/particle_solver/fluid_cold_engine.h	/^		is_implicit_ = true$/;"	e	enum:simpla::Particle::__anon12
is_indexable	core/gtl/check_concept.h	/^struct is_indexable$/;"	s	namespace:simpla::traits
is_indexable	core/gtl/concept_check.h	/^struct is_indexable$/;"	s	namespace:simpla
is_indexable	core/gtl/utilities/lua_object.h	/^struct is_indexable<lua::LuaObject, Other>$/;"	s	namespace:simpla::check
is_inside	core/model/obsoleted/revolve_polygon.h	/^    virtual int is_inside(point_type const &p) const$/;"	f	struct:simpla::RevolvePolygon
is_integer	core/gtl/utilities/lua_object.cpp	/^bool LuaObject::is_integer() const$/;"	f	class:simpla::lua::LuaObject
is_integral	core/gtl/any.h	/^    bool is_integral() const { return ptr_ != nullptr && ptr_->is_integral(); }$/;"	f	struct:simpla::any
is_integral	core/gtl/any.h	/^    virtual bool is_integral() const { return std::is_convertible<T, int>::value; }$/;"	f	struct:simpla::Derived
is_iterator	core/gtl/check_concept.h	/^struct is_iterator$/;"	s	namespace:simpla::traits
is_list	core/gtl/utilities/lua_object.cpp	/^bool LuaObject::is_list() const$/;"	f	class:simpla::lua::LuaObject
is_loaded_	applications/field_solver/pml.h	/^	bool is_loaded_;$/;"	m	class:simpla::PML
is_manifold	core/manifold/ManifoldTraits.h	/^struct is_manifold : public std::integral_constant<bool, false>$/;"	s	namespace:simpla::traits
is_manifold	core/manifold/ManifoldTraits.h	/^struct is_manifold<Manifold<TMesh, Policies...>> : public std::integral_constant<bool, true>$/;"	s	namespace:simpla::traits
is_markov_chain	core/particle/obsolete/probe_particle.h	/^    static constexpr bool is_markov_chain = (check_member_value_memory_length<engine_type>::value == 0);$/;"	m	struct:simpla::ProbeParticle
is_nTuple	core/gtl/utilities/lua_object.cpp	/^bool LuaObject::is_nTuple() const$/;"	f	class:simpla::lua::LuaObject
is_ntuple	core/gtl/ntuple.h	/^struct is_ntuple$/;"	s	namespace:simpla::traits
is_ntuple	core/gtl/ntuple.h	/^struct is_ntuple<nTuple<T, N...>>$/;"	s	namespace:simpla::traits
is_null	core/gtl/iterator/sp_ntuple_range.h	/^    bool is_null() const$/;"	f	struct:simpla::sp_nTuple_range
is_null	core/gtl/utilities/lua_object.h	/^    inline bool is_null() const { return L_.empty(); }$/;"	f	class:simpla::lua::LuaObject
is_number	core/gtl/utilities/lua_object.cpp	/^bool LuaObject::is_number() const$/;"	f	class:simpla::lua::LuaObject
is_opaque	core/data_model/DataType.cpp	/^bool DataType::is_opaque() const$/;"	f	class:simpla::data_model::DataType
is_opened	core/io/HDF5Stream.cpp	/^bool HDF5Stream::is_opened() const$/;"	f	class:simpla::io::HDF5Stream
is_opened_	core/gtl/utilities/log.cpp	/^    bool is_opened_ = false;$/;"	m	struct:simpla::logger::LoggerStreams	file:
is_periodic	core/manifold/mesh/MeshBlock.h	/^    bool is_periodic(int n) const { return m_ghost_width_[n % 3] == 0; }$/;"	f	struct:simpla::mesh::MeshBlock
is_primitive	core/geometry/chains.h	/^struct is_primitive<model::Chains<Others...>>$/;"	s	namespace:simpla::geometry::traits
is_primitive	core/geometry/primitive.h	/^struct is_primitive<model::Primitive<Dimension, Others...>>$/;"	s	namespace:simpla::geometry::traits
is_primitive	core/gtl/primitives.h	/^struct is_primitive$/;"	s	namespace:simpla
is_ready	core/parallel/DistributedObject.cpp	/^bool DistributedObject::is_ready() const$/;"	f	class:simpla::parallel::DistributedObject
is_ready	core/parallel/obsoleted/parallel_traits.h	/^template<typename ...T> bool is_ready(T &&...) { return true; }$/;"	f	namespace:simpla::parallel
is_ready	core/parallel/trash/distributed_unordered_set.cpp	/^bool DistributedUnorderedSetBase::is_ready() const$/;"	f	class:simpla::DistributedUnorderedSetBase
is_real	core/gtl/primitives.h	/^template<> struct is_real<Real>$/;"	s	namespace:simpla
is_real	core/gtl/primitives.h	/^template<typename> struct is_real$/;"	s	namespace:simpla
is_root	core/gtl/enable_create_from_this.h	/^	bool is_root() const$/;"	f	struct:simpla::enable_create_from_this
is_same	core/data_model/DataSet.cpp	/^bool DataSet::is_same(void const *other) const$/;"	f	class:simpla::data_model::DataSet
is_same	core/data_model/DataType.cpp	/^bool DataType::is_same(std::type_index const &other) const$/;"	f	class:simpla::data_model::DataType
is_same	core/data_model/DataType.h	/^    template<typename T> bool is_same() const { return is_same(std::type_index(typeid(T))); }$/;"	f	struct:simpla::data_model::DataType
is_same	core/gtl/any.h	/^    bool is_same(std::type_index const &t_idx) const { return std::type_index(typeid(T)) == t_idx; }$/;"	f	struct:simpla::Derived
is_same	core/gtl/any.h	/^    template<class U> bool is_same() const { return ptr_ != nullptr && ptr_->is_same<U>(); }$/;"	f	struct:simpla::any
is_same	core/gtl/any.h	/^    template<typename T> bool is_same() const { return is_same(std::type_index(typeid(T))); }$/;"	f	struct:simpla::Base
is_same	core/gtl/containers/container_traits.h	/^	static bool is_same(container_type const& lhs, container_type const& rhs)$/;"	f	struct:simpla::container_traits
is_same	core/gtl/iterator/sp_iterator_index_base.h	/^	virtual bool is_same(this_type const& rhs) const$/;"	f	class:simpla::Iterator
is_shared_ptr	core/gtl/check_concept.h	/^struct is_shared_ptr$/;"	s	namespace:simpla::traits
is_shared_ptr	core/gtl/check_concept.h	/^struct is_shared_ptr<const std::shared_ptr<T>>$/;"	s	namespace:simpla::traits
is_shared_ptr	core/gtl/check_concept.h	/^struct is_shared_ptr<std::shared_ptr<T>>$/;"	s	namespace:simpla::traits
is_simple	core/data_model/DataSpace.cpp	/^bool DataSpace::is_simple() const$/;"	f	class:simpla::data_model::DataSpace
is_slow_first	core/gtl/iterator/sp_ntuple_range.h	/^    bool is_slow_first() const$/;"	f	struct:simpla::sp_nTuple_range
is_slow_first	core/gtl/iterator/sp_ntuple_range.h	/^    void is_slow_first(bool slow_first)$/;"	f	struct:simpla::sp_nTuple_range
is_splittable_in_proportion	core/gtl/array_view.h	/^    static const bool is_splittable_in_proportion = true;$/;"	m	class:simpla::gtl::ArrayView
is_splittable_in_proportion	core/gtl/iterator/range.h	/^    static const bool is_splittable_in_proportion = true;$/;"	m	class:simpla::Range
is_splittable_in_proportion	core/gtl/iterator/sp_indirect_iterator.h	/^    static bool is_splittable_in_proportion()$/;"	f	struct:simpla::sp_indirect_range
is_splittable_in_proportion	core/gtl/range/block_range.h	/^    static const bool is_splittable_in_proportion = true;$/;"	m	class:simpla::BlockRange
is_splittable_in_proportion	core/manifold/mesh/MeshIds.h	/^        static const bool is_splittable_in_proportion = true;$/;"	m	struct:simpla::mesh::MeshEntityIdCoder::range_type
is_string	core/gtl/any.h	/^    bool is_string() const { return ptr_ != nullptr && ptr_->is_string(); }$/;"	f	struct:simpla::any
is_string	core/gtl/any.h	/^    virtual bool is_string() const { return std::is_convertible<T, std::string>::value; }$/;"	f	struct:simpla::Derived
is_string	core/gtl/utilities/lua_object.cpp	/^bool LuaObject::is_string() const$/;"	f	class:simpla::lua::LuaObject
is_structed	core/geometry/chains.h	/^struct is_structed<model::Chains<PrimitiveType, Others...>>$/;"	s	namespace:simpla::geometry::traits
is_table	core/gtl/utilities/lua_object.cpp	/^    if (this->is_table())$/;"	f	namespace:simpla::lua::_impl
is_valid	core/data_model/DataSet.h	/^    bool is_valid() const$/;"	f	struct:simpla::data_model::DataSet
is_valid	core/data_model/DataSpace.cpp	/^bool DataSpace::is_valid() const$/;"	f	class:simpla::data_model::DataSpace
is_valid	core/data_model/DataType.cpp	/^bool DataType::is_valid() const$/;"	f	class:simpla::data_model::DataType
is_valid	core/field/FieldFunction.h	/^    bool is_valid() const { return (!!m_fun_); }$/;"	f	class:simpla::Field
is_valid	core/io/HDF5Stream.cpp	/^bool HDF5Stream::is_valid() const$/;"	f	class:simpla::io::HDF5Stream
is_valid	core/manifold/mesh/RectMesh.h	/^    bool is_valid() const { return m_is_valid_; }$/;"	f	struct:simpla::mesh::Mesh
is_valid	core/parallel/MPIComm.cpp	/^bool MPIComm::is_valid() const$/;"	f	class:simpla::parallel::MPIComm
is_valid_	core/model/GEqdsk.cpp	/^    bool is_valid_ = false;$/;"	m	struct:simpla::GEqdsk::pimpl_s	file:
iterator	applications/particle_solver/fluid_cold_engine.h	/^	typedef typename mesh_type::iterator iterator;$/;"	t	class:simpla::Particle
iterator	core/field/test/field_io_test.h	/^	typedef typename mesh_type::iterator iterator;$/;"	t	class:simpla::TestFieldIO
iterator	core/field/test/trash/fetl_test3.h	/^	typedef typename manifold_type::iterator iterator;$/;"	t	class:TestFETL
iterator	core/gtl/array_view.h	/^    iterator(ArrayViewBase &d, size_t const *idx = nullptr) : m_data_(d)$/;"	f	struct:simpla::gtl::ArrayView::iterator
iterator	core/gtl/array_view.h	/^    iterator(iterator &&other) : m_data_(other.m_data_), m_idx_(other.m_idx_) { }$/;"	f	struct:simpla::gtl::ArrayView::iterator
iterator	core/gtl/array_view.h	/^    iterator(iterator const &other) : m_data_(other.m_data_), m_idx_(other.m_idx_) { }$/;"	f	struct:simpla::gtl::ArrayView::iterator
iterator	core/gtl/array_view.h	/^    struct const iterator;$/;"	m	class:simpla::gtl::ArrayView
iterator	core/gtl/array_view.h	/^struct ArrayView<T>::iterator : public std::iterator<typename std::random_access_iterator_tag, value_type, ptrdiff_t>$/;"	s	class:simpla::gtl::ArrayView
iterator	core/gtl/containers/sp_indirect_container.h	/^	typedef indirect_iterator<const_key_iterator, value_conatinaer_type> iterator;$/;"	t	struct:simpla::indirect_container
iterator	core/gtl/containers/unordered_set.h	/^    typedef typename base_container_type::iterator iterator;$/;"	t	class:simpla::UnorderedSet
iterator	core/gtl/design_pattern/factory.h	/^	typedef typename CallbackMap::iterator iterator;$/;"	t	struct:simpla::Factory
iterator	core/gtl/design_pattern/signal.h	/^    typedef typename std::list<Slot>::iterator iterator;$/;"	t	struct:simpla::Signal
iterator	core/gtl/iterator/iterator.h	/^	typedef simpla::Iterator<TI, TPred> iterator;$/;"	t	struct:std::iterator_traits
iterator	core/gtl/iterator/iterator_cycle.h	/^	typedef iterator_cycle<base_iterator> iterator;$/;"	t	struct:simpla::iterator_cycle
iterator	core/gtl/iterator/sp_indirect_iterator.h	/^    typedef sp_indirect_iterator<key_iterator, value_container_type, Hasher> iterator;$/;"	t	struct:simpla::sp_indirect_range
iterator	core/gtl/iterator/sp_ntuple_range.h	/^    iterator(T1 const &min, T2 const &max, T3 const &s, bool slow_first = true)$/;"	f	struct:simpla::sp_nTuple_range::iterator
iterator	core/gtl/iterator/sp_ntuple_range.h	/^    iterator(iterator &&other) :$/;"	f	struct:simpla::sp_nTuple_range::iterator
iterator	core/gtl/iterator/sp_ntuple_range.h	/^    iterator(iterator const &other) :$/;"	f	struct:simpla::sp_nTuple_range::iterator
iterator	core/gtl/iterator/sp_ntuple_range.h	/^struct sp_nTuple_range<IndexType, DIMS...>::iterator : public std::iterator<$/;"	s	class:simpla::sp_nTuple_range
iterator	core/gtl/iterator/sp_range_filter.h	/^	typedef Iterator<base_iterator, pred_function, _iterator_policy_filter, true> iterator;$/;"	t	struct:simpla::FilterRange
iterator	core/gtl/utilities/lua_object.cpp	/^LuaObject::iterator::iterator() :$/;"	f	class:simpla::lua::LuaObject::iterator
iterator	core/gtl/utilities/lua_object.cpp	/^LuaObject::iterator::iterator(LuaState L, unsigned int G, unsigned int p, std::string path) :$/;"	f	class:simpla::lua::LuaObject::iterator
iterator	core/gtl/utilities/lua_object.cpp	/^LuaObject::iterator::iterator(iterator &&r) :$/;"	f	class:simpla::lua::LuaObject::iterator
iterator	core/gtl/utilities/lua_object.cpp	/^LuaObject::iterator::iterator(iterator const &r) :$/;"	f	class:simpla::lua::LuaObject::iterator
iterator	core/gtl/utilities/lua_object.h	/^    class iterator$/;"	c	class:simpla::lua::LuaObject
iterator	core/manifold/mesh/MeshIds.h	/^        iterator() : base_type(), m_iform_(VERTEX) { }$/;"	f	struct:simpla::mesh::MeshEntityIdCoder::iterator
iterator	core/manifold/mesh/MeshIds.h	/^        iterator(T0 const &pself, T1 const &pmin, T2 const &pmax, int IFORM = VERTEX) :$/;"	f	struct:simpla::mesh::MeshEntityIdCoder::iterator
iterator	core/manifold/mesh/MeshIds.h	/^        iterator(base_type const &other, int IFORM) : base_type(other), m_iform_(IFORM)$/;"	f	struct:simpla::mesh::MeshEntityIdCoder::iterator
iterator	core/manifold/mesh/MeshIds.h	/^        iterator(id_type s, id_type b, id_type e)$/;"	f	struct:simpla::mesh::MeshEntityIdCoder::iterator
iterator	core/manifold/mesh/MeshIds.h	/^        iterator(iterator &&other) : base_type(other), m_iform_(other.m_iform_)$/;"	f	struct:simpla::mesh::MeshEntityIdCoder::iterator
iterator	core/manifold/mesh/MeshIds.h	/^        iterator(iterator const &other) : base_type(other), m_iform_(other.m_iform_)$/;"	f	struct:simpla::mesh::MeshEntityIdCoder::iterator
iterator	core/manifold/mesh/MeshIds.h	/^    struct iterator : public block_iterator<index_type, ndims + 1>$/;"	s	struct:simpla::mesh::MeshEntityIdCoder
iterator	core/manifold/obsoleted/patch/mesh_patch.h	/^    typedef typename std::map<size_t, std::shared_ptr<AttributeBase>>::iterator iterator;$/;"	t	class:simpla::mesh::MeshPatch
iterator	core/numeric/interpolation.h	/^    typedef typename container_type::iterator iterator;$/;"	t	class:simpla::Interpolation
iterator	core/parallel/obsoleted/blocked_range.h	/^	iterator(iterator && r) :$/;"	f	struct:simpla::iterator
iterator	core/parallel/obsoleted/blocked_range.h	/^	iterator(iterator const & r) :$/;"	f	struct:simpla::iterator
iterator	core/parallel/obsoleted/blocked_range.h	/^	iterator(nTuple<index_type, ndims> const & b,$/;"	f	struct:simpla::iterator
iterator	core/parallel/obsoleted/blocked_range.h	/^	typedef typename RectMesh::iterator iterator;$/;"	t	struct:simpla::range
iterator	core/parallel/obsoleted/blocked_range.h	/^struct iterator$/;"	s	namespace:simpla
iterator_category	core/gtl/iterator/iterator.h	/^	typedef typename iterator::iterator_category iterator_category;$/;"	t	struct:std::iterator_traits
iterator_category	core/gtl/iterator/sp_iterator_mapped.h	/^	typedef typename key_iterator::iterator_category iterator_category;$/;"	t	struct:simpla::Iterator
iterator_category	core/gtl/iterator/sp_iterator_shared_container.h	/^	typedef typename std::iterator_traits<key_iterator_type>::iterator_category iterator_category;$/;"	t	class:simpla::TransformIterator
iterator_category	core/parallel/obsoleted/blocked_range.h	/^	typedef std::bidirectional_iterator_tag iterator_category;$/;"	t	struct:simpla::iterator
iterator_cycle	core/gtl/iterator/iterator_cycle.h	/^	iterator_cycle(base_iterator p, size_t tail = 0, size_t l = 1) :$/;"	f	struct:simpla::iterator_cycle
iterator_cycle	core/gtl/iterator/iterator_cycle.h	/^struct iterator_cycle$/;"	s	namespace:simpla
iterator_proxy	core/gtl/containers/iterator_proxy.h	/^	iterator_proxy(const iterator_proxy &other) : base_iterator(other), m_data_(other.m_data_)$/;"	f	struct:simpla::iterator_proxy
iterator_proxy	core/gtl/containers/iterator_proxy.h	/^	iterator_proxy(this_type &d, base_iterator &it) :$/;"	f	struct:simpla::iterator_proxy
iterator_proxy	core/gtl/containers/iterator_proxy.h	/^struct iterator_proxy : public TIterator$/;"	s	namespace:simpla
iterator_traits	core/gtl/iterator/iterator.h	/^struct iterator_traits<simpla::Iterator<TI, TPred, Policy>>$/;"	s	namespace:std
iu	core/numeric/sobol_engine.h	/^	result_type* iu[MAXBIT];$/;"	m	class:simpla::sobol_engine
iv	core/numeric/sobol_engine.h	/^	result_type iv[MAXDIM * MAXBIT] = \/\/MAXDIM*MAXBIT$/;"	m	class:simpla::sobol_engine
ix	core/numeric/sobol_engine.h	/^	result_type ix[MAXDIM];$/;"	m	class:simpla::sobol_engine
join_ntuple	core/gtl/ntuple.h	/^nTuple<T1, N + M> join_ntuple(nTuple<T1, N> const &left, nTuple<T2, M> right)$/;"	f	namespace:simpla::traits
join_ntuple	core/gtl/ntuple.h	/^nTuple<TV, N + 1> join_ntuple(nTuple<TV, N> const &left, T2 right)$/;"	f	namespace:simpla::traits
k	core/field/test/field_io_test.h	/^	static constexpr nTuple<3, Real> k =$/;"	m	class:simpla::TestFieldIO
k_it_	core/gtl/iterator/sp_iterator_mapped.h	/^	key_iterator k_it_, k_it_end_;$/;"	m	struct:simpla::Iterator
k_it_	core/gtl/iterator/sp_iterator_mapped.h	/^	key_iterator k_it_;$/;"	m	struct:simpla::Iterator
k_it_	core/gtl/iterator/sp_iterator_shared_container.h	/^	key_iterator_type k_it_;$/;"	m	class:simpla::TransformIterator
k_it_end_	core/gtl/iterator/sp_iterator_mapped.h	/^	key_iterator k_it_, k_it_end_;$/;"	m	struct:simpla::Iterator
key_	core/gtl/utilities/lua_object.h	/^        int key_;$/;"	m	class:simpla::lua::LuaObject::iterator
key_conatinaer_type	core/gtl/containers/sp_indirect_container.h	/^	typedef KeyContainer key_conatinaer_type;$/;"	t	struct:simpla::indirect_container
key_iterator	core/gtl/iterator/sp_indirect_iterator.h	/^    typedef typename key_range_type::iterator key_iterator;$/;"	t	struct:simpla::sp_indirect_range
key_iterator	core/gtl/iterator/sp_iterator_mapped.h	/^	typedef TIterator key_iterator;$/;"	t	struct:simpla::Iterator
key_iterator_type	core/gtl/iterator/sp_iterator_shared_container.h	/^	typedef TKey key_iterator_type;$/;"	t	class:simpla::TransformIterator
key_range_type	core/gtl/iterator/sp_indirect_iterator.h	/^    typedef KeyRange key_range_type;$/;"	t	struct:simpla::sp_indirect_range
key_type	core/field/FieldTraits.h	/^struct key_type<Field<T ...> >$/;"	s	namespace:simpla::traits
key_type	core/gtl/Properties.h	/^    typedef std::string key_type;$/;"	t	class:simpla::Properties
key_type	core/gtl/containers/UnorderedSet.h	/^    typedef Key key_type;$/;"	t	class:simpla::gtl::UnorderedSet
key_type	core/gtl/containers/container_container.h	/^	typedef TKey key_type;$/;"	t	class:simpla::ContainerContainer
key_type	core/gtl/containers/container_dense.h	/^	typedef TKey key_type;$/;"	t	class:simpla::DenseContainer
key_type	core/gtl/containers/container_sparse.h	/^    typedef TI key_type;$/;"	t	class:simpla::SparseContainer
key_type	core/gtl/containers/container_traits.h	/^	typedef typename TContainer::key_type key_type;$/;"	t	struct:simpla::container_traits
key_type	core/gtl/containers/sp_hash_container.h	/^	typedef Key key_type;$/;"	t	struct:simpla::SpHashContainer
key_type	core/gtl/containers/sp_indirect_container.h	/^	typedef typename key_conatinaer_type::value_type key_type;$/;"	t	struct:simpla::indirect_container
key_type	core/gtl/containers/unordered_set.h	/^    typedef BucketKeyType key_type;$/;"	t	class:simpla::UnorderedSet
key_type	core/gtl/function_cache.h	/^	typedef size_t key_type;$/;"	t	struct:simpla::FunctionCache
key_type	core/gtl/iterator/sp_indirect_iterator.h	/^    typedef typename std::iterator_traits<BaseIterator>::value_type key_type;$/;"	t	struct:simpla::sp_indirect_iterator
key_type	core/gtl/ntuple.h	/^struct key_type<nTuple<T, N...>>$/;"	s	namespace:simpla::traits
key_type	core/gtl/type_traits.h	/^template<typename T> struct key_type$/;"	s	namespace:simpla::traits
key_words	example/mhd/demo_mhd.cpp	/^static constexpr char key_words[] = "Cylindrical BaseManifold, Uniform Grid, single toridal model number  ";$/;"	v	file:
key_x_type	core/numeric/interpolation.h	/^    typedef TX key_x_type;$/;"	t	class:simpla::Interpolation
kg_	core/physics/PhysicalConstants.h	/^    double kg_; \/\/<< mass	[kilgram]$/;"	m	class:simpla::PhysicalConstants
ksp_cg	core/numeric/ksp_cg.h	/^void ksp_cg(Field <TM, IFORM, F1> const &Ax, Field <TM, IFORM, F3> &x, size_t max_iterative_num = 1000,$/;"	f	namespace:simpla::linear_solver
l_	core/numeric/rectangle_distribution.h	/^    nTuple<double, NDIMS> l_;$/;"	m	class:simpla::rectangle_distribution
l_type	core/geometry/primitive.h	/^    typedef typename length_type<CS>::type l_type;$/;"	t	struct:simpla::geometry::traits::area_type
l_type	core/geometry/primitive.h	/^    typedef typename length_type<CS>::type l_type;$/;"	t	struct:simpla::geometry::traits::volume_type
label2idx	plugins/vtk_reader/vtkAMRSimPlaReader.h	/^    std::map<std::string, int> label2idx;$/;"	m	class:vtkAMRSimPlaReader
left	core/parallel/ParallelDummy.h	/^    size_t left() { return m_left_; }$/;"	f	struct:simpla::serial::tags::proportional_split
left_action	core/manifold/mesh/GeneralMap.h	/^    typedef LEFT left_action;$/;"	t	struct:simpla::mesh::GeneralMap
left_of	core/geometry/obsolete/polygons.h	/^int left_of(vec a, vec b, vec c)$/;"	f
len	core/geometry/obsolete/polygons.h	/^	int len, alloc;$/;"	m	struct:__anon2
length	core/geometry/cube.h	/^typename traits::length_type<CS>::type length($/;"	f	namespace:simpla::geometry
length	core/geometry/simplex.h	/^typename traits::length_type<CS>::type length($/;"	f	namespace:simpla::geometry
length_	core/gtl/iterator/iterator_cycle.h	/^	size_t shift_ = 0, length_ = 1;$/;"	m	struct:simpla::iterator_cycle
length_type	core/geometry/model.h	/^	typedef typename traits::length_type<CS>::type length_type;$/;"	t	struct:simpla::geometry::model::Primitive
lhs	core/gtl/expression_template.h	/^    TL &lhs;$/;"	m	struct:simpla::AssignmentExpression
lift	core/manifold/obsoleted/fiber_bundle.h	/^    inline point_type lift(typename mesh_type::point_type const &x, typename mesh_type::vector_type const &v) const$/;"	f	struct:simpla::manifold::DirectMap
lift	core/particle/ParticleTracker.h	/^    sample_type lift(Args &&...args) const$/;"	f	class:simpla::particle::enable_tracking
lift	core/particle/pre_define/GuidingCenter.h	/^    sample_type lift(point_type const &x, vector_type const &v, Real f = 0) const { return sample_type{x, v, f, 1.0}; }$/;"	f	struct:simpla::particle::engine::GuidingCenterEngine
lift	core/particle/pre_define/GuidingCenter.h	/^    sample_type lift(point_type const &x, vector_type const &v, TFunc const &fun) const$/;"	f	struct:simpla::particle::engine::GuidingCenterEngine
lift	core/particle/pre_define/PICBoris.h	/^    sample_type lift(point_type const &x, vector_type const &v, Real f = 0) const$/;"	f	struct:simpla::particle::engine::BorisEngine
lift	core/particle/pre_define/PICBoris.h	/^    sample_type lift(point_type const &x, vector_type const &v, TFunc const &fun) const$/;"	f	struct:simpla::particle::engine::BorisEngine
lift	core/particle/pre_define/PICGyro.h	/^    sample_type lift(point_type const &x, vector_type const &v, Real f = 0) const$/;"	f	struct:simpla::particle::engine::GyroParticleWithCylindricalCoord
lift	core/particle/test/particle_generator_test.cpp	/^    point_type lift(Vec3 const &x, Vec3 const &v) const$/;"	f	struct:simpla::PICDemo
lift	core/particle/test/particle_generator_test.cpp	/^    point_type lift(std::tuple<Vec3, Vec3> const &z) const$/;"	f	struct:simpla::PICDemo
lift	example/pic/demo_pic.h	/^	inline point_type lift(typename base_manifold::point_type const &x, TV const &v, Real f, Args &&...args) const$/;"	f	struct:simpla::FiberBundle
limiter	core/model/GEqdsk.cpp	/^geometry::GeoObject const &GEqdsk::limiter() const$/;"	f	class:simpla::geometry::GEqdsk
limiter_boundary	core/phy_solver/em_fluid.h	/^    model::Surface<mesh_type> limiter_boundary;$/;"	m	class:simpla::phy_solver::EMFluid
limiter_boundary	example/em_tokamak/tokamak.cpp	/^    model::Surface<mesh_type> limiter_boundary;$/;"	m	struct:simpla::EMTokamak	file:
line_sect	core/geometry/obsolete/polygons.h	/^int line_sect(vec x0, vec x1, vec y0, vec y1, vec res)$/;"	f
line_width_	core/gtl/utilities/log.cpp	/^    int line_width_;$/;"	m	struct:simpla::logger::LoggerStreams	file:
linear_solver	core/numeric/ksp_cg.h	/^namespace linear_solver$/;"	n	namespace:simpla
link_node	core/parallel/obsoleted/distributed_comm.h	/^struct link_node$/;"	s	namespace:simpla::parallel
link_s	core/parallel/DistributedObject.h	/^    typedef std::tuple<nTuple<int, 3>, data_model::DataSet> link_s;$/;"	t	struct:simpla::parallel::DistributedObject
load	applications/contexts/explicit_em.h	/^void ExplicitEMContext<TM>::load(TDict const &dict)$/;"	f	class:simpla::ExplicitEMContext
load	applications/fokker_planck/lhw.cpp	/^	void load()$/;"	f	struct:PICDeltaF
load	applications/particle_solver/fluid_cold_engine.h	/^void Particle<TM, ColdFluid, PolicyFluidParticle>::load(TDict const & dict,$/;"	f	class:simpla::Particle
load	applications/particle_solver/pic_engine_deltaf2.h	/^	void load(TDict const &dict, TN const & n, TT const &T)$/;"	f	struct:simpla::PICEngineDeltaF
load	applications/particle_solver/pic_engine_fullf.h	/^	void load(TDict const & dict)$/;"	f	class:simpla::PICEngineFullF
load	applications/particle_solver/pic_engine_ggauge.h	/^	void load(TDict const & dict, Args const & ...args)$/;"	f	class:simpla::PICEngineGGauge
load	applications/particle_solver/pic_engine_implicit.h	/^	void load(TDict const& dict, Args const & ...args)$/;"	f	struct:simpla::PICEngineImplicit
load	core/geometry/obsolete/polygon.h	/^	void load(TDict const & dict)$/;"	f	struct:simpla::PolyGon
load	core/io/IO.cpp	/^data_model::DataSet load(std::string const &url)$/;"	f	namespace:simpla::io
load	core/manifold/obsoleted/embedded_policy.h	/^    template<typename TDict> void load(TDict const &) { }$/;"	f	struct:simpla::manifold::policy::EmbeddedPolicy
load	core/manifold/obsoleted/time_integrator_policy.h	/^    void load(TDict const &dict)$/;"	f	struct:simpla::manifold::policy::TimeIntegrator
load	core/manifold/policy/IOPolicy.h	/^    template<typename TDict> void load(TDict const &) { }$/;"	f	struct:simpla::manifold::policy::IOPolicy
load	core/manifold/policy/ParallelPolicy.h	/^    template<typename TDict> void load(TDict const &dict) { }$/;"	f	struct:simpla::manifold::policy::ParallelPolicy
load	core/manifold/policy/StoragePolicy.h	/^    template<typename TDict> void load(TDict const &) { }$/;"	f	struct:simpla::manifold::policy::StoragePolicy
load	core/model/GEqdsk.cpp	/^void GEqdsk::load(std::string const &fname)$/;"	f	class:simpla::GEqdsk
load	core/model/GEqdsk.cpp	/^void GEqdsk::pimpl_s::load(std::string const &fname)$/;"	f	class:simpla::GEqdsk::pimpl_s
load	core/particle/obsolete/kinetic_particle.h	/^void KineticParticle<Engine, TDomain>::load(TDict const &dict,$/;"	f	class:KineticParticle
load	core/particle/obsolete/probe_particle.h	/^void ProbeParticle<Engine>::load(TDict const &dict, Others &&...others)$/;"	f	class:simpla::ProbeParticle
load	core/physics/PhysicalConstants.h	/^    void load(TDict const &dict)$/;"	f	class:simpla::PhysicalConstants
loadField	core/field/obsoleted/load_field.h	/^bool loadField(TDict const & dict, TField *f)$/;"	f	namespace:simpla
load_particle	core/particle/obsolete/load_particle.h	/^std::shared_ptr<TP> load_particle(TDict const &dict, TModel const &model,$/;"	f	namespace:simpla
load_particle_constriant	core/particle/obsolete/load_particle.h	/^void load_particle_constriant(TP *p, TRange const &range, TModel const &model,$/;"	f	namespace:simpla
load_profile	core/model/GEqdsk.cpp	/^void GEqdsk::load_profile(std::string const &fname)$/;"	f	class:simpla::GEqdsk
load_profile	core/model/GEqdsk.cpp	/^void GEqdsk::pimpl_s::load_profile(std::string const &fname)$/;"	f	class:simpla::GEqdsk::pimpl_s
load_surface	core/geometry/obsolete/surface.h	/^void Surface<TM>::load_surface(TDict const & dict)$/;"	f	class:simpla::Surface
local_box	core/manifold/mesh/RectMesh.h	/^    box_type local_box() const$/;"	f	struct:simpla::mesh::Mesh
local_index_box	core/manifold/mesh/MeshBlock.h	/^    index_box_type local_index_box() const$/;"	f	struct:simpla::mesh::MeshBlock
local_iterator	core/gtl/containers/unordered_set.h	/^    typedef typename bucket_type::iterator local_iterator;$/;"	t	class:simpla::UnorderedSet
lock	core/base/Object.h	/^    inline void lock() { m_mutex_.lock(); }$/;"	f	class:simpla::base::Object
lock	core/gtl/containers/container_container.h	/^	void lock()$/;"	f	class:simpla::ContainerContainer
lock	core/gtl/containers/container_dense.h	/^	void lock()$/;"	f	class:simpla::DenseContainer
lock	core/gtl/containers/container_sparse.h	/^    void lock()$/;"	f	class:simpla::SparseContainer
locker_	core/gtl/utilities/memory_pool.cpp	/^    std::mutex locker_;$/;"	m	struct:simpla::MemoryPool::pimpl_s	file:
logger	core/gtl/utilities/log.cpp	/^namespace logger$/;"	n	namespace:simpla	file:
logger	core/gtl/utilities/log.h	/^namespace logger$/;"	n	namespace:simpla
logical_or	core/gtl/mpl.h	/^struct logical_or<first, args...> : public std::integral_constant<bool,$/;"	s	namespace:simpla::mpl
logical_or	core/gtl/mpl.h	/^struct logical_or<first, second> : public std::integral_constant<bool,$/;"	s	namespace:simpla::mpl
logical_or	core/gtl/mpl.h	/^struct logical_or<first> : public std::integral_constant<bool, first>::type$/;"	s	namespace:simpla::mpl
lua	core/gtl/utilities/lua_object.cpp	/^namespace lua$/;"	n	namespace:simpla	file:
lua	core/gtl/utilities/lua_object.h	/^namespace simpla { namespace lua$/;"	n	namespace:simpla
lua	core/gtl/utilities/lua_object_ext.h	/^namespace lua$/;"	n	namespace:simpla
lua_s	core/gtl/utilities/lua_object.h	/^            lua_s() : m_state_(luaL_newstate()) { }$/;"	f	struct:simpla::lua::LuaObject::LuaState::lua_s
lua_s	core/gtl/utilities/lua_object.h	/^        struct lua_s$/;"	s	struct:simpla::lua::LuaObject::LuaState
m	applications/fokker_planck/lhw.cpp	/^	Real m;$/;"	m	struct:PICDeltaF	file:
m	applications/particle_solver/fluid_cold_engine.h	/^	const Real m;$/;"	m	class:simpla::Particle
m	applications/particle_solver/pic_engine_deltaf2.h	/^	Real m, cmr_, q, q_k_;$/;"	m	struct:simpla::PICEngineDeltaF
m	applications/particle_solver/pic_engine_ggauge.h	/^	Real m;$/;"	m	class:simpla::PICEngineGGauge
m	applications/particle_solver/pic_engine_implicit.h	/^	Real m;$/;"	m	struct:simpla::PICEngineImplicit
m	core/manifold/Manifold.h	/^    Manifold(this_type const &m) = delete;$/;"	m	class:simpla::Manifold
m	core/manifold/mesh/MeshBlock.h	/^    typedef MeshIDs m;$/;"	t	struct:simpla::mesh::MeshBlock
m	core/manifold/obsoleted/mesh_graph.h	/^    typedef MeshBlock m;$/;"	t	struct:simpla::mesh::MeshMapEdge
m	core/manifold/obsoleted/mesh_graph.h	/^    typedef MeshIDs m;$/;"	t	struct:simpla::mesh::MeshTransform
m	core/phy_solver/em_fluid.h	/^    mesh_type &m;$/;"	m	class:simpla::phy_solver::EMFluid
m	example/em_tokamak/tokamak.cpp	/^    mesh_type m;$/;"	m	struct:simpla::EMTokamak	file:
m0	core/manifold/obsoleted/mesh_graph.h	/^    std::shared_ptr<m> m0, m1;$/;"	m	struct:simpla::mesh::MeshMapEdge
m1	core/manifold/obsoleted/mesh_graph.h	/^    std::shared_ptr<m> m0, m1;$/;"	m	struct:simpla::mesh::MeshMapEdge
m_	applications/particle_solver/pic_engine_fullf.h	/^	Real m_;$/;"	m	class:simpla::PICEngineFullF
m_	core/particle/ParticleContainer.h	/^        mesh_type const *m_;$/;"	m	struct:simpla::particle::ParticleContainer::Hash
m_	core/physics/PhysicalConstants.h	/^    double m_; \/\/<< length [meter]$/;"	m	class:simpla::PhysicalConstants
m_R_	core/geometry/model.h	/^	length_type m_R_;$/;"	m	struct:simpla::geometry::model::Primitive
m_Z_	core/geometry/model.h	/^	vector_type m_Z_;$/;"	m	struct:simpla::geometry::model::Primitive
m_a_	core/geometry/model.h	/^	length_type m_a_;$/;"	m	struct:simpla::geometry::model::Primitive
m_adjacent_cell_matrix_	core/manifold/mesh/MeshIds.h	/^    static constexpr id_type m_adjacent_cell_matrix_[4\/* to iform*\/][NUM_OF_NODE_ID\/* node id*\/][MAX_NUM_OF_ADJACENT_CELL\/*id shift*\/] =$/;"	m	struct:simpla::mesh::MeshEntityIdCoder
m_adjacent_cell_matrix_	core/manifold/mesh/MeshIds.h	/^template<int L> constexpr typename MeshEntityIdCoder<L>::id_type MeshEntityIdCoder<L>::m_adjacent_cell_matrix_[4\/* to iform*\/][NUM_OF_NODE_ID\/* node id*\/][MAX_NUM_OF_ADJACENT_CELL\/*id shift*\/];$/;"	m	class:simpla::mesh::MeshEntityIdCoder
m_adjacent_cell_num_	core/manifold/mesh/MeshIds.h	/^    static constexpr int m_adjacent_cell_num_[4\/* to iform*\/][8\/* node id*\/] =$/;"	m	struct:simpla::mesh::MeshEntityIdCoder
m_adjacent_cell_num_	core/manifold/mesh/MeshIds.h	/^template<int L> constexpr int MeshEntityIdCoder<L>::m_adjacent_cell_num_[4][8];$/;"	m	class:simpla::mesh::MeshEntityIdCoder
m_attributes_	core/manifold/Manifold.h	/^    attribute_holder_type m_attributes_;$/;"	m	class:simpla::Manifold
m_b_	core/gtl/iterator/sp_ntuple_range.h	/^    ntuple_type m_b_, m_e_;$/;"	m	struct:simpla::sp_nTuple_range
m_base_	core/gtl/containers/sp_indirect_container.h	/^	ValueContiner & m_base_;$/;"	m	struct:simpla::indirect_container
m_bcenter_	core/model/GEqdsk.cpp	/^    Real m_bcenter_ = 0.5; \/\/!< Vacuum toroidal magnetic field in Tesla at RCENTR$/;"	m	struct:simpla::GEqdsk::pimpl_s	file:
m_begin_	core/gtl/iterator/range.h	/^    const_iterator m_begin_, m_end_;$/;"	m	class:simpla::Range
m_begin_	core/gtl/iterator/sp_iterator_cycle.h	/^	base_iterator m_begin_, m_end_;$/;"	m	struct:simpla::CycleIterator
m_begin_	core/gtl/range/block_range.h	/^    const_iterator m_begin_, m_end_;$/;"	m	class:simpla::BlockRange
m_block_	core/gtl/array_view.h	/^    nTuple<size_t, MAX_NDIMS_OF_ARRAY> m_block_;$/;"	m	struct:simpla::gtl::ArrayViewBase
m_boundary_box_	core/manifold/mesh/MeshBlock.h	/^    std::vector<index_box_type> m_boundary_box_;$/;"	m	struct:simpla::mesh::MeshBlock
m_buffer_	core/io/WriteBuffer.h	/^    std::shared_ptr<void> m_buffer_;$/;"	m	class:simpla::io::WriteBuffer
m_buffer_depth_	core/io/WriteBuffer.h	/^    size_t m_buffer_depth_ = 0;$/;"	m	class:simpla::io::WriteBuffer
m_buffer_map_	core/io/HDF5Stream.cpp	/^    std::map<std::string, data_model::DataSet> m_buffer_map_;$/;"	m	struct:simpla::io::HDF5Stream::pimpl_s	file:
m_cache_	core/gtl/function_cache.h	/^	std::map<key_type, value_type> m_cache_;$/;"	m	struct:simpla::FunctionCache
m_center_box_	core/manifold/mesh/MeshBlock.h	/^    index_box_type m_center_box_;$/;"	m	struct:simpla::mesh::MeshBlock
m_circle_	core/geometry/model.h	/^	Primitive<3, CS, tags::circle> m_circle_;$/;"	m	struct:simpla::geometry::model::Primitive
m_click_	core/base/LifeClick.h	/^    std::atomic<size_t> m_click_;$/;"	m	struct:simpla::base::LifeClick
m_click_	core/base/Object.h	/^    size_t m_click_ = 0;$/;"	m	class:simpla::base::Object
m_cmr_	core/particle/pre_define/PICGyro.h	/^    Real m_cmr_;$/;"	m	struct:simpla::particle::engine::GyroParticleWithCylindricalCoord
m_cmr_	example/pic/demo_pic.h	/^	Real m_cmr_, m_q_kT_;$/;"	m	struct:simpla::FiberBundle
m_comm_	core/parallel/MPIComm.cpp	/^    MPI_Comm m_comm_;$/;"	m	struct:simpla::parallel::MPIComm::pimpl_s	file:
m_connections_	core/parallel/obsoleted/distributed_unordered_set.h	/^	std::vector<connection_node> m_connections_;$/;"	m	struct:simpla::Distributed
m_const_mesh_	core/base/Attribute.h	/^    mesh_type const *m_const_mesh_;$/;"	m	class:simpla::base::AttributeEntity
m_container_	core/gtl/iterator/sp_indirect_iterator.h	/^    std::reference_wrapper<container_type> m_container_;$/;"	m	struct:simpla::sp_indirect_iterator
m_coords_max_	core/manifold/mesh/CoRectMesh.h	/^    point_type m_coords_max_ = {1, 1, 1};$/;"	m	struct:simpla::mesh::Mesh
m_coords_max_	core/manifold/mesh/RectMesh.h	/^    point_type m_coords_max_ = {1, 1, 1};$/;"	m	struct:simpla::mesh::Mesh
m_coords_min_	core/manifold/mesh/CoRectMesh.h	/^    point_type m_coords_min_ = {0, 0, 0};$/;"	m	struct:simpla::mesh::Mesh
m_coords_min_	core/manifold/mesh/RectMesh.h	/^    point_type m_coords_min_ = {0, 0, 0};$/;"	m	struct:simpla::mesh::Mesh
m_count	example/em_tokamak/tokamak.cpp	/^    size_t m_count = 0;$/;"	m	struct:simpla::EMTokamak	file:
m_count_	core/gtl/array_view.h	/^    nTuple<size_t, MAX_NDIMS_OF_ARRAY> m_count_;$/;"	m	struct:simpla::gtl::ArrayViewBase
m_count_	core/manifold/obsoleted/amr_policy.h	/^    size_t m_count_ = 0;$/;"	m	class:simpla::manifold::policy::AMR
m_count_	core/manifold/obsoleted/patch/mesh_patch.h	/^    size_t m_count_ = 0;$/;"	m	class:simpla::mesh::MeshPatch
m_count_	core/parallel/ParallelRandomGenerator.h	/^    size_t m_count_;$/;"	m	struct:simpla::parallel::DistributedCounter::input_iterator
m_count_	core/particle/ParticleGenerator.h	/^        size_t m_count_;$/;"	m	struct:simpla::particle::ParticleGenerator::input_iterator
m_current_	core/model/GEqdsk.cpp	/^    Real m_current_ = 1.0; \/\/!< Plasma current in Ampere$/;"	m	struct:simpla::GEqdsk::pimpl_s	file:
m_d_shape_	core/data_model/DataSpace.cpp	/^    data_shape_s m_d_shape_;$/;"	m	struct:simpla::data_model::DataSpace::pimpl_s	file:
m_data_	core/base/Attribute.h	/^    std::shared_ptr<value_type> m_data_;$/;"	m	class:simpla::base::Attribute
m_data_	core/data_model/data_view.h	/^	std::shared_ptr<TV> m_data_;$/;"	m	struct:simpla::data_view
m_data_	core/field/FieldDense.h	/^    std::shared_ptr<attribute_type> m_data_;$/;"	m	class:simpla::Field
m_data_	core/geometry/chains.h	/^    data_type m_data_;$/;"	m	struct:simpla::geometry::model::Chains
m_data_	core/geometry/primitive.h	/^    nTuple<CoordinateType, N...> m_data_;$/;"	m	struct:simpla::geometry::model::Tensor
m_data_	core/gtl/array_view.h	/^    ArrayViewBase m_data_;$/;"	m	struct:simpla::gtl::ArrayView::iterator
m_data_	core/gtl/array_view.h	/^    std::shared_ptr<void> m_data_;$/;"	m	struct:simpla::gtl::ArrayViewBase
m_data_	core/gtl/containers/iterator_proxy.h	/^	traits::reference_t<data_container_type> m_data_;$/;"	m	struct:simpla::iterator_proxy
m_data_	core/gtl/containers/sp_hash_container.h	/^	std::shared_ptr<value_type> m_data_;$/;"	m	struct:simpla::SpHashContainer
m_data_	core/gtl/containers/sp_ndarray.h	/^	std::shared_ptr<value_type> m_data_;$/;"	m	class:simpla::ndArray
m_data_	core/gtl/containers/unordered_set.h	/^    base_container_type m_data_;$/;"	m	class:simpla::UnorderedSet
m_data_	core/model/obsoleted/model.h	/^    std::shared_ptr<tag_type> m_data_;$/;"	m	class:simpla::Model
m_data_	core/particle/Particle.h	/^    std::shared_ptr<container_type> m_data_;$/;"	m	struct:simpla::particle::Particle
m_data_type_	core/io/WriteBuffer.h	/^    data_model::DataType m_data_type_;$/;"	m	class:simpla::io::WriteBuffer
m_dataset_	core/field/obsoleted/field_sparse.h	/^	container_type m_dataset_;$/;"	m	struct:simpla::Field
m_define_domain_	core/field/FieldFunction.h	/^    spatial_domain_type m_define_domain_;$/;"	m	class:simpla::Field
m_density_	core/particle/ParticleGenerator.h	/^    std::function<Real(point_type const &)> m_density_;$/;"	m	class:simpla::particle::ParticleGeneratorPerCell
m_desc_	core/model/GEqdsk.cpp	/^    std::string m_desc_;$/;"	m	struct:simpla::GEqdsk::pimpl_s	file:
m_dimensions_	core/gtl/containers/sp_ndarray.h	/^	index_type m_dimensions_;$/;"	m	class:simpla::ndArray
m_dimensions_	core/gtl/containers/sp_ndarray.h	/^	nTuple<size_t, ndims> m_dimensions_;$/;"	m	class:simpla::ndArray
m_dims_	core/gtl/array_view.h	/^    nTuple<size_t, MAX_NDIMS_OF_ARRAY> m_dims_;$/;"	m	struct:simpla::gtl::ArrayViewBase
m_dt_	core/manifold/Manifold.h	/^    double m_dt_;$/;"	m	class:simpla::Manifold
m_dt_	core/manifold/obsoleted/time_integrator_policy.h	/^    double m_dt_;$/;"	m	struct:simpla::manifold::policy::TimeIntegrator
m_dual_volume_	core/manifold/mesh/CartesianCoRect.h	/^    Real m_dual_volume_[9];$/;"	m	struct:simpla::mesh::CartesianCoRect
m_dual_volume_	core/manifold/mesh/CoRectMesh.h	/^    Real m_dual_volume_[9];$/;"	m	struct:simpla::mesh::Mesh
m_dual_volume_	core/manifold/mesh/CylindricalCoRect.h	/^    std::vector<Real> m_dual_volume_;$/;"	m	class:simpla::mesh::CylindricalCoRect
m_dual_volume_	core/manifold/mesh/RectMesh.h	/^    std::shared_ptr<Real> m_dual_volume_;$/;"	m	struct:simpla::mesh::Mesh
m_dx_	core/manifold/mesh/CoRectMesh.h	/^    vector_type m_dx_ = {1, 1, 1};; \/\/!< width of cell, except m_dx_[i]=0 when m_dims_[i]==1$/;"	m	struct:simpla::mesh::Mesh
m_dx_	core/manifold/mesh/MeshBlock.h	/^    vector_type m_dx_;$/;"	m	struct:simpla::mesh::MeshBlock
m_dx_	core/manifold/mesh/RectMesh.h	/^    vector_type m_dx_ = {1, 1, 1};; \/\/!< width of cell, except m_dx_[i]=0 when m_dims_[i]==1$/;"	m	struct:simpla::mesh::Mesh
m_e_	core/gtl/iterator/sp_ntuple_range.h	/^    ntuple_type m_b_, m_e_;$/;"	m	struct:simpla::sp_nTuple_range
m_ele_size_in_byte_	core/data_model/DataType.cpp	/^    size_t m_ele_size_in_byte_ = 0;$/;"	m	struct:simpla::data_model::DataType::pimpl_s	file:
m_ele_size_in_byte_	core/gtl/array_view.h	/^    int m_ele_size_in_byte_;$/;"	m	struct:simpla::gtl::ArrayViewBase
m_end_	core/gtl/iterator/range.h	/^    const_iterator m_begin_, m_end_;$/;"	m	class:simpla::Range
m_end_	core/gtl/iterator/sp_iterator_cycle.h	/^	base_iterator m_begin_, m_end_;$/;"	m	struct:simpla::CycleIterator
m_end_	core/gtl/range/block_range.h	/^    const_iterator m_begin_, m_end_;$/;"	m	class:simpla::BlockRange
m_end_	core/parallel/DistributedCounter.h	/^    std::atomic<size_t> m_start_, m_end_;$/;"	m	struct:simpla::parallel::DistributedCounter
m_end_	core/parallel/ParallelRandomGenerator.h	/^    std::atomic<size_t> m_start_, m_end_;$/;"	m	struct:simpla::parallel::DistributedCounter
m_extent	core/gtl/ntuple.h	/^    static constexpr int m_extent = N;$/;"	m	struct:simpla::nTuple
m_extents_	core/data_model/DataType.cpp	/^    std::vector<size_t> m_extents_;$/;"	m	struct:simpla::data_model::DataType::pimpl_s	file:
m_file_stream_	core/io/XDMFStream.h	/^    std::ofstream m_file_stream_;$/;"	m	class:simpla::io::XDMFStream
m_filter_list_	core/particle/Particle.h	/^            typename mesh_type::range_type  >> m_filter_list_;$/;"	m	struct:simpla::particle::Particle
m_fun_	core/field/FieldFunction.h	/^    TFun m_fun_;$/;"	m	class:simpla::Field
m_fun_	core/geometry/implicit_function.h	/^	function_type m_fun_;$/;"	m	class:simpla::ImplicitFunction
m_fun_	core/gtl/function.h	/^    TFun m_fun_;$/;"	m	class:simpla::Function
m_fun_	core/gtl/function_cache.h	/^	function_type m_fun_;$/;"	m	struct:simpla::FunctionCache
m_func_	core/particle/ParticleGenerator.h	/^        std::function<void(nTuple<Real, 3> const &, nTuple<Real, 3> const &, value_type *)> m_func_;$/;"	m	struct:simpla::particle::ParticleGenerator::input_iterator
m_geo_	core/manifold/obsoleted/embedded_policy.h	/^    geometry_type const &m_geo_;$/;"	m	struct:simpla::manifold::policy::EmbeddedPolicy
m_geo_	core/manifold/obsoleted/time_integrator_policy.h	/^    geometry_type &m_geo_;$/;"	m	struct:simpla::manifold::policy::TimeIntegrator
m_geo_	core/manifold/policy/IOPolicy.h	/^    geometry_type const &m_geo_;$/;"	m	struct:simpla::manifold::policy::IOPolicy
m_geo_	core/manifold/policy/StoragePolicy.h	/^    geometry_type const &m_geo_;$/;"	m	struct:simpla::manifold::policy::StoragePolicy
m_geo_	core/model/obsoleted/model.h	/^    Block const &m_geo_;$/;"	m	class:simpla::Model
m_ghost_box_	core/manifold/mesh/MeshBlock.h	/^    std::vector<index_box_type> m_ghost_box_;$/;"	m	struct:simpla::mesh::MeshBlock
m_grain_size_	core/gtl/array_view.h	/^    nTuple<size_t, MAX_NDIMS_OF_ARRAY> m_grain_size_;$/;"	m	struct:simpla::gtl::ArrayViewBase
m_grain_size_	core/gtl/iterator/range.h	/^    ptrdiff_t m_grain_size_;$/;"	m	class:simpla::Range
m_grain_size_	core/gtl/range/block_range.h	/^    size_type m_grain_size_;$/;"	m	class:simpla::BlockRange
m_grain_size_	core/manifold/mesh/MeshIds.h	/^        index_tuple m_min_, m_max_, m_grain_size_;$/;"	m	struct:simpla::mesh::MeshEntityIdCoder::range_type
m_grainsize_	core/gtl/iterator/sp_ntuple_range.h	/^    ntuple_type m_grainsize_;$/;"	m	struct:simpla::sp_nTuple_range
m_h5_stream_	core/io/XDMFStream.h	/^    HDF5Stream m_h5_stream_;$/;"	m	class:simpla::io::XDMFStream
m_hash_	core/gtl/containers/sp_hash_container.h	/^	hash_function m_hash_;$/;"	m	struct:simpla::SpHashContainer
m_hash_	core/gtl/function_cache.h	/^	hash_fun m_hash_;$/;"	m	struct:simpla::FunctionCache
m_hash_	core/particle/ParticleContainer.h	/^    Hash m_hash_;$/;"	m	struct:simpla::particle::ParticleContainer
m_hasher_	core/gtl/iterator/sp_indirect_iterator.h	/^    hasher_type m_hasher_;$/;"	m	struct:simpla::sp_indirect_iterator
m_id_to_coordinates_shift_	core/manifold/mesh/MeshIds.h	/^    static constexpr point_type m_id_to_coordinates_shift_[] = {$/;"	m	struct:simpla::mesh::MeshEntityIdCoder
m_id_to_coordinates_shift_	core/manifold/mesh/MeshIds.h	/^template<int L> constexpr typename MeshEntityIdCoder<L>::point_type MeshEntityIdCoder<L>::m_id_to_coordinates_shift_[];$/;"	m	class:simpla::mesh::MeshEntityIdCoder
m_id_to_iform_	core/manifold/mesh/MeshIds.h	/^    static constexpr int m_id_to_iform_[] = { \/\/$/;"	m	struct:simpla::mesh::MeshEntityIdCoder
m_id_to_iform_	core/manifold/mesh/MeshIds.h	/^template<int L> constexpr int MeshEntityIdCoder<L>::m_id_to_iform_[];$/;"	m	class:simpla::mesh::MeshEntityIdCoder
m_id_to_index_	core/manifold/mesh/MeshIds.h	/^    static constexpr int m_id_to_index_[8] = { \/\/$/;"	m	struct:simpla::mesh::MeshEntityIdCoder
m_id_to_index_	core/manifold/mesh/MeshIds.h	/^template<int L> constexpr int MeshEntityIdCoder<L>::m_id_to_index_[];$/;"	m	class:simpla::mesh::MeshEntityIdCoder
m_id_to_num_of_ele_in_cell_	core/manifold/mesh/MeshIds.h	/^    static constexpr int m_id_to_num_of_ele_in_cell_[] = {$/;"	m	struct:simpla::mesh::MeshEntityIdCoder
m_id_to_num_of_ele_in_cell_	core/manifold/mesh/MeshIds.h	/^template<int L> constexpr int MeshEntityIdCoder<L>::m_id_to_num_of_ele_in_cell_[];$/;"	m	class:simpla::mesh::MeshEntityIdCoder
m_id_to_shift_	core/manifold/mesh/MeshIds.h	/^    static constexpr id_type m_id_to_shift_[] = {$/;"	m	struct:simpla::mesh::MeshEntityIdCoder
m_id_to_shift_	core/manifold/mesh/MeshIds.h	/^template<int L> constexpr typename MeshEntityIdCoder<L>::id_type MeshEntityIdCoder<L>::m_id_to_shift_[];$/;"	m	class:simpla::mesh::MeshEntityIdCoder
m_id_to_sub_index_	core/manifold/mesh/MeshIds.h	/^    static constexpr id_type m_id_to_sub_index_[8] = { \/\/$/;"	m	struct:simpla::mesh::MeshEntityIdCoder
m_idx_	core/gtl/array_view.h	/^    nTuple<size_t, MAX_NDIMS_OF_ARRAY> m_idx_;$/;"	m	struct:simpla::gtl::ArrayView::iterator
m_iform_	core/manifold/mesh/MeshIds.h	/^        int m_iform_;$/;"	m	struct:simpla::mesh::MeshEntityIdCoder::iterator
m_iform_	core/manifold/mesh/MeshIds.h	/^        int m_iform_;$/;"	m	struct:simpla::mesh::MeshEntityIdCoder::range_type
m_index_range_	core/data_model/data_view.h	/^	index_range_type m_index_range_;$/;"	m	struct:simpla::data_view
m_inners_	core/geometry/model.h	/^	inner_container_type m_inners_;$/;"	m	struct:simpla::geometry::model::Polygon
m_integral_list_	core/particle/Particle.h	/^            std::weak_ptr<typename mesh_type::AttributeEntity> &)> >> m_integral_list_;$/;"	m	struct:simpla::particle::Particle
m_inv_cmr_	core/particle/pre_define/PICGyro.h	/^    Real m_inv_cmr_;$/;"	m	struct:simpla::particle::engine::GyroParticleWithCylindricalCoord
m_inv_dual_volume_	core/manifold/mesh/CartesianCoRect.h	/^    Real m_inv_dual_volume_[9];$/;"	m	struct:simpla::mesh::CartesianCoRect
m_inv_dual_volume_	core/manifold/mesh/CoRectMesh.h	/^    Real m_inv_dual_volume_[9];$/;"	m	struct:simpla::mesh::Mesh
m_inv_dual_volume_	core/manifold/mesh/CylindricalCoRect.h	/^    std::vector<Real> m_inv_dual_volume_;$/;"	m	class:simpla::mesh::CylindricalCoRect
m_inv_dual_volume_	core/manifold/mesh/RectMesh.h	/^    std::shared_ptr<Real> m_inv_dual_volume_;$/;"	m	struct:simpla::mesh::Mesh
m_inv_map_orig_	core/manifold/mesh/LinearMap.h	/^    point_type m_inv_map_orig_ = {0, 0, 0};$/;"	m	struct:simpla::mesh::LinearMap
m_inv_map_orig_	core/manifold/mesh/MeshBlock.h	/^    point_type m_inv_map_orig_ = {0, 0, 0};$/;"	m	struct:simpla::mesh::MeshBlock
m_inv_map_scale_	core/manifold/mesh/LinearMap.h	/^    point_type m_inv_map_scale_ = {1, 1, 1};$/;"	m	struct:simpla::mesh::LinearMap
m_inv_map_scale_	core/manifold/mesh/MeshBlock.h	/^    point_type m_inv_map_scale_ = {1, 1, 1};$/;"	m	struct:simpla::mesh::MeshBlock
m_inv_volume_	core/manifold/mesh/CartesianCoRect.h	/^    Real m_inv_volume_[9];$/;"	m	struct:simpla::mesh::CartesianCoRect
m_inv_volume_	core/manifold/mesh/CoRectMesh.h	/^    Real m_inv_volume_[9];$/;"	m	struct:simpla::mesh::Mesh
m_inv_volume_	core/manifold/mesh/CylindricalCoRect.h	/^    std::vector<Real> m_inv_volume_;$/;"	m	class:simpla::mesh::CylindricalCoRect
m_inv_volume_	core/manifold/mesh/RectMesh.h	/^    std::shared_ptr<Real> m_inv_volume_;$/;"	m	struct:simpla::mesh::Mesh
m_it_	core/gtl/iterator/indirect_iterator.h	/^	src_iterator m_it_;$/;"	m	struct:simpla::indirect_iterator
m_key_range_	core/gtl/iterator/sp_indirect_iterator.h	/^    key_range_type m_key_range_;$/;"	m	struct:simpla::sp_indirect_range
m_kv_map_	core/gtl/utilities/config_parser.h	/^    std::map<std::string, std::string> m_kv_map_;$/;"	m	struct:simpla::ConfigParser
m_l_	core/gtl/utilities/lua_object.h	/^            std::shared_ptr<lua_s> m_l_;$/;"	m	struct:simpla::lua::LuaObject::LuaState::accessor
m_l_	core/gtl/utilities/lua_object.h	/^            std::shared_ptr<lua_s> m_l_;$/;"	m	struct:simpla::lua::LuaObject::LuaState::const_accessor
m_l_	core/gtl/utilities/lua_object.h	/^        std::shared_ptr<lua_s> m_l_;$/;"	m	struct:simpla::lua::LuaObject::LuaState
m_last_	core/gtl/iterator/sp_iterator_filter.h	/^	base_iterator m_last_;$/;"	m	struct:simpla::sp_fliter_iterator
m_left_	core/manifold/mesh/GeneralMap.h	/^    left_action m_left_;$/;"	m	struct:simpla::mesh::GeneralMap
m_left_	core/parallel/ParallelDummy.h	/^    size_t m_left_, m_right_;$/;"	m	struct:simpla::serial::tags::proportional_split
m_level_	core/gtl/utilities/log.h	/^    int m_level_ = 10;$/;"	m	class:simpla::logger::Logger
m_lua_object_	core/gtl/utilities/config_parser.h	/^    lua::LuaObject m_lua_object_;$/;"	m	struct:simpla::ConfigParser
m_map_	core/manifold/obsoleted/fiber_bundle.h	/^    project_map_type const &m_map_;$/;"	m	class:simpla::manifold::FiberBundle
m_map_orig_	core/manifold/mesh/LinearMap.h	/^    point_type m_map_orig_ = {0, 0, 0};$/;"	m	struct:simpla::mesh::LinearMap
m_map_orig_	core/manifold/mesh/MeshBlock.h	/^    point_type m_map_orig_ = {0, 0, 0};$/;"	m	struct:simpla::mesh::MeshBlock
m_map_scale_	core/manifold/mesh/LinearMap.h	/^    point_type m_map_scale_ = {1, 1, 1};$/;"	m	struct:simpla::mesh::LinearMap
m_map_scale_	core/manifold/mesh/MeshBlock.h	/^    point_type m_map_scale_ = {1, 1, 1};$/;"	m	struct:simpla::mesh::MeshBlock
m_max_	core/gtl/iterator/block_iterator.h	/^    nTuple<TV, NDIMS> m_min_, m_max_, m_self_;$/;"	m	struct:simpla::block_iterator
m_max_	core/gtl/iterator/sp_ntuple_range.h	/^    ntuple_type m_min_, m_max_, m_self_;$/;"	m	struct:simpla::sp_nTuple_range::iterator
m_max_	core/manifold/mesh/MeshBlock.h	/^    point_type m_max_;$/;"	m	struct:simpla::mesh::MeshBlock
m_max_	core/manifold/mesh/MeshIds.h	/^        index_tuple m_min_, m_max_, m_grain_size_;$/;"	m	struct:simpla::mesh::MeshEntityIdCoder::range_type
m_max_buffer_depth_	core/io/WriteBuffer.h	/^    size_t m_max_buffer_depth_ = 1;$/;"	m	class:simpla::io::WriteBuffer
m_max_hash_	core/gtl/containers/sp_hash_container.h	/^	size_t m_max_hash_ = 0;$/;"	m	struct:simpla::SpHashContainer
m_max_index_r_	core/manifold/mesh/CylindricalCoRect.h	/^    index_type m_max_index_r_ = 1;$/;"	m	class:simpla::mesh::CylindricalCoRect
m_members_	core/data_model/DataType.cpp	/^    std::vector<std::tuple<DataType, std::string, int>> m_members_;$/;"	m	struct:simpla::data_model::DataType::pimpl_s	file:
m_mesh	core/particle/test/kinetic_particle_test.h	/^	mesh_type m_mesh;$/;"	m	class:TestKineticParticle
m_mesh_	applications/field_solver/pml.h	/^	std::shared_ptr<const mesh_type> m_mesh_;$/;"	m	class:simpla::PML
m_mesh_	core/base/Attribute.h	/^    mesh_type *m_mesh_;$/;"	m	class:simpla::base::AttributeEntity
m_mesh_	core/field/FieldFunction.h	/^    mesh_type const &m_mesh_;$/;"	m	class:simpla::Field
m_mesh_	core/field/obsoleted/field_constant.h	/^	mesh_type m_mesh_;$/;"	m	class:simpla::Field
m_mesh_	core/field/obsoleted/field_sparse.h	/^	mesh_type m_mesh_;$/;"	m	struct:simpla::Field
m_mesh_	core/geometry/obsolete/polygon.h	/^	mesh_type m_mesh_;$/;"	m	struct:simpla::PolyGon
m_mesh_	core/geometry/obsolete/surface.h	/^	mesh_type const & m_mesh_;$/;"	m	class:simpla::Surface
m_mesh_	core/manifold/obsoleted/fiber_bundle.h	/^    mesh_type const &m_mesh_;$/;"	m	class:simpla::manifold::FiberBundle
m_mesh_	core/manifold/policy/ParallelPolicy.h	/^    mesh_type &m_mesh_;$/;"	m	struct:simpla::manifold::policy::ParallelPolicy
m_mesh_	core/particle/obsolete/kinetic_particle.h	/^    mesh_type const *m_mesh_;$/;"	m	struct:simpla::_impl::particle_hasher
m_mesh_	core/particle/pre_define/PICBoris.h	/^    mesh_type &m_mesh_;$/;"	m	struct:simpla::particle::engine::BorisEngine
m_mesh_	core/particle/pre_define/PICGyro.h	/^    mesh_type &m_mesh_;$/;"	m	struct:simpla::particle::engine::GyroParticleWithCylindricalCoord
m_mesh_	example/pic/demo_pic.h	/^	base_manifold const &m_mesh_;$/;"	m	struct:simpla::FiberBundle
m_min_	core/gtl/iterator/block_iterator.h	/^    nTuple<TV, NDIMS> m_min_, m_max_, m_self_;$/;"	m	struct:simpla::block_iterator
m_min_	core/gtl/iterator/sp_ntuple_range.h	/^    ntuple_type m_min_, m_max_, m_self_;$/;"	m	struct:simpla::sp_nTuple_range::iterator
m_min_	core/manifold/mesh/MeshBlock.h	/^    point_type m_min_;$/;"	m	struct:simpla::mesh::MeshBlock
m_min_	core/manifold/mesh/MeshIds.h	/^        index_tuple m_min_, m_max_, m_grain_size_;$/;"	m	struct:simpla::mesh::MeshEntityIdCoder::range_type
m_min_index_r_	core/manifold/mesh/CylindricalCoRect.h	/^    index_type m_min_index_r_ = 0;$/;"	m	class:simpla::mesh::CylindricalCoRect
m_modified_	core/gtl/containers/unordered_set.h	/^    std::set<key_type> m_modified_;$/;"	m	class:simpla::UnorderedSet
m_mpi_dtype_	core/parallel/DistributedObject.cpp	/^    std::vector<MPIDataType> m_mpi_dtype_;$/;"	m	struct:simpla::parallel::DistributedObject::pimpl_s	file:
m_mpi_requests_	core/parallel/DistributedObject.cpp	/^    std::vector<MPI_Request> m_mpi_requests_;$/;"	m	struct:simpla::parallel::DistributedObject::pimpl_s	file:
m_mpi_requests_	core/parallel/trash/distributed_unordered_set.cpp	/^	std::vector<MPI_Request> m_mpi_requests_;$/;"	m	struct:simpla::DistributedUnorderedSetBase::pimpl_s	file:
m_mutex_	core/base/Object.h	/^    std::mutex m_mutex_;$/;"	m	class:simpla::base::Object
m_mutex_	core/field/FieldFunction.h	/^    std::mutex m_mutex_;$/;"	m	class:simpla::Field
m_mutex_	core/gtl/utilities/lua_object.h	/^            std::mutex m_mutex_;$/;"	m	struct:simpla::lua::LuaObject::LuaState::lua_s
m_name_	core/data_model/DataType.cpp	/^    std::string m_name_;$/;"	m	struct:simpla::data_model::DataType::pimpl_s	file:
m_ndims_	core/gtl/array_view.h	/^    int m_ndims_;$/;"	m	struct:simpla::gtl::ArrayViewBase
m_ndims_	core/manifold/mesh/MeshBlock.h	/^    int m_ndims_ = 3;$/;"	m	struct:simpla::mesh::MeshBlock
m_nid_	core/geometry/obsolete/surface.h	/^	id_type m_nid_;$/;"	m	class:simpla::Surface
m_num_per_cell_	core/particle/ParticleGenerator.h	/^    size_t m_num_per_cell_ = 1;$/;"	m	class:simpla::particle::ParticleGeneratorPerCell
m_num_process_	core/parallel/MPIComm.cpp	/^    int m_num_process_;$/;"	m	struct:simpla::parallel::MPIComm::pimpl_s	file:
m_object_	core/geometry/obsolete/geometry_object.h	/^	Sphere m_object_;$/;"	m	struct:simpla::geometry_object::ImplicitFunction
m_object_id_	core/parallel/DistributedObject.cpp	/^    int m_object_id_;$/;"	m	struct:simpla::parallel::DistributedObject::pimpl_s	file:
m_object_id_count_	core/parallel/MPIComm.cpp	/^    int m_object_id_count_;$/;"	m	struct:simpla::parallel::MPIComm::pimpl_s	file:
m_observers_	core/gtl/design_pattern/observer.h	/^	std::set<std::shared_ptr<observer_type>> m_observers_;$/;"	m	struct:simpla::Observable
m_offset_	core/gtl/containers/sp_ndarray.h	/^	index_type m_offset_;$/;"	m	class:simpla::ndArray
m_offset_	core/manifold/obsoleted/mesh_graph.h	/^    typename m::id_type m_offset_;$/;"	m	struct:simpla::mesh::MeshMapEdge
m_op_	core/gtl/expression_template.h	/^    TOP m_op_;$/;"	m	struct:simpla::Expression
m_out_stream_	core/io/WriteBuffer.h	/^    HDF5Stream &m_out_stream_;$/;"	m	class:simpla::io::WriteBuffer
m_outer_	core/geometry/model.h	/^	ring_type m_outer_;$/;"	m	struct:simpla::geometry::model::Polygon
m_p_	core/gtl/iterator/sp_iterator.h	/^	container_type m_p_;$/;"	m	class:simpla::sp_back_insert_iterator
m_parent_	core/base/Attribute.h	/^    std::weak_ptr<AttributeObject> m_parent_;$/;"	m	class:simpla::base::AttributeObject
m_particle_	core/particle/ParticleGenerator.h	/^    particle_type const &m_particle_;$/;"	m	class:simpla::particle::ParticleGeneratorPerCell
m_patch_count_	core/base/Patch.h	/^    size_t m_patch_count_;$/;"	m	class:simpla::base::Patch
m_patches_	core/base/Patch.h	/^    std::map<size_t, std::shared_ptr<object_type> > m_patches_;$/;"	m	class:simpla::base::Patch
m_patches_	core/manifold/obsoleted/amr_policy.h	/^    std::map<size_t, std::shared_ptr<entity_type>> m_patches_;$/;"	m	class:simpla::manifold::policy::AMR
m_patches_	core/manifold/obsoleted/patch/mesh_patch.h	/^    std::map<size_t, std::shared_ptr<AttributeBase>> m_patches_;$/;"	m	class:simpla::mesh::MeshPatch
m_patches_	core/manifold/obsoleted/patch/mesh_patch.h	/^    std::map<size_t, std::shared_ptr<attribute_type> > m_patches_;$/;"	m	class:simpla::mesh::PatchPolicy
m_path_	core/io/XDMFStream.h	/^    std::list<std::string> m_path_;$/;"	m	class:simpla::io::XDMFStream
m_pimpl_	core/data_model/DataSpace.h	/^    std::shared_ptr<pimpl_s> m_pimpl_;$/;"	m	class:simpla::data_model::DataSpace
m_pimpl_	core/io/HDF5Stream.h	/^    std::unique_ptr<pimpl_s> m_pimpl_;$/;"	m	class:simpla::io::HDF5Stream
m_pimpl_	core/model/GEqdsk.h	/^    std::unique_ptr<pimpl_s> m_pimpl_;$/;"	m	class:simpla::GEqdsk
m_pimpl_	plugins/vtk_reader/vtkAMRSimPlaParticlesReader.h	/^    std::unique_ptr<pimpl_s> m_pimpl_;$/;"	m	class:vtkAMRSimPlaParticlesReader
m_pimpl_	plugins/vtk_reader/vtkAMRSimPlaReader.h	/^    std::unique_ptr<pimpl_s> m_pimpl_;$/;"	m	class:vtkAMRSimPlaReader
m_pip_constant_	core/geometry/obsolete/polygon.h	/^	std::list<Real> m_pip_constant_;$/;"	m	struct:simpla::PolyGon
m_pip_multiple_	core/geometry/obsolete/polygon.h	/^	std::list<Real> m_pip_multiple_;$/;"	m	struct:simpla::PolyGon
m_polygon_	core/geometry/polygon.h	/^    std::vector<point2d_type> m_polygon_;$/;"	m	struct:simpla::geometry::Polygon
m_polygon_	core/model/obsoleted/revolve_polygon.h	/^    polygon_type m_polygon_;$/;"	m	struct:simpla::RevolvePolygon
m_pred_	core/gtl/iterator/sp_iterator_filter.h	/^	predicate_fun m_pred_;$/;"	m	struct:simpla::sp_fliter_iterator
m_prefix_	core/io/XDMFStream.h	/^    std::string m_prefix_;$/;"	m	class:simpla::io::XDMFStream
m_process_num_	core/parallel/MPIComm.cpp	/^    int m_process_num_;$/;"	m	struct:simpla::parallel::MPIComm::pimpl_s	file:
m_profile_	core/model/GEqdsk.cpp	/^    std::map<std::string, inter_type> m_profile_;$/;"	m	struct:simpla::GEqdsk::pimpl_s	file:
m_properties_	core/base/Attribute.h	/^    Properties m_properties_;$/;"	m	class:simpla::base::Attribute
m_psirz_	core/model/GEqdsk.cpp	/^    inter2d_type m_psirz_; \/\/!< Poloidal flux in Webber\/rad on the rectangular grid points$/;"	m	struct:simpla::GEqdsk::pimpl_s	file:
m_ptr_	core/gtl/design_pattern/signal.h	/^        std::weak_ptr<T> m_ptr_;$/;"	m	struct:simpla::Signal::Slot::Tracker
m_q_kT_	example/pic/demo_pic.h	/^	Real m_cmr_, m_q_kT_;$/;"	m	struct:simpla::FiberBundle
m_radius_	core/geometry/model.h	/^	length_type m_radius_;$/;"	m	struct:simpla::geometry::model::Primitive
m_range_	core/geometry/obsolete/surface.h	/^	range_type m_range_;$/;"	m	class:simpla::Surface
m_rcenter_	core/model/GEqdsk.cpp	/^    Real m_rcenter_ = 0.5; \/\/!< R in meter of  vacuum toroidal magnetic field BCENTR$/;"	m	struct:simpla::GEqdsk::pimpl_s	file:
m_rdim_	core/model/GEqdsk.cpp	/^    Real m_rdim_; \/\/!< Horizontal dimension in meter of computational box$/;"	m	struct:simpla::GEqdsk::pimpl_s	file:
m_record_size_	core/io/WriteBuffer.h	/^    size_t m_record_size_ = 1;$/;"	m	class:simpla::io::WriteBuffer
m_refinement_ratio_	core/manifold/obsoleted/amr_policy.h	/^    size_t m_refinement_ratio_ = 2;$/;"	m	class:simpla::manifold::policy::AMR
m_refinement_ratio_	core/manifold/obsoleted/patch/mesh_patch.h	/^    size_t m_refinement_ratio_ = 2;$/;"	m	class:simpla::mesh::MeshPatch
m_registered_task_	core/task_flow/task.h	/^    static std::map<std::string, std::shared_ptr<task_type>> m_registered_task_;$/;"	m	struct:simpla::task_flow::_impl::TaskRegistry
m_registered_task_	core/task_flow/task.h	/^template<typename TContext> std::map<std::string, std::shared_ptr<Task<TContext>>> TaskRegistry<TContext>::m_registered_task_;$/;"	m	class:simpla::task_flow::_impl::TaskRegistry
m_right_	core/manifold/mesh/GeneralMap.h	/^    right_action m_right_;$/;"	m	struct:simpla::mesh::GeneralMap
m_right_	core/parallel/ParallelDummy.h	/^    size_t m_left_, m_right_;$/;"	m	struct:simpla::serial::tags::proportional_split
m_rleft_	core/model/GEqdsk.cpp	/^    Real m_rleft_; \/\/!< Minimum R in meter of rectangular computational box$/;"	m	struct:simpla::GEqdsk::pimpl_s	file:
m_rmaxis_	core/model/GEqdsk.cpp	/^    Real m_rmaxis_ = 1.0; \/\/!< R of magnetic axis in meter$/;"	m	struct:simpla::GEqdsk::pimpl_s	file:
m_rzbbb_	core/model/GEqdsk.cpp	/^    geometry::Polygon<2> m_rzbbb_; \/\/!< R,Z of boundary points in meter$/;"	m	struct:simpla::GEqdsk::pimpl_s	file:
m_rzlim_	core/model/GEqdsk.cpp	/^    geometry::Polygon<2> m_rzlim_; \/\/!< R,Z of surrounding limiter contour in meter$/;"	m	struct:simpla::GEqdsk::pimpl_s	file:
m_rzmax_	core/model/GEqdsk.cpp	/^    point_type m_rzmax_;$/;"	m	struct:simpla::GEqdsk::pimpl_s	file:
m_rzmin_	core/model/GEqdsk.cpp	/^    point_type m_rzmin_;$/;"	m	struct:simpla::GEqdsk::pimpl_s	file:
m_seed_	core/particle/ParticleGenerator.h	/^        seed_type m_seed_;$/;"	m	struct:simpla::particle::ParticleGenerator::input_iterator
m_seed_	core/particle/ParticleGenerator.h	/^    TSeed m_seed_;$/;"	m	struct:simpla::particle::ParticleGenerator
m_selected_points_	core/data_model/DataSpace.cpp	/^    std::vector<size_t> m_selected_points_;$/;"	m	struct:simpla::data_model::DataSpace::pimpl_s	file:
m_self_	core/gtl/iterator/block_iterator.h	/^    nTuple<TV, NDIMS> m_min_, m_max_, m_self_;$/;"	m	struct:simpla::block_iterator
m_self_	core/gtl/iterator/sp_ntuple_range.h	/^    ntuple_type m_min_, m_max_, m_self_;$/;"	m	struct:simpla::sp_nTuple_range::iterator
m_self_	core/particle/ParticleProxy.h	/^    std::shared_ptr<particle_type> m_self_;$/;"	m	class:simpla::particle::ParticleProxy
m_send_recv_buffer_	core/parallel/trash/distributed_unordered_set.cpp	/^	std::vector<mpi_send_recv_buffer_s> m_send_recv_buffer_;$/;"	m	struct:simpla::DistributedUnorderedSetBase::pimpl_s	file:
m_send_recv_list_	core/parallel/trash/distributed_unordered_set.cpp	/^	std::vector<mpi_send_recv_s> m_send_recv_list_;$/;"	m	struct:simpla::DistributedUnorderedSetBase::pimpl_s	file:
m_sign_flag_	core/gtl/iterator/sp_ntuple_range.h	/^    typename std::make_signed<IndexType>::type m_sign_flag_ = 0;$/;"	m	struct:simpla::sp_nTuple_range::iterator
m_size_	core/gtl/type_traits.h	/^    static constexpr int m_size_ = sizeof...(_I);$/;"	m	struct:simpla::integer_sequence
m_slot_	core/gtl/design_pattern/signal.h	/^    std::function<result_type(Args...)> m_slot_;$/;"	m	struct:simpla::Signal::Slot
m_slots_	core/gtl/design_pattern/signal.h	/^    std::list<Slot> m_slots_;$/;"	m	struct:simpla::Signal
m_slow_first_	core/gtl/iterator/sp_ntuple_range.h	/^    bool m_slow_first_ = true;$/;"	m	struct:simpla::sp_nTuple_range
m_slow_first_	core/gtl/iterator/sp_ntuple_range.h	/^    bool m_slow_first_ = true;$/;"	m	struct:simpla::sp_nTuple_range::iterator
m_start_	core/gtl/array_view.h	/^    nTuple<size_t, MAX_NDIMS_OF_ARRAY> m_start_;$/;"	m	struct:simpla::gtl::ArrayViewBase
m_start_	core/gtl/containers/sp_ndarray.h	/^	value_type * m_start_;$/;"	m	class:simpla::ndArray
m_start_	core/parallel/DistributedCounter.h	/^    std::atomic<size_t> m_start_, m_end_;$/;"	m	struct:simpla::parallel::DistributedCounter
m_start_	core/parallel/ParallelRandomGenerator.h	/^    std::atomic<size_t> m_start_, m_end_;$/;"	m	struct:simpla::parallel::DistributedCounter
m_state_	core/gtl/utilities/lua_object.h	/^            lua_State *m_state_;$/;"	m	struct:simpla::lua::LuaObject::LuaState::lua_s
m_std_out_level_	core/gtl/utilities/log.cpp	/^    int m_std_out_level_;$/;"	m	struct:simpla::logger::LoggerStreams	file:
m_strides_	core/gtl/array_view.h	/^    nTuple<size_t, MAX_NDIMS_OF_ARRAY> m_strides_;$/;"	m	struct:simpla::gtl::ArrayViewBase
m_sub_index_to_id_	core/manifold/mesh/MeshIds.h	/^    static constexpr int m_sub_index_to_id_[4][3] = { \/\/$/;"	m	struct:simpla::mesh::MeshEntityIdCoder
m_sub_index_to_id_	core/manifold/mesh/MeshIds.h	/^template<int L> constexpr int MeshEntityIdCoder<L>::m_sub_index_to_id_[4][3];$/;"	m	class:simpla::mesh::MeshEntityIdCoder
m_subject_	core/gtl/design_pattern/observer.h	/^	std::shared_ptr<Observable> m_subject_;$/;"	m	struct:simpla::Observer
m_t_index_	core/data_model/DataType.cpp	/^    std::type_index m_t_index_;$/;"	m	struct:simpla::data_model::DataType::pimpl_s	file:
m_temperature_	core/particle/ParticleGenerator.h	/^    std::function<Real(point_type const &)> m_temperature_;$/;"	m	class:simpla::particle::ParticleGeneratorPerCell
m_time_	core/manifold/Manifold.h	/^    double m_time_;$/;"	m	class:simpla::Manifold
m_time_	core/manifold/obsoleted/time_integrator_policy.h	/^    double m_time_;$/;"	m	struct:simpla::manifold::policy::TimeIntegrator
m_topology_coord_	core/parallel/MPIComm.cpp	/^    nTuple<int, NDIMS> m_topology_coord_;$/;"	m	struct:simpla::parallel::MPIComm::pimpl_s	file:
m_topology_dims_	core/parallel/MPIComm.cpp	/^    nTuple<int, NDIMS> m_topology_dims_;$/;"	m	struct:simpla::parallel::MPIComm::pimpl_s	file:
m_topology_strides_	core/parallel/MPIComm.cpp	/^    nTuple<int, NDIMS> m_topology_strides_;$/;"	m	struct:simpla::parallel::MPIComm::pimpl_s	file:
m_tracker_	core/gtl/design_pattern/signal.h	/^    std::shared_ptr<AbstractTracker> m_tracker_;$/;"	m	struct:simpla::Signal::Slot
m_type	core/field/test/trash/field_vector_calculus_Cartesian_complex_test.cpp	/^		FiniteDiffMethod, InterpolatorLinear> m_type;$/;"	t	file:
m_type	core/field/test/trash/field_vector_calculus_Cartesian_vec3_test.cpp	/^		FiniteDiffMethod, InterpolatorLinear> m_type;$/;"	t	file:
m_type	core/field/test/trash/field_vector_calculus_cylindrical_test.cpp	/^		FiniteDiffMethod, InterpolatorLinear> m_type;$/;"	t	file:
m_type_	core/parallel/MPIDataType.h	/^    MPI_Datatype m_type_ = MPI_DATATYPE_NULL;$/;"	m	struct:simpla::MPIDataType
m_url_	core/io/WriteBuffer.h	/^    std::string m_url_;$/;"	m	class:simpla::io::WriteBuffer
m_v_dist_	core/particle/ParticleGenerator.h	/^        v_dist_engine m_v_dist_;$/;"	m	struct:simpla::particle::ParticleGenerator::input_iterator
m_value	core/gtl/any.h	/^    T m_value;$/;"	m	struct:simpla::Derived
m_value_	core/field/obsoleted/field_constant.h	/^	value_type m_value_;$/;"	m	class:simpla::Field
m_value_	core/gtl/iterator/sp_indirect_iterator.h	/^    value_container_type &m_value_;$/;"	m	struct:simpla::sp_indirect_range
m_value_	core/gtl/utilities/config_parser.h	/^        std::string m_value_;$/;"	m	struct:simpla::ConfigParser::DictObject
m_value_	core/particle/ParticleGenerator.h	/^        value_type m_value_;$/;"	m	struct:simpla::particle::ParticleGenerator::input_iterator
m_volume_	core/manifold/mesh/CartesianCoRect.h	/^    Real m_volume_[9];$/;"	m	struct:simpla::mesh::CartesianCoRect
m_volume_	core/manifold/mesh/CoRectMesh.h	/^    Real m_volume_[9];$/;"	m	struct:simpla::mesh::Mesh
m_volume_	core/manifold/mesh/CylindricalCoRect.h	/^    std::vector<Real> m_volume_;$/;"	m	class:simpla::mesh::CylindricalCoRect
m_volume_	core/manifold/mesh/RectMesh.h	/^    std::shared_ptr<Real> m_volume_;$/;"	m	struct:simpla::mesh::Mesh
m_x0_	core/geometry/model.h	/^	point_type m_x0_;$/;"	m	struct:simpla::geometry::model::Primitive
m_x0_	core/geometry/polygon.h	/^    point_type m_x0_, m_x1_;$/;"	m	struct:simpla::geometry::Polygon
m_x1_	core/geometry/polygon.h	/^    point_type m_x0_, m_x1_;$/;"	m	struct:simpla::geometry::Polygon
m_x_dist_	core/particle/ParticleGenerator.h	/^        x_dist_engine m_x_dist_;$/;"	m	struct:simpla::particle::ParticleGenerator::input_iterator
m_zdim_	core/model/GEqdsk.cpp	/^    Real m_zdim_; \/\/!< Vertical dimension in meter of computational box$/;"	m	struct:simpla::GEqdsk::pimpl_s	file:
m_zmaxis	core/model/GEqdsk.cpp	/^    Real m_zmaxis = 1.0; \/\/!< Z of magnetic axis in meter$/;"	m	struct:simpla::GEqdsk::pimpl_s	file:
m_zmid_	core/model/GEqdsk.cpp	/^    Real m_zmid_; \/\/!< Z of center of computational box in meter$/;"	m	struct:simpla::GEqdsk::pimpl_s	file:
magnetic_axis	core/model/GEqdsk.cpp	/^GEqdsk::point_type GEqdsk::magnetic_axis() const$/;"	f	class:simpla::GEqdsk
main	applications/fokker_planck/lhw.cpp	/^int main(int argc, char **argv)$/;"	f
main	applications/simpla.cpp	/^int main(int argc, char **argv)$/;"	f
main	core/field/test/field_io_test.cpp	/^int main(int argc, char **argv)$/;"	f
main	core/geometry/obsolete/polygons.h	/^int main()$/;"	f
main	core/gtl/test/log_test.cpp	/^int main(int argc, char **argv)$/;"	f
main	core/gtl/test/lua_state_test.cpp	/^int main(int argc, char **argv)$/;"	f
main	core/gtl/test/memory_pool_test.cpp	/^int main(int argc, char **argv)$/;"	f
main	core/gtl/test/ntuple_test.cpp	/^int main(int argc, char **argv)$/;"	f
main	core/model/geqdsk_convert.cpp	/^int main(int argc, char **argv)$/;"	f
main	core/parallel/test/multi_thread_test.cpp	/^int main(int argc, char **argv)$/;"	f
main	core/particle/test/particle_generator_test.cpp	/^int main(int argc, char **argv)$/;"	f
main	core/particle/test/particle_test.cpp	/^int main(int argc, char **argv)$/;"	f
main	core/particle/test/probe_particle_test.cpp	/^int main(int argc, char **argv)$/;"	f
main	core/task_flow/application_main.cpp	/^int main(int argc, char **argv)$/;"	f
main	core/task_flow/use_case_main.cpp	/^int main(int argc, char **argv)$/;"	f
main	cpplint.py	/^def main():$/;"	f
main	example/em/em_task.cpp	/^int main(int argc, char **argv)$/;"	f
main	example/em_tokamak/tokamak.cpp	/^int main(int argc, char **argv)$/;"	f
main	example/geometry/demo_geometry.cpp	/^int main(int argc, char **argv)$/;"	f
main	example/mhd/demo_mhd.cpp	/^int main(int argc, char **argv)$/;"	f
main	example/misc/demo_misc.cpp	/^int main()$/;"	f
main	example/misc/demo_misc2.cpp	/^int main(int argc, char **argv)$/;"	f
main	example/misc/demo_misc3.cpp	/^int main(int argc, char **argv)$/;"	f
main	example/pic/test_vi.cpp	/^int main(int argc, char **argv)$/;"	f
make_cycle_iterator	core/gtl/iterator/sp_iterator_cycle.h	/^CycleIterator<TIterator> make_cycle_iterator(TIterator const & b,$/;"	f	namespace:simpla
make_cycle_iterator	core/gtl/iterator/sp_iterator_cycle.h	/^CycleIterator<TIterator> make_cycle_iterator(TIterator const & self,$/;"	f	namespace:simpla
make_field	core/field/test/trash/fetl_test2.h	/^	Field<domain_type, value_type> make_field() const$/;"	f	class:TestField
make_field	core/manifold/pre_define/PreDefine.h	/^make_field(TM const &mesh) { return field_t<TV, TM, I>(mesh); };$/;"	f	namespace:simpla::traits
make_field_constant	core/field/obsoleted/field_constant.h	/^Field<TM, TV, _impl::this_is_constant> make_field_constant(TM const &m,$/;"	f	namespace:simpla
make_field_function	core/manifold/pre_define/PreDefine.h	/^field_function_t<TV, TM, IFORM, TDict> make_field_function(TM const &m, TDict const &dict)$/;"	f	namespace:simpla::traits
make_field_function_from_config	core/manifold/pre_define/PreDefine.h	/^field_function_t<TV, TM, IFORM, TDict> make_field_function_from_config(TM const &m, TDict const &dict)$/;"	f	namespace:simpla::traits
make_filter_iterator	core/gtl/iterator/sp_iterator_filter.h	/^sp_fliter_iterator<BaseIterator, TPred> make_filter_iterator(BaseIterator first,$/;"	f	namespace:simpla
make_function_cache	core/gtl/function_cache.h	/^FunctionCache<TRect, TFun, Hash> make_function_cache(TFun const & fun,$/;"	f	namespace:simpla
make_function_cache	core/gtl/function_cache.h	/^FunctionCache<TRect, TFun, void> make_function_cache(TFun const & fun)$/;"	f	namespace:simpla
make_hash	core/gtl/utilities/misc_utilities.h	/^inline unsigned long make_hash(T s)$/;"	f	namespace:simpla
make_implicit_function	core/geometry/implicit_function.h	/^ImplicitFunction<TFun> make_implicit_function(TFun const & fun)$/;"	f	namespace:simpla
make_indirect_iterator	core/gtl/iterator/indirect_iterator.h	/^constexpr indirect_iterator<TSIterator> make_indirect_iterator($/;"	f	namespace:simpla
make_iterator_proxy	core/gtl/containers/iterator_proxy.h	/^iterator_proxy<TD, TIterator> make_iterator_proxy(TD &d, TIterator const &it)$/;"	f	namespace:simpla
make_kinetic_particle	core/particle/obsolete/kinetic_particle.h	/^make_kinetic_particle($/;"	f	namespace:simpla
make_mesh	core/manifold/ManifoldTraits.h	/^std::shared_ptr<Manifold<TMesh, Policies...>> make_mesh()$/;"	f	namespace:simpla
make_msg	core/gtl/utilities/log.h	/^std::string make_msg(Others const &...others)$/;"	f	namespace:simpla::logger
make_nTuple	core/gtl/ntuple.h	/^nTuple<T, 1 + sizeof...(Others), M...> make_nTuple(nTuple<T, M...> const &a0, Others &&... others)$/;"	f	namespace:simpla::traits
make_nTuple	core/gtl/ntuple.h	/^nTuple<T0, 1 + sizeof...(Others)> make_nTuple(T0 const &a0, Others &&... others)$/;"	f	namespace:simpla::traits
make_ntuple_range	core/gtl/iterator/sp_ntuple_range.h	/^sp_nTuple_range<TIndex, DIMS...> make_ntuple_range($/;"	f	namespace:simpla
make_pod_array	core/gtl/ntuple.h	/^struct make_pod_array<TV, integer_sequence<TI, N0, N...>>$/;"	s	namespace:simpla::traits::_impl
make_pod_array	core/gtl/ntuple.h	/^struct make_pod_array<TV, integer_sequence<TI>>$/;"	s	namespace:simpla::traits::_impl
make_point	applications/particle_solver/pic_engine_deltaf2.h	/^	static inline Point_s make_point(coordinate_tuple const & x, Vec3 const &v, Real f)$/;"	f	struct:simpla::PICEngineDeltaF
make_point	applications/particle_solver/pic_engine_ggauge.h	/^	static inline Point_s make_point(coordinate_tuple const & x, Vec3 const &v, Real f)$/;"	f	class:simpla::PICEngineGGauge
make_point	applications/particle_solver/pic_engine_implicit.h	/^	static inline Point_s make_point(coordinate_tuple const & x, Vec3 const &v, Real f)$/;"	f	struct:simpla::PICEngineImplicit
make_primary_nTuple	core/gtl/ntuple.h	/^struct make_primary_nTuple<TV, integer_sequence<TI, N...>>$/;"	s	namespace:simpla::traits::_impl
make_primary_nTuple	core/gtl/ntuple.h	/^struct make_primary_nTuple<TV, integer_sequence<TI>>$/;"	s	namespace:simpla::traits::_impl
make_range	core/manifold/mesh/MeshIds.h	/^    static range_type make_range(T0 const &b, T1 const &e)$/;"	f	struct:simpla::mesh::MeshEntityIdCoder
make_range	core/manifold/mesh/MeshIds.h	/^    static range_type make_range(T0 const &min, T1 const &max, int iform = VERTEX)$/;"	f	struct:simpla::mesh::MeshEntityIdCoder
make_range	core/manifold/mesh/MeshIds.h	/^    static range_type make_range(TB const &b)$/;"	f	struct:simpla::mesh::MeshEntityIdCoder
make_scalarField	core/field/test/trash/fetl_test2.h	/^	Field<domain_type, Real> make_scalarField() const$/;"	f	class:TestField
make_select_function_by_config	core/geometry/select.h	/^std::function<bool(TCoord const &)> make_select_function_by_config($/;"	f	namespace:simpla
make_select_function_by_config	core/model/obsoleted/select.h	/^std::function<bool(TCoord const &)> make_select_function_by_config($/;"	f	namespace:simpla
make_send_recv_list	core/parallel/trash/distributed_unordered_set.cpp	/^void DistributedUnorderedSetBase::make_send_recv_list(int object_id, DataType const &datatype, int ndims,$/;"	f	class:simpla::DistributedUnorderedSetBase
make_send_recv_tag	core/parallel/MPIComm.cpp	/^std::tuple<int, int, int> MPIComm::make_send_recv_tag(int prefix,$/;"	f	class:simpla::parallel::MPIComm
make_seq_iterator	core/gtl/iterator/iterator_sequence.h	/^IteratorSequence<TI> make_seq_iterator(TI const & b)$/;"	f	namespace:simpla
manifold	core/field/test/trash/fetl_test3.h	/^	manifold_type manifold;$/;"	m	class:TestFETL
manifold	core/manifold/obsoleted/amr_policy.h	/^namespace simpla { namespace manifold { namespace policy$/;"	n	namespace:simpla
manifold	core/manifold/obsoleted/embedded_policy.h	/^namespace simpla { namespace manifold { namespace policy$/;"	n	namespace:simpla
manifold	core/manifold/obsoleted/fiber_bundle.h	/^namespace simpla { namespace manifold$/;"	n	namespace:simpla
manifold	core/manifold/obsoleted/time_integrator_policy.h	/^namespace simpla { namespace manifold { namespace policy$/;"	n	namespace:simpla
manifold	core/manifold/policy/FvmStructuredPolicy.h	/^namespace simpla { namespace manifold { namespace policy$/;"	n	namespace:simpla
manifold	core/manifold/policy/IOPolicy.h	/^namespace manifold { namespace policy$/;"	n	namespace:simpla
manifold	core/manifold/policy/LinearInterpolatorPolicy.h	/^namespace simpla { namespace manifold { namespace policy$/;"	n	namespace:simpla
manifold	core/manifold/policy/ParallelPolicy.h	/^namespace simpla { namespace manifold { namespace policy$/;"	n	namespace:simpla
manifold	core/manifold/policy/StoragePolicy.h	/^namespace manifold { namespace policy$/;"	n	namespace:simpla
manifold	core/manifold/pre_define/PreDefine.h	/^namespace simpla { namespace manifold$/;"	n	namespace:simpla
manifold	core/manifold/pre_define/mock.h	/^namespace manifold$/;"	n	namespace:simpla
manifold	core/manifold/pre_define/riemannian.h	/^namespace manifold$/;"	n	namespace:simpla
manifold_type	core/field/test/trash/fetl_test3.h	/^	typedef TManifold manifold_type;$/;"	t	class:TestFETL
manifold_type	core/field/test/trash/field_basic_algebra_Cartesian_test.cpp	/^		FiniteDiffMethod, InterpolatorLinear> manifold_type;$/;"	t	file:
manifold_type	core/field/test/trash/field_basic_algebra_cylindrical_test.cpp	/^		FiniteDiffMethod, InterpolatorLinear> manifold_type;$/;"	t	file:
manifold_type	core/geometry/test/geometry_test.cpp	/^			InterpolatorLinear> manifold_type;$/;"	t	class:TestModel	file:
manifold_type	core/model/test/model_test.cpp	/^			InterpolatorLinear> manifold_type;$/;"	t	class:TestModel	file:
map	core/manifold/mesh/GeneralMap.h	/^    TP *map(TP *x) const$/;"	f	struct:simpla::mesh::GeneralMap
map	core/manifold/mesh/GeneralMap.h	/^    TP map(TP const &x) const$/;"	f	struct:simpla::mesh::GeneralMap
map	core/manifold/mesh/GeneralMap.h	/^    point_type *map(point_type *x) const$/;"	f	struct:simpla::mesh::SquareMap
map	core/manifold/mesh/GeneralMap.h	/^    point_type map(U const &x) const$/;"	f	struct:simpla::mesh::SquareMap
map	core/manifold/mesh/LinearMap.h	/^    point_type map(point_type const &y) const$/;"	f	struct:simpla::mesh::LinearMap
map	core/manifold/mesh/MeshBlock.h	/^    point_type map(point_type const &y) const$/;"	f	struct:simpla::mesh::MeshBlock
map_to	core/manifold/Calculus.h	/^inline Field<Expression<calculus::tags::MapTo, T, std::integral_constant<int, I>>> map_to($/;"	f	namespace:simpla
map_to_cartesian	core/geometry/csCartesian.h	/^    static inline point_type map_to_cartesian(point_type const &p)$/;"	f	struct:simpla::geometry::CartesianMetric
map_to_cartesian	core/geometry/csCylindrical.h	/^    static point_type map_to_cartesian(point_type const &p)$/;"	f	struct:simpla::geometry::Metric
map_type	core/gtl/Properties.h	/^    typedef std::map<key_type, this_type> map_type;$/;"	t	class:simpla::Properties
mass	core/phy_solver/em_fluid.h	/^        Real mass;$/;"	m	struct:simpla::phy_solver::EMFluid::fluid_s
mass	example/em_tokamak/tokamak.cpp	/^        Real mass;$/;"	m	struct:simpla::EMTokamak::fluid_s	file:
max	core/gtl/mpl.h	/^struct max<_Tp, first, Others...> : std::integral_constant<_Tp,$/;"	s	namespace:simpla::mpl
max	core/gtl/mpl.h	/^struct max<_Tp, first, second> : std::integral_constant<_Tp,$/;"	s	namespace:simpla::mpl
max	core/gtl/mpl.h	/^struct max<_Tp, first> : std::integral_constant<_Tp, first>$/;"	s	namespace:simpla::mpl
max	core/gtl/type_traits.h	/^T0 const &max(T0 const &first)$/;"	f	namespace:simpla::traits
max	core/gtl/type_traits.h	/^T0 const &max(T0 const &first, Others const &...others)$/;"	f	namespace:simpla::traits
max	core/gtl/type_traits.h	/^T0 max(T0 const &first)$/;"	f	namespace:simpla
max	core/gtl/type_traits.h	/^T0 max(T0 const &first, Others &&...others)$/;"	f	namespace:simpla
max	core/gtl/type_traits.h	/^T0 max(T0 const &first, T1 const &second)$/;"	f	namespace:simpla
max	core/numeric/sobol_engine.h	/^	result_type max() const$/;"	f	class:simpla::sobol_engine
max_buffer_depth	core/io/WriteBuffer.h	/^    void max_buffer_depth(size_t s) { m_max_buffer_depth_ = s; }$/;"	f	class:simpla::io::WriteBuffer
max_hash	core/gtl/containers/sp_hash_container.h	/^	size_t max_hash() const$/;"	f	struct:simpla::SpHashContainer
max_hash	core/gtl/containers/sp_hash_container.h	/^	void max_hash(size_t m) const$/;"	f	struct:simpla::SpHashContainer
max_hash	core/manifold/mesh/MeshBlock.h	/^    size_t max_hash() const$/;"	f	struct:simpla::mesh::MeshBlock
max_hash	core/manifold/mesh/MeshIds.h	/^    static constexpr size_t max_hash(id_type b, id_type e)$/;"	f	struct:simpla::mesh::MeshEntityIdCoder
max_material_	core/model/obsoleted/model.h	/^    int max_material_;$/;"	m	class:simpla::Model
max_num_of_points	core/geometry/model.h	/^	static constexpr size_t max_num_of_points = traits::number_of_points<$/;"	m	struct:simpla::geometry::model::Surface
max_number_of_points	core/geometry/chains.h	/^    static constexpr size_t max_number_of_points = traits::number_of_points<$/;"	m	struct:simpla::geometry::model::Chains
max_pool_depth_	core/gtl/utilities/memory_pool.cpp	/^    size_t max_pool_depth_ = 16 * ONE_GIGA;$/;"	m	struct:simpla::MemoryPool::pimpl_s	file:
max_size	core/gtl/utilities/memory_pool.cpp	/^void MemoryPool::max_size(size_t s)$/;"	f	class:simpla::MemoryPool
mdeg	core/numeric/sobol_engine.h	/^	const  unsigned int  mdeg[MAXDIM] =$/;"	m	class:simpla::sobol_engine
members	core/data_model/DataType.cpp	/^std::vector<std::tuple<DataType, std::string, int>> const &DataType::members() const$/;"	f	class:simpla::data_model::std::DataType
memory_index_box	core/manifold/mesh/MeshBlock.h	/^    index_box_type memory_index_box() const$/;"	f	struct:simpla::mesh::MeshBlock
memory_length	core/particle/obsolete/probe_particle.h	/^    static constexpr size_t memory_length = check_member_value_memory_length<engine_type>::value;$/;"	m	struct:simpla::ProbeParticle
memory_length	example/probe_particle/demo_probe_particle.h	/^	static constexpr size_t memory_length = 0; \/\/!  declare this engine is memoryless$/;"	m	struct:simpla::ProbeDemo
memory_size	core/manifold/policy/StoragePolicy.h	/^    size_t memory_size() const$/;"	f	struct:simpla::manifold::policy::StoragePolicy
memory_space	core/data_model/DataSet.h	/^    DataSpace memory_space;$/;"	m	struct:simpla::data_model::DataSet
merge	core/geometry/obsolete/surface.h	/^	bool merge(id_type s)$/;"	f	class:simpla::Surface
merge	core/gtl/containers/UnorderedSet.h	/^UnorderedSet<ValueType, Key>::merge(buffer_type *buffer) { merge(buffer, buffer->range()); }$/;"	f	class:simpla::gtl::UnorderedSet
merge	core/gtl/containers/UnorderedSet.h	/^UnorderedSet<ValueType, Key>::merge(buffer_type *other, TRange const &r0)$/;"	f	class:simpla::gtl::UnorderedSet
merge	core/particle/ParticleContainer.h	/^ParticleContainer<V, K>::merge(buffer_type *buffer)$/;"	f	class:simpla::particle::ParticleContainer
merge	core/particle/ParticleContainer.h	/^ParticleContainer<V, K>::merge(buffer_type *other, TRange const &r0)$/;"	f	class:simpla::particle::ParticleContainer
merge	core/particle/ParticleContainer.h	/^ParticleContainer<V, K>::merge(buffer_type *other, id_type s)$/;"	f	class:simpla::particle::ParticleContainer
mesh	applications/field_solver/implicitPushE.h	/^    std::shared_ptr<mesh_type> mesh;$/;"	m	class:simpla::ImplicitPushE
mesh	applications/particle_solver/fluid_cold_engine.h	/^	mesh_type const & mesh;$/;"	m	class:simpla::Particle
mesh	applications/particle_solver/pic_engine_deltaf2.h	/^	mesh_type const &mesh;$/;"	m	struct:simpla::PICEngineDeltaF
mesh	applications/particle_solver/pic_engine_ggauge.h	/^	mesh_type const &mesh;$/;"	m	class:simpla::PICEngineGGauge
mesh	applications/particle_solver/pic_engine_implicit.h	/^	mesh_type const &mesh;$/;"	m	struct:simpla::PICEngineImplicit
mesh	core/base/Attribute.h	/^    mesh_type const &mesh() const { return *m_const_mesh_; }$/;"	f	class:simpla::base::AttributeEntity
mesh	core/base/Attribute.h	/^    mesh_type const &mesh() { return *m_const_mesh_; }$/;"	f	class:simpla::base::AttributeEntity
mesh	core/field/FieldDense.h	/^    mesh_type const &mesh() const { return attribute()->mesh(); }$/;"	f	class:simpla::Field
mesh	core/field/obsoleted/field_sparse.h	/^	mesh_type const & mesh() const$/;"	f	struct:simpla::Field
mesh	core/field/test/field_basic_algebra_test.cpp	/^        TestField<TF>::mesh = std::make_shared<typename TestField<TF>::mesh_type>();$/;"	m	class:TestField	file:
mesh	core/field/test/field_basic_algebra_test.h	/^    static std::shared_ptr<mesh_type> mesh;$/;"	m	class:TestField
mesh	core/field/test/field_diff_calculus_test.h	/^    std::shared_ptr<mesh_type> mesh;$/;"	m	class:FETLTest
mesh	core/field/test/field_dummy.cpp	/^	mesh_type mesh;$/;"	m	class:FieldTest	file:
mesh	core/field/test/field_io_test.h	/^	mesh_type mesh;$/;"	m	class:simpla::TestFieldIO
mesh	core/field/test/trash/field_basic_algebra_Cartesian_test.cpp	/^std::shared_ptr<typename TestField<TF>::manifold_type> TestField<TF>::mesh = \/\/$/;"	m	class:TestField	file:
mesh	core/field/test/trash/field_basic_algebra_cylindrical_test.cpp	/^std::shared_ptr<typename TestField<TF>::manifold_type> TestField<TF>::mesh = \/\/$/;"	m	class:TestField	file:
mesh	core/field/test/trash/field_basic_test.h	/^	mesh_type mesh;$/;"	m	class:TestField
mesh	core/field/test/trash/field_continue.h	/^	mesh_type const & mesh() const$/;"	f	struct:simpla::Field
mesh	core/field/test/trash/field_simple_mesh_shared_ptr_test.cpp	/^	static SimpleMesh mesh;$/;"	m	struct:TestFieldParam	file:
mesh	core/field/test/trash/field_simple_mesh_shared_ptr_test.cpp	/^template<> SimpleMesh TestFieldParam<field_type, 0>::mesh = SimpleMesh();$/;"	m	class:TestFieldParam	file:
mesh	core/field/test/trash/field_simple_mesh_shared_ptr_test.cpp	/^template<> SimpleMesh TestFieldParam<field_type, 1>::mesh = SimpleMesh();$/;"	m	class:TestFieldParam	file:
mesh	core/manifold/mesh/CartesianCoRect.h	/^namespace simpla { namespace mesh$/;"	n	namespace:simpla
mesh	core/manifold/mesh/CoRectMesh.h	/^namespace simpla { namespace mesh$/;"	n	namespace:simpla
mesh	core/manifold/mesh/CylindricalCoRect.h	/^namespace simpla { namespace mesh$/;"	n	namespace:simpla
mesh	core/manifold/mesh/GeneralMap.h	/^namespace simpla { namespace mesh$/;"	n	namespace:simpla
mesh	core/manifold/mesh/LinearMap.h	/^namespace simpla { namespace mesh$/;"	n	namespace:simpla
mesh	core/manifold/mesh/Mesh.h	/^namespace simpla { namespace mesh$/;"	n	namespace:simpla
mesh	core/manifold/mesh/MeshBlock.cpp	/^namespace simpla { namespace mesh$/;"	n	namespace:simpla	file:
mesh	core/manifold/mesh/MeshBlock.h	/^namespace simpla { namespace mesh$/;"	n	namespace:simpla
mesh	core/manifold/mesh/MeshIds.h	/^namespace simpla { namespace mesh$/;"	n	namespace:simpla
mesh	core/manifold/mesh/RectMesh.h	/^namespace simpla { namespace mesh$/;"	n	namespace:simpla
mesh	core/manifold/obsoleted/fiber_bundle.h	/^    mesh_type const &mesh() const { return m_mesh_; }$/;"	f	class:simpla::manifold::FiberBundle
mesh	core/manifold/obsoleted/mesh_graph.h	/^namespace simpla { namespace mesh$/;"	n	namespace:simpla
mesh	core/manifold/obsoleted/mesh_layout.h	/^namespace simpla { namespace mesh$/;"	n	namespace:simpla
mesh	core/manifold/obsoleted/patch/mesh_patch.h	/^namespace simpla { namespace mesh$/;"	n	namespace:simpla
mesh	core/manifold/obsoleted/samr_object.h	/^namespace simpla { namespace mesh$/;"	n	namespace:simpla
mesh	core/particle/Particle.h	/^    mesh_type const &mesh() const { return m_data_->mesh(); }$/;"	f	struct:simpla::particle::Particle
mesh	core/particle/test/kinetic_particle_test.cpp	/^	std::shared_ptr<mesh_type> mesh;$/;"	m	class:TestKineticParticle	file:
mesh	core/particle/test/kinetic_particle_test.h	/^	mesh_type mesh;$/;"	m	class:TestKineticParticle
mesh	example/pic/demo_pic.h	/^	base_manifold const &mesh() const { return m_mesh_; }$/;"	f	struct:simpla::FiberBundle
mesh_	core/field/test/trash/field_continue.h	/^	mesh_type mesh_;$/;"	m	struct:simpla::Field
mesh_attribute_entity	core/particle/ParticleContainer.h	/^    typedef typename M::AttributeEntity mesh_attribute_entity;$/;"	t	struct:simpla::particle::ParticleContainer
mesh_type	applications/contexts/explicit_em.h	/^    typedef TM mesh_type;$/;"	t	struct:simpla::ExplicitEMContext
mesh_type	applications/field_solver/implicitPushE.h	/^    typedef TM mesh_type;$/;"	t	class:simpla::ImplicitPushE
mesh_type	applications/field_solver/pml.h	/^	typedef TM mesh_type;$/;"	t	class:simpla::PML
mesh_type	applications/particle_solver/fluid_cold_engine.h	/^	typedef TM mesh_type;$/;"	t	class:simpla::Particle
mesh_type	applications/particle_solver/pic_engine_deltaf2.h	/^	typedef TM mesh_type;$/;"	t	struct:simpla::PICEngineDeltaF
mesh_type	applications/particle_solver/pic_engine_ggauge.h	/^	typedef TM mesh_type;$/;"	t	class:simpla::PICEngineGGauge
mesh_type	applications/particle_solver/pic_engine_implicit.h	/^	typedef TM mesh_type;$/;"	t	struct:simpla::PICEngineImplicit
mesh_type	core/base/Attribute.h	/^    typedef TMesh mesh_type;$/;"	t	class:simpla::base::Attribute
mesh_type	core/base/Attribute.h	/^    typedef TMesh mesh_type;$/;"	t	class:simpla::base::AttributeEntity
mesh_type	core/field/FieldDense.h	/^    typedef TMesh mesh_type;$/;"	t	class:simpla::Field
mesh_type	core/field/FieldDense.h	/^template<typename TV, typename TM, typename ...Others> struct mesh_type<Field<TV, TM, Others...> >$/;"	s	namespace:simpla::traits
mesh_type	core/field/FieldFunction.h	/^    typedef TMesh mesh_type;$/;"	t	class:simpla::Field
mesh_type	core/field/obsoleted/field_constant.h	/^	typedef TM mesh_type;$/;"	t	class:simpla::Field
mesh_type	core/field/obsoleted/field_patch.h	/^    typedef typename field_type::mesh_type mesh_type;$/;"	t	class:simpla::FieldAMRPolicy
mesh_type	core/field/obsoleted/field_sparse.h	/^	typedef TM mesh_type;$/;"	t	struct:simpla::Field
mesh_type	core/field/test/field_basic_algebra_test.cpp	/^typedef manifold::CartesianManifold mesh_type;$/;"	t	file:
mesh_type	core/field/test/field_basic_algebra_test.h	/^    typedef traits::manifold_type_t<field_type> mesh_type;$/;"	t	class:TestField
mesh_type	core/field/test/field_diff_calculus_test.h	/^typedef manifold::CylindricalManifold mesh_type;$/;"	t
mesh_type	core/field/test/field_dummy.cpp	/^	typedef TM mesh_type;$/;"	t	class:FieldTest	file:
mesh_type	core/field/test/field_io_test.h	/^	typedef typename TParam::mesh_type mesh_type;$/;"	t	class:simpla::TestFieldIO
mesh_type	core/field/test/trash/field_basic_test.h	/^	typedef typename field_type::mesh_type mesh_type;$/;"	t	class:TestField
mesh_type	core/field/test/trash/field_cartesian_map_test.cpp	/^		FiniteDiffMethod, InterpolatorLinear> mesh_type;$/;"	t	file:
mesh_type	core/field/test/trash/field_continue.h	/^	typedef TM mesh_type;$/;"	t	struct:simpla::Field
mesh_type	core/field/test/trash/field_simple_mesh_map_test.cpp	/^typedef SimpleMesh mesh_type;$/;"	t	file:
mesh_type	core/geometry/obsolete/polygon.h	/^	typedef TM mesh_type;$/;"	t	struct:simpla::PolyGon
mesh_type	core/geometry/obsolete/surface.h	/^	typedef TM mesh_type;$/;"	t	class:simpla::Surface
mesh_type	core/manifold/Manifold.h	/^    typedef TMesh mesh_type;$/;"	t	class:simpla::Manifold
mesh_type	core/manifold/ManifoldTraits.h	/^template<typename T> struct mesh_type$/;"	s	namespace:simpla::traits
mesh_type	core/manifold/obsoleted/amr_policy.h	/^    typedef TMesh mesh_type;$/;"	t	class:simpla::manifold::policy::AMR
mesh_type	core/manifold/obsoleted/fiber_bundle.h	/^    typedef M mesh_type; \/\/!<  Base space;$/;"	t	class:simpla::manifold::FiberBundle
mesh_type	core/manifold/obsoleted/fiber_bundle.h	/^    typedef M mesh_type;$/;"	t	struct:simpla::manifold::DirectMap
mesh_type	core/manifold/obsoleted/patch/mesh_patch.h	/^    typedef TM mesh_type;$/;"	t	class:simpla::mesh::MeshPatch
mesh_type	core/manifold/obsoleted/patch/mesh_patch.h	/^    typedef TM mesh_type;$/;"	t	class:simpla::mesh::PatchPolicy
mesh_type	core/manifold/policy/ParallelPolicy.h	/^    typedef TMesh mesh_type;$/;"	t	struct:simpla::manifold::policy::ParallelPolicy
mesh_type	core/particle/Particle.h	/^    typedef M mesh_type;$/;"	t	struct:simpla::particle::Particle
mesh_type	core/particle/ParticleContainer.h	/^    typedef M mesh_type;$/;"	t	struct:simpla::particle::ParticleContainer
mesh_type	core/particle/ParticleGenerator.h	/^    typedef typename particle_type::mesh_type mesh_type;$/;"	t	class:simpla::particle::ParticleGeneratorPerCell
mesh_type	core/particle/obsolete/kinetic_particle.h	/^    typedef typename domain_type::mesh_type mesh_type;$/;"	t	struct:simpla::_impl::particle_hasher
mesh_type	core/particle/pre_define/PICBoris.h	/^    typedef TM mesh_type;$/;"	t	struct:simpla::particle::engine::BorisEngine
mesh_type	core/particle/pre_define/PICGyro.h	/^    typedef TM mesh_type;$/;"	t	struct:simpla::particle::engine::GyroParticleWithCylindricalCoord
mesh_type	core/particle/test/kinetic_particle_test.cpp	/^	typedef SimpleMesh mesh_type;$/;"	t	class:TestKineticParticle	file:
mesh_type	core/particle/test/kinetic_particle_test.h	/^	typedef SimpleMesh mesh_type;$/;"	t	class:TestKineticParticle
mesh_type	core/particle/test/particle_test.cpp	/^typedef TManifold mesh_type;$/;"	t	file:
mesh_type	core/particle/test/probe_particle_test.cpp	/^typedef TManifold mesh_type;$/;"	t	file:
mesh_type	core/phy_solver/em_fluid.h	/^    typedef TM mesh_type;$/;"	t	class:simpla::phy_solver::EMFluid
mesh_type	example/em/demo_em.cpp	/^typedef manifold::CylindricalManifold mesh_type;$/;"	t	file:
mesh_type	example/em/em.cpp	/^typedef manifold::DefaultManifold<geometry::Metric<cs>, mesh::RectMesh<>> mesh_type;$/;"	t	file:
mesh_type	example/em_tokamak/tokamak.cpp	/^    typedef manifold::CylindricalManifold mesh_type;$/;"	t	struct:simpla::EMTokamak	file:
mesh_type	example/model/demo_model.cpp	/^		InterpolatorLinear, FiniteDiffMethod> mesh_type;$/;"	t	namespace:simpla	file:
mesh_type	example/pic/demo_pic.cpp	/^typedef manifold::Riemannian<3> mesh_type;$/;"	t	file:
metadata	scripts/animation.py	/^metadata = dict(title='Movie Test', artist='YuZhi',$/;"	v
metric_type	core/manifold/mesh/CartesianCoRect.h	/^    typedef geometry::CartesianMetric metric_type;$/;"	t	struct:simpla::mesh::CartesianCoRect
metric_type	core/manifold/mesh/CoRectMesh.h	/^    typedef TMetric metric_type;$/;"	t	struct:simpla::mesh::Mesh
metric_type	core/manifold/mesh/CylindricalCoRect.h	/^    typedef geometry::CylindricalMetric metric_type;$/;"	t	class:simpla::mesh::CylindricalCoRect
metric_type	core/manifold/mesh/Mesh.h	/^struct metric_type<::simpla::mesh::Mesh<T...>>$/;"	s	namespace:simpla::geometry::traits
metric_type	core/manifold/mesh/RectMesh.h	/^    typedef TMetric metric_type;$/;"	t	struct:simpla::mesh::Mesh
miminal_vertex	core/manifold/mesh/MeshIds.h	/^    static constexpr id_type miminal_vertex(id_type s)$/;"	f	struct:simpla::mesh::MeshEntityIdCoder
min	core/gtl/mpl.h	/^struct min<_Tp, first, Others...> : std::integral_constant<_Tp,$/;"	s	namespace:simpla::mpl
min	core/gtl/mpl.h	/^struct min<_Tp, first, second> : std::integral_constant<_Tp,$/;"	s	namespace:simpla::mpl
min	core/gtl/mpl.h	/^struct min<_Tp, first> : std::integral_constant<_Tp, first>$/;"	s	namespace:simpla::mpl
min	core/gtl/type_traits.h	/^T0 const &min(T0 const &first)$/;"	f	namespace:simpla::traits
min	core/gtl/type_traits.h	/^T0 const &min(T0 const &first, Others const &...others)$/;"	f	namespace:simpla::traits
min	core/gtl/type_traits.h	/^T0 min(T0 const &first)$/;"	f	namespace:simpla
min	core/gtl/type_traits.h	/^T0 min(T0 const &first, Others &&...others)$/;"	f	namespace:simpla
min	core/gtl/type_traits.h	/^T0 min(T0 const &first, T1 const &second)$/;"	f	namespace:simpla
min	core/numeric/sobol_engine.h	/^	result_type min() const$/;"	f	class:simpla::sobol_engine
model	applications/contexts/explicit_em.h	/^    std::shared_ptr<Model < mesh_type>> model;$/;"	m	struct:simpla::ExplicitEMContext
model	core/geometry/box.h	/^namespace model$/;"	n	namespace:simpla::geometry
model	core/geometry/chains.h	/^namespace model {$/;"	n	namespace:simpla::geometry
model	core/geometry/cube.h	/^namespace model$/;"	n	namespace:simpla::geometry
model	core/geometry/model.h	/^namespace model$/;"	n	namespace:simpla::geometry
model	core/geometry/primitive.h	/^namespace model$/;"	n	namespace:simpla::geometry
model	core/geometry/primitive_ext.h	/^namespace model$/;"	n	namespace:simpla::geometry
model	core/geometry/simplex.h	/^namespace model$/;"	n	namespace:simpla::geometry
model	core/geometry/test/geometry_test.cpp	/^	model_type model;$/;"	m	class:TestModel	file:
model	core/model/Constraint.h	/^namespace simpla { namespace model$/;"	n	namespace:simpla
model	core/model/test/model_test.cpp	/^	model_type model;$/;"	m	class:TestModel	file:
model_type	core/geometry/test/geometry_test.cpp	/^	typedef Model<manifold_type> model_type;$/;"	t	class:TestModel	file:
model_type	core/model/test/model_test.cpp	/^	typedef Model<manifold_type> model_type;$/;"	t	class:TestModel	file:
modify	core/gtl/containers/unordered_set.h	/^    void modify(TFun const &fun, key_type hint = 0)$/;"	f	class:simpla::UnorderedSet
mol_	core/physics/PhysicalConstants.h	/^    double mol_;    \/\/<< amount of substance [mole]$/;"	m	class:simpla::PhysicalConstants
move	example/pic/demo_pic.h	/^	void move(point_type *p0, Real dt, TE const &fE, TB const &fB, TJ *J) const$/;"	f	struct:simpla::FiberBundle
mpi_rank_	core/gtl/utilities/log.cpp	/^    int mpi_rank_ = 0, mpi_size_ = 1;$/;"	m	struct:simpla::logger::LoggerStreams	file:
mpi_size_	core/gtl/utilities/log.cpp	/^    int mpi_rank_ = 0, mpi_size_ = 1;$/;"	m	struct:simpla::logger::LoggerStreams	file:
mpl	core/gtl/integer_sequence.h	/^namespace mpl$/;"	n	namespace:simpla
mpl	core/gtl/mpl.h	/^namespace mpl$/;"	n	namespace:simpla
multi_normal_distribution	core/numeric/multi_normal_distribution.h	/^	multi_normal_distribution(RealType pT = 1.0, \/\/$/;"	f	class:simpla::multi_normal_distribution
multi_normal_distribution	core/numeric/multi_normal_distribution.h	/^	multi_normal_distribution(nTuple<RealType, N, N> const & pA,$/;"	f	class:simpla::multi_normal_distribution
multi_normal_distribution	core/numeric/multi_normal_distribution.h	/^	multi_normal_distribution(nTuple<RealType, N> const & pT,$/;"	f	class:simpla::multi_normal_distribution
multi_normal_distribution	core/numeric/multi_normal_distribution.h	/^class multi_normal_distribution$/;"	c	namespace:simpla
multiple_	core/geometry/polygon.h	/^    std::vector<Real> multiple_;$/;"	m	struct:simpla::geometry::Polygon
my_hash	core/parallel/test/multi_thread_test.cpp	/^struct my_hash$/;"	s	file:
n	core/gtl/type_traits_ext.h	/^	static const unsigned long n = 0;$/;"	m	struct:simpla::CountBits
n	core/gtl/type_traits_ext.h	/^	static const unsigned long n = CountBits<N \/ 2>::n + 1;$/;"	m	struct:simpla::CountBits
n0	applications/contexts/explicit_em.h	/^    field<Real, VERTEX> n0; \/\/!< background  equilibrium electron density$/;"	m	struct:simpla::ExplicitEMContext
n0	applications/particle_solver/pic_engine_deltaf2.h	/^	Field<mesh_type, VERTEX, Real> n0;$/;"	m	struct:simpla::PICEngineDeltaF
n0	core/particle/pre_define/PICGyro.h	/^    scalar_field n0;$/;"	m	struct:simpla::particle::engine::GyroParticleWithCylindricalCoord
nTuple	core/gtl/ntuple.h	/^struct nTuple<BooleanExpression<TOP, T...> > : public nTuple<$/;"	s	namespace:simpla
nTuple	core/gtl/ntuple.h	/^struct nTuple<Expression<T...>> : public Expression<T...>$/;"	s	namespace:simpla
nTuple	core/gtl/ntuple.h	/^struct nTuple<Expression<TOP, ARG0, ARG1>> : public Expression<TOP, ARG0, ARG1>$/;"	s	namespace:simpla
nTuple	core/gtl/ntuple.h	/^struct nTuple<Expression<TOP, ARG0>> : public Expression<TOP, ARG0>$/;"	s	namespace:simpla
nTuple	core/gtl/ntuple.h	/^struct nTuple<TV, N, M...>$/;"	s	namespace:simpla
nTuple	core/gtl/ntuple.h	/^struct nTuple<TV>$/;"	s	namespace:simpla
nTuplePerf1	core/gtl/test/ntuple_perf_test.cpp	/^class nTuplePerf1<nTuple<T, N>> : public testing::Test$/;"	c	file:
nTuplePerf2	core/gtl/test/ntuple_perf_test.cpp	/^class nTuplePerf2<nTuple<T, N, M>> : public testing::Test$/;"	c	file:
n_field	core/particle/pre_define/PICGyro.h	/^    typedef traits::field_t<scalar_type, mesh_type, VERTEX> n_field;$/;"	t	struct:simpla::particle::engine::GyroParticleWithCylindricalCoord
name	core/base/Attribute.h	/^    virtual std::string name() const$/;"	f	class:simpla::base::AttributeObject
name	core/data_model/DataType.cpp	/^std::string DataType::name() const$/;"	f	class:simpla::data_model::DataType
name	core/geometry/csCylindrical.h	/^    static std::string name()$/;"	f	struct:simpla::traits::type_id
name	core/gtl/type_traits.h	/^    static std::string name()$/;"	f	struct:simpla::traits::type_id
name	core/manifold/ManifoldTraits.h	/^    static std::string name()$/;"	f	struct:simpla::traits::type_id
name	core/manifold/mesh/MeshCommon.h	/^template<typename TAG> struct type_id<Topology<TAG>> { static std::string name() { return "Topology<>"; }};$/;"	f	struct:simpla::traits::type_id
name	core/manifold/obsoleted/time_integrator_policy.h	/^    static std::string name()$/;"	f	struct:simpla::traits::type_id
name	core/manifold/policy/IOPolicy.h	/^    static std::string name()$/;"	f	struct:simpla::traits::type_id
name_	core/gtl/design_pattern/visitor.h	/^    std::string name_;$/;"	m	struct:simpla::Visitor
ndArray	core/gtl/containers/sp_ndarray.h	/^	ndArray()$/;"	f	class:simpla::ndArray
ndArray	core/gtl/containers/sp_ndarray.h	/^	ndArray(index_tuple const & d)$/;"	f	class:simpla::ndArray
ndArray	core/gtl/containers/sp_ndarray.h	/^	ndArray(this_type && other)$/;"	f	class:simpla::ndArray
ndArray	core/gtl/containers/sp_ndarray.h	/^	ndArray(this_type const & other)$/;"	f	class:simpla::ndArray
ndArray	core/gtl/containers/sp_ndarray.h	/^class ndArray$/;"	c	namespace:simpla
ndArray	core/gtl/containers/sp_ndarray.h	/^class ndArray<T, 1>$/;"	c	namespace:simpla
ndims	core/field/FieldFunction.h	/^    static constexpr int ndims = mesh_type::ndims;$/;"	m	class:simpla::Field
ndims	core/field/test/field_diff_calculus_test.h	/^    static constexpr size_t ndims = mesh_type::ndims;$/;"	m	class:FETLTest
ndims	core/geometry/primitive.h	/^    static const int ndims = simpla::geometry::traits::dimension<$/;"	m	struct:simpla::geometry::model::Vector
ndims	core/geometry/primitive.h	/^    static const size_t ndims = simpla::geometry::traits::dimension<$/;"	m	struct:simpla::geometry::model::CoVector
ndims	core/geometry/primitive.h	/^    static const size_t ndims = simpla::geometry::traits::dimension<$/;"	m	struct:simpla::geometry::model::Primitive
ndims	core/geometry/test/geometry_test.cpp	/^	static constexpr size_t ndims = manifold_type::ndims;$/;"	m	class:TestModel	file:
ndims	core/gtl/containers/sp_ndarray.h	/^	static constexpr size_t ndims = 1;$/;"	m	class:simpla::ndArray
ndims	core/gtl/containers/sp_ndarray.h	/^	static constexpr size_t ndims = NDIMS;$/;"	m	class:simpla::ndArray
ndims	core/gtl/containers/sp_ndarray.h	/^template<typename T, size_t N> size_t ndArray<T, N>::ndims;$/;"	m	class:simpla::ndArray
ndims	core/gtl/iterator/block_iterator.h	/^    static constexpr int ndims = NDIMS;$/;"	m	struct:simpla::block_iterator
ndims	core/manifold/mesh/MeshBlock.h	/^    static constexpr int ndims = 3;$/;"	m	struct:simpla::mesh::MeshBlock
ndims	core/manifold/mesh/MeshIds.h	/^    static constexpr int ndims = 3;$/;"	m	struct:simpla::mesh::MeshEntityIdCoder
ndims	core/manifold/mesh/MeshIds.h	/^template<int L> constexpr int MeshEntityIdCoder<L>::ndims;$/;"	m	class:simpla::mesh::MeshEntityIdCoder
ndims	core/model/test/model_test.cpp	/^	static constexpr size_t ndims = manifold_type::ndims;$/;"	m	class:TestModel	file:
ndims	core/numeric/multi_normal_distribution.h	/^	static constexpr size_t ndims = N;$/;"	m	class:simpla::multi_normal_distribution
ndims	core/particle/ParticleContainer.h	/^    static constexpr int ndims = mesh_type::ndims;$/;"	m	struct:simpla::particle::ParticleContainer
ndims	core/particle/obsolete/kinetic_particle.h	/^    static constexpr size_t ndims = domain_type::ndims;$/;"	m	struct:simpla::_impl::particle_hasher
ndims	core/particle/obsolete/kinetic_particle.h	/^template<typename TDomain, typename TPoint_s> constexpr size_t particle_hasher<TDomain, TPoint_s>::ndims;$/;"	m	class:simpla::_impl::particle_hasher
nearest_point	core/geometry/GeoObject.h	/^    virtual Real nearest_point(point_type *x0, point_type *x1) const$/;"	f	class:simpla::geometry::GeoObject
nearest_point	core/geometry/GeoObject.h	/^    virtual Real nearest_point(point_type const &x0, point_type const &x1, point_type *x2,$/;"	f	class:simpla::geometry::GeoObject
nearest_point	core/geometry/GeoObject.h	/^    virtual Real nearest_point(point_type const &x0, point_type const *x1, point_type *x2) const$/;"	f	class:simpla::geometry::GeoObject
nearest_point	core/geometry/obsolete/polygon.h	/^std::tuple<Real, typename PolyGon<TM>::iterator> PolyGon<TM>::nearest_point($/;"	f	class:simpla::PolyGon
nearest_point	core/geometry/polygon.cpp	/^Real Polygon<2>::nearest_point(point_type *x) const$/;"	f	class:simpla::geometry::Polygon
nearest_point	core/model/obsoleted/revolve_polygon.h	/^    virtual Real nearest_point(point_type *p) const$/;"	f	struct:simpla::RevolvePolygon
nearest_point_line_to_line	core/geometry/GeoAlgorithm.h	/^std::tuple<Real, Real> nearest_point_line_to_line(T0 const &P0, T1 const &P1,$/;"	f	namespace:simpla::geometry
nearest_point_to_line_segment	core/geometry/GeoAlgorithm.h	/^Real nearest_point_to_line_segment(T0 const &p0, T1 const &p1, T2 const &x)$/;"	f	namespace:simpla::geometry
nearest_point_to_polygon	core/geometry/GeoAlgorithm.h	/^Real nearest_point_to_polygon(T0 const &p0, T1 const &p1, TP *x)$/;"	f	namespace:simpla::geometry
new_table	core/gtl/utilities/lua_object.cpp	/^LuaObject LuaObject::new_table(std::string const &name, unsigned int narr, unsigned int nrec)$/;"	f	class:simpla::lua::LuaObject
next	core/gtl/iterator/sp_iterator_mapped.h	/^	void next()$/;"	f	struct:simpla::Iterator
next	core/parallel/obsoleted/blocked_range.h	/^	void next()$/;"	f	struct:simpla::iterator
next_n_timesteps	core/particle/obsolete/probe_particle.h	/^Real ProbeParticle<Engine>::next_n_timesteps(size_t num_of_steps, Real t0,$/;"	f	class:simpla::ProbeParticle
next_time_step	core/manifold/Manifold.h	/^    void next_time_step() { m_time_ += m_dt_; }$/;"	f	class:simpla::Manifold
next_time_step	core/manifold/obsoleted/time_integrator_policy.h	/^    void next_time_step() { m_time_ += m_dt_; }$/;"	f	struct:simpla::manifold::policy::TimeIntegrator
next_time_step	core/phy_solver/em_fluid.h	/^void EMFluid<TM>::next_time_step()$/;"	f	class:simpla::phy_solver::EMFluid
next_time_step	core/task_flow/use_case.h	/^    virtual void next_time_step(Real dt) { }$/;"	f	class:simpla::use_case::UseCase
next_time_step	example/em_tokamak/tokamak.cpp	/^void EMTokamak::next_time_step()$/;"	f	class:simpla::EMTokamak
next_timestep	applications/contexts/explicit_em.h	/^void ExplicitEMContext<TM>::next_timestep()$/;"	f	class:simpla::ExplicitEMContext
next_timestep	applications/field_solver/implicitPushE.h	/^void ImplicitPushE<TM>::next_timestep(field<scalar_type, EDGE> *pdE)$/;"	f	class:simpla::ImplicitPushE
next_timestep	applications/fokker_planck/lhw.cpp	/^	inline void next_timestep (Point_s * p, Real dt, TE const &fE0, TB const & fB0 )const$/;"	f	struct:PICDeltaF
next_timestep	applications/particle_solver/fluid_cold_engine.h	/^	void next_timestep()$/;"	f	class:simpla::Particle
next_timestep	applications/particle_solver/pic_engine_deltaf.h	/^	void next_timestep(Point_s * p, TJ* J, Real dt, TE const &fE, TB const & fB) const$/;"	f	struct:simpla::ParticleEngine
next_timestep	applications/particle_solver/pic_engine_deltaf2.h	/^	void next_timestep(Point_s * p, Real dt, TE const &fE, TB const & fB, Others const &...others) const$/;"	f	struct:simpla::PICEngineDeltaF
next_timestep	applications/particle_solver/pic_engine_fullf.h	/^	void next_timestep(Point_s * p, Real dt, TE const &fE, TB const & fB) const$/;"	f	class:simpla::PICEngineFullF
next_timestep	applications/particle_solver/pic_engine_implicit.h	/^	inline void next_timestep(Point_s * p, Real dt, E0_type const &fE0, B0_type const & fB0, E1_type const &fE1,$/;"	f	struct:simpla::PICEngineImplicit
next_timestep	core/particle/obsolete/probe_particle.h	/^void ProbeParticle<Engine>::next_timestep(Args &&...args)$/;"	f	class:simpla::ProbeParticle
next_timestep	core/particle/obsolete/simple_particle.h	/^	void next_timestep(Point_s * p, Real dt, TE const &fE, TB const & fB,$/;"	f	struct:simpla::SimpleParticleEngine
next_timestep	example/probe_particle/demo_probe_particle.h	/^	void next_timestep(Point_p p, Real dt, TE const &fE, TB const & fB) const$/;"	f	struct:simpla::ProbeDemo
next_timestepB	applications/field_solver/pml.h	/^void PML<TM>::next_timestepB(Real dt,$/;"	f	class:simpla::PML
next_timestepE	applications/field_solver/pml.h	/^void PML<TM>::next_timestepE(Real dt,$/;"	f	class:simpla::PML
next_timestep_half	applications/particle_solver/fluid_cold_engine.h	/^void Particle<TM, ColdFluid, PolicyFluidParticle>::next_timestep_half($/;"	f	class:simpla::Particle
next_timestep_half	applications/particle_solver/pic_engine_ggauge.h	/^	inline void next_timestep_half(Point_s * p, Real dt, TE const &fE, TB const & fB, Others const &...others) const$/;"	f	class:simpla::PICEngineGGauge
next_timestep_half	applications/particle_solver/pic_engine_ggauge.h	/^	inline void next_timestep_half(std::integral_constant<bool, IS_IMPLICIT>, Point_s * p, Real dt, TE const &fE,$/;"	f	class:simpla::PICEngineGGauge
next_timestep_zero	applications/particle_solver/fluid_cold_engine.h	/^void Particle<TM, ColdFluid, PolicyFluidParticle>::next_timestep_zero($/;"	f	class:simpla::Particle
next_timestep_zero	applications/particle_solver/pic_engine_ggauge.h	/^	inline void next_timestep_zero(Point_s * p, Real dt, TJ *J, TE const &fE, TB const & fB,$/;"	f	class:simpla::PICEngineGGauge
next_timestep_zero	applications/particle_solver/pic_engine_ggauge.h	/^	inline void next_timestep_zero(std::integral_constant<bool, IS_IMPLICIT>, Point_s * p, Real dt, TJ *J, TE const &fE,$/;"	f	class:simpla::PICEngineGGauge
no	core/gtl/check_concept.h	/^	typedef std::false_type no;$/;"	t	struct:simpla::traits::is_callable
no	core/gtl/check_concept.h	/^	typedef std::false_type no;$/;"	t	struct:simpla::traits::is_indexable
no	core/gtl/check_concept.h	/^	typedef std::false_type no;$/;"	t	struct:simpla::traits::is_iterator
no	core/gtl/concept_check.h	/^	typedef std::false_type no;$/;"	t	struct:simpla::is_callable
no	core/gtl/concept_check.h	/^	typedef std::false_type no;$/;"	t	struct:simpla::is_indexable
node_id	core/manifold/mesh/MeshIds.h	/^    static constexpr size_t node_id(id_type const &s)$/;"	f	struct:simpla::mesh::MeshEntityIdCoder
node_id_tag	core/manifold/mesh/MeshIds.h	/^    enum node_id_tag$/;"	g	struct:simpla::mesh::MeshEntityIdCoder
noexcept	core/gtl/utilities/lua_object.h	/^    LuaObject operator[](int s) const noexcept;$/;"	m	class:simpla::lua::LuaObject
noexcept	core/gtl/utilities/lua_object.h	/^    LuaObject operator[](std::string const &s) const noexcept;$/;"	m	class:simpla::lua::LuaObject
normal_dist_	core/numeric/multi_normal_distribution.h	/^	TNormalGen normal_dist_;$/;"	m	class:simpla::multi_normal_distribution
normal_distribution_icdf	core/numeric/normal_distribution_icdf.h	/^	normal_distribution_icdf(double mean, double stddev)$/;"	f	class:simpla::normal_distribution_icdf
normal_distribution_icdf	core/numeric/normal_distribution_icdf.h	/^class normal_distribution_icdf$/;"	c	namespace:simpla
not_endl	core/gtl/utilities/log.cpp	/^void Logger::not_endl()$/;"	f	class:simpla::logger::Logger
notify	core/gtl/design_pattern/observer.h	/^	void notify(Args &&...args)$/;"	f	struct:simpla::Observable
ntuple_carry	core/gtl/iterator/sp_ntuple_range.h	/^typename std::make_signed<TV>::type ntuple_carry(T0 const &min, T1 const &max,$/;"	f	namespace:simpla::_impl
ntuple_cycle	core/gtl/iterator/sp_ntuple_range.h	/^void ntuple_cycle(T0 const &min, T1 const &max, nTuple<TV, NDIMS> *self)$/;"	f	namespace:simpla::_impl
ntuple_type	core/gtl/iterator/sp_ntuple_range.h	/^    typedef nTuple<IndexType, DIMS...> ntuple_type;$/;"	t	struct:simpla::sp_nTuple_range
ntuple_type_lists	core/gtl/test/ntuple_reduce_test.cpp	/^> ntuple_type_lists;$/;"	t	file:
ntuple_type_lists_1d	core/gtl/test/ntuple_perf_test.cpp	/^> ntuple_type_lists_1d;$/;"	t	file:
ntuple_type_lists_2d	core/gtl/test/ntuple_perf_test.cpp	/^> ntuple_type_lists_2d;$/;"	t	file:
null_material	core/model/obsoleted/model.cpp	/^static constexpr typename Model::tage_type Model::null_material;$/;"	m	class:simpla::Model	file:
null_material	core/model/obsoleted/model.h	/^    static constexpr tag_type null_material = 0UL;$/;"	m	class:simpla::Model
null_op	core/gtl/expression_template.h	/^struct null_op$/;"	s	namespace:simpla::_impl
num_of_ele_	core/gtl/containers/container_dense.h	/^	size_t num_of_ele_;$/;"	m	class:simpla::DenseContainer
num_of_ele_in_cell	core/manifold/mesh/MeshIds.h	/^    static constexpr int num_of_ele_in_cell(id_type s)$/;"	f	struct:simpla::mesh::MeshEntityIdCoder
num_of_elements	core/data_model/DataSpace.cpp	/^size_t DataSpace::num_of_elements() const$/;"	f	class:simpla::data_model::DataSpace
num_of_loops	core/gtl/test/ntuple_perf_test.cpp	/^	std::size_t num_of_loops = 10000000L;$/;"	m	class:nTuplePerf1	file:
num_of_loops	core/gtl/test/ntuple_perf_test.cpp	/^	std::size_t num_of_loops = 10000000L;$/;"	m	class:nTuplePerf2	file:
num_of_loops	core/gtl/test/ntuple_reduce_test.cpp	/^	std::size_t num_of_loops = 10000000L;$/;"	m	class:TestNtupleReduce	file:
num_of_process	core/parallel/MPIComm.cpp	/^int MPIComm::num_of_process() const$/;"	f	class:simpla::parallel::MPIComm
num_per_cell	core/particle/ParticleGenerator.h	/^    size_t num_per_cell() const { return m_num_per_cell_; }$/;"	f	class:simpla::particle::ParticleGeneratorPerCell
num_per_cell	core/particle/ParticleGenerator.h	/^    size_t num_per_cell(size_t n) { m_num_per_cell_ = n; }$/;"	f	class:simpla::particle::ParticleGeneratorPerCell
number_of_dims	core/manifold/mesh/MeshBlock.h	/^    int number_of_dims() const { return m_ndims_; }$/;"	f	struct:simpla::mesh::MeshBlock
number_of_points	core/geometry/cube.h	/^struct number_of_points<model::Primitive<N, CS, tags::cube>>$/;"	s	namespace:simpla::geometry::traits
number_of_points	core/geometry/primitive.h	/^    static constexpr size_t number_of_points = traits::number_of_points<$/;"	m	struct:simpla::geometry::model::Primitive
number_of_points	core/geometry/primitive.h	/^struct number_of_points<model::Primitive<0, CoordinateSystem>>$/;"	s	namespace:simpla::geometry::traits
number_of_points	core/geometry/primitive.h	/^struct number_of_points<model::Primitive<1, CoordinateSystem>>$/;"	s	namespace:simpla::geometry::traits
number_of_points	core/geometry/simplex.h	/^struct number_of_points<model::Primitive<N, CoordinateSystem, tags::simplex> >$/;"	s	namespace:simpla::geometry::traits
number_of_vertices	core/geometry/primitive_ext.h	/^struct number_of_vertices<$/;"	s	namespace:simpla::geometry::traits
object_type	core/base/Patch.h	/^    typedef TObject object_type;$/;"	t	class:simpla::base::Patch
object_type	core/gtl/enable_create_from_this.h	/^	typedef TObject object_type;$/;"	t	struct:simpla::enable_create_from_this
observer_type	core/gtl/design_pattern/observer.h	/^	typedef Observer<Signature> observer_type;$/;"	t	struct:simpla::Observable
offset	core/gtl/containers/sp_ndarray.h	/^	index_tuple const & offset() const$/;"	f	class:simpla::ndArray
offset	core/gtl/containers/sp_ndarray.h	/^	void offset(TD const & d)$/;"	f	class:simpla::ndArray
offset	core/gtl/containers/sp_ndarray.h	/^	void offset(index_tuple const & d)$/;"	f	class:simpla::ndArray
on_cache_full	core/particle/obsolete/probe_particle.h	/^    std::function<void(this_type const &)> on_cache_full;$/;"	m	struct:simpla::ProbeParticle
one	core/field/test/field_diff_calculus_test.h	/^    value_type one;$/;"	m	class:FETLTest
one	core/field/test/trash/fetl_test3.h	/^	value_type one;$/;"	m	class:TestFETL
op_	core/gtl/expression_template.h	/^    TOP op_;$/;"	m	struct:simpla::AssignmentExpression
op_traits	core/gtl/expression_template.h	/^template<> struct op_traits<not_equal_to>$/;"	s	namespace:simpla::_impl
op_traits	core/gtl/expression_template.h	/^template<typename TOP> struct op_traits$/;"	s	namespace:simpla::_impl
open	core/io/HDF5Stream.cpp	/^std::tuple<bool, std::string> HDF5Stream::open(std::string const &url, size_t flag)$/;"	f	class:simpla::io::HDF5Stream
open	core/io/XDMFStream.cpp	/^void XDMFStream::open(std::string const &prefix, std::string const &grid_name)$/;"	f	class:simpla::io::XDMFStream
open_file	core/gtl/utilities/log.cpp	/^    inline void open_file(std::string const &name)$/;"	f	struct:simpla::logger::LoggerStreams
open_file	core/io/HDF5Stream.cpp	/^void HDF5Stream::open_file(std::string const &fname, bool is_append)$/;"	f	class:simpla::io::HDF5Stream
open_grid	core/io/XDMFStream.cpp	/^void XDMFStream::open_grid(const std::string &g_name, int TAG)$/;"	f	class:simpla::io::XDMFStream
open_group	core/io/HDF5Stream.cpp	/^void HDF5Stream::open_group(std::string const &str)$/;"	f	class:simpla::io::HDF5Stream
operator !	core/geometry/implicit_function.h	/^		Expression<_impl::logical_not, ImplicitFunction<T...>, std::nullptr_t>> operator !($/;"	f	namespace:simpla
operator !=	core/gtl/iterator/block_iterator.h	/^    bool operator!=(this_type const &other) const { return m_self_ != other.m_self_; }$/;"	f	struct:simpla::block_iterator
operator !=	core/gtl/iterator/iterator_cycle.h	/^	bool operator!=(iterator const & rhs) const$/;"	f	struct:simpla::iterator_cycle
operator !=	core/gtl/iterator/iterator_sequence.h	/^	bool operator !=(this_type const &other) const$/;"	f	class:simpla::IteratorSequence
operator !=	core/gtl/iterator/sp_indirect_iterator.h	/^    bool operator!=(sp_indirect_iterator const &other) const$/;"	f	struct:simpla::sp_indirect_iterator
operator !=	core/gtl/iterator/sp_iterator_index_base.h	/^	bool operator!=(this_type const &rhs) const$/;"	f	class:simpla::Iterator
operator !=	core/gtl/iterator/sp_iterator_mapped.h	/^	bool operator!=(this_type const & other) const$/;"	f	struct:simpla::Iterator
operator !=	core/gtl/iterator/sp_iterator_shared_container.h	/^	bool operator!=(this_type const & other) const$/;"	f	class:simpla::TransformIterator
operator !=	core/gtl/iterator/sp_ntuple_range.h	/^    bool operator!=(this_type const &other) const$/;"	f	struct:simpla::sp_nTuple_range::iterator
operator !=	core/gtl/utilities/lua_object.h	/^        bool operator!=(iterator const &r) const { return (r.key_ != key_); }$/;"	f	class:simpla::lua::LuaObject::iterator
operator !=	core/parallel/ParallelRandomGenerator.h	/^    bool operator!=(input_iterator const &other) const { return (m_count_ != other.m_count_); }$/;"	f	struct:simpla::parallel::DistributedCounter::input_iterator
operator !=	core/parallel/obsoleted/blocked_range.h	/^	bool operator!=(iterator const & rhs) const$/;"	f	struct:simpla::iterator
operator !=	core/particle/ParticleGenerator.h	/^        bool operator!=(input_iterator const &other) const { return (m_count_ != other.m_count_); }$/;"	f	struct:simpla::particle::ParticleGenerator::input_iterator
operator &	core/gtl/expression_template.h	/^TL const &operator&(TL const &l, Identity)$/;"	f	namespace:simpla
operator &	core/gtl/expression_template.h	/^TR const &operator&(Identity, TR const &r)$/;"	f	namespace:simpla
operator &	core/gtl/expression_template.h	/^constexpr Identity operator&(Identity, Identity)$/;"	f	namespace:simpla
operator &	core/gtl/expression_template.h	/^constexpr Zero operator$/;"	f	namespace:simpla
operator &	core/gtl/expression_template.h	/^constexpr Zero operator&(Zero, TR const &l)$/;"	f	namespace:simpla
operator &	core/gtl/expression_template.h	/^constexpr Zero operator&(Zero, Zero)$/;"	f	namespace:simpla
operator &	core/gtl/iterator/sp_ntuple_range.h	/^    this_type operator&(this_type const &other) const$/;"	f	struct:simpla::sp_nTuple_range
operator &&	core/geometry/implicit_function.h	/^				ImplicitFunction<T2...>>> operator &&($/;"	f	namespace:simpla
operator ()	core/data_model/data_view.h	/^	value_type &operator()(Args &&... args) const$/;"	f	struct:simpla::data_view
operator ()	core/data_model/data_view.h	/^	value_type &operator()(Args &&... args)$/;"	f	struct:simpla::data_view
operator ()	core/field/FieldDense.h	/^    field_value_type operator()(Args &&...args) const$/;"	f	class:simpla::Field
operator ()	core/field/FieldFunction.h	/^    field_value_type operator()(point_type const &x) const$/;"	f	class:simpla::Field
operator ()	core/field/obsoleted/field_constant.h	/^	value_type operator()(coordinates_type const &x) const$/;"	f	class:simpla::Field
operator ()	core/field/test/trash/field_simple_mesh_map_test.cpp	/^	size_t operator()(typename SimpleMesh::id_type const& s) const$/;"	f	struct:hash_id
operator ()	core/geometry/implicit_function.h	/^	Real operator()(Args && ...args) const$/;"	f	class:simpla::ImplicitFunction
operator ()	core/geometry/implicit_function.h	/^	Real operator()(Args && ...args) const$/;"	f	struct:simpla::ImplicitFunction
operator ()	core/geometry/model.h	/^	length_type operator()(point_type const & x) const$/;"	f	struct:simpla::geometry::model::Primitive
operator ()	core/geometry/obsolete/geometry_object.h	/^	Real operator()(nTuple<Real, 3> const & x)$/;"	f	struct:simpla::geometry_object::ImplicitFunction
operator ()	core/gtl/containers/sp_ndarray.h	/^	value_type & operator()(index_type ... s)$/;"	f	class:simpla::ndArray
operator ()	core/gtl/containers/sp_ndarray.h	/^	value_type & operator()(index_type s)$/;"	f	class:simpla::ndArray
operator ()	core/gtl/containers/sp_ndarray.h	/^	value_type const & operator()(index_type s) const$/;"	f	class:simpla::ndArray
operator ()	core/gtl/containers/sp_ndarray.h	/^	value_type const& operator()(index_type ... s) const$/;"	f	class:simpla::ndArray
operator ()	core/gtl/design_pattern/signal.h	/^    result_type operator()(Args &&...args) const$/;"	f	struct:simpla::Signal::Slot
operator ()	core/gtl/expression_template.h	/^    TL const &operator()(TL const &l) const$/;"	f	struct:simpla::_impl::null_op
operator ()	core/gtl/expression_template.h	/^    TR const &operator()(TL const &, TR const &r) const$/;"	f	struct:simpla::_impl::binary_right
operator ()	core/gtl/expression_template.h	/^    constexpr TL operator()(TL const &l) const { return _identify::eval(l); }$/;"	f	struct:simpla::_impl::_identify
operator ()	core/gtl/expression_template.h	/^    constexpr TL operator()(TL const &l) const { return _pow2::eval(l); }$/;"	f	struct:simpla::_impl::_pow2
operator ()	core/gtl/expression_template.h	/^    constexpr bool operator()(TL const &l, TR const &r) const$/;"	f	struct:simpla::_impl::equal_to
operator ()	core/gtl/expression_template.h	/^    constexpr bool operator()(double l, double r) const$/;"	f	struct:simpla::_impl::equal_to
operator ()	core/gtl/expression_template.h	/^    void operator()(TL &l, TR &r) const$/;"	f	struct:simpla::_impl::_swap
operator ()	core/gtl/expression_template.h	/^    void operator()(TL &l, TR &r, TI const &s) const$/;"	f	struct:simpla::_impl::_swap
operator ()	core/gtl/expression_template.h	/^    void operator()(TL &l, TR const &r) const$/;"	f	struct:simpla::_impl::_assign
operator ()	core/gtl/expression_template.h	/^    void operator()(TL &l, TR const &r, TI const &s) const$/;"	f	struct:simpla::_impl::_assign
operator ()	core/gtl/function.h	/^    result_type operator()(Args &&...args) const$/;"	f	class:simpla::Function
operator ()	core/gtl/function_cache.h	/^	value_type operator()(T key)const$/;"	f	struct:simpla::FunctionCache
operator ()	core/gtl/function_cache.h	/^	value_type operator()(T&& ...args) const$/;"	f	struct:simpla::FunctionCache
operator ()	core/gtl/type_traits.h	/^    template<typename ...Args> void operator()(Args &&...) const { }$/;"	f	struct:simpla::tags::do_nothing
operator ()	core/gtl/utilities/lua_object.h	/^    LuaObject operator()(Args &&... args) const$/;"	f	class:simpla::lua::LuaObject
operator ()	core/gtl/utilities/memory_pool.h	/^        inline void operator()(void *ptr)$/;"	f	struct:simpla::MemoryPool::deleter_s
operator ()	core/model/obsoleted/trans_revolve.h	/^    point_type *operator()(point_type *p) const$/;"	f	struct:simpla::TransformRevolve
operator ()	core/model/obsoleted/trans_revolve.h	/^    point_type operator()(point_type const &p) const$/;"	f	struct:simpla::TransformRevolve
operator ()	core/numeric/interpolation.h	/^    inline value_type operator()(TArgs const &... x) const$/;"	f	class:simpla::MultiDimesionInterpolation
operator ()	core/numeric/interpolation.h	/^    value_type operator()(key_x_type const &x) const$/;"	f	class:simpla::Interpolation
operator ()	core/numeric/multi_normal_distribution.h	/^	template<typename Generator> inline nTuple<RealType, N> operator()($/;"	f	class:simpla::multi_normal_distribution
operator ()	core/numeric/multi_normal_distribution.h	/^	void operator()(Generator & g, T * res)$/;"	f	class:simpla::multi_normal_distribution
operator ()	core/numeric/rectangle_distribution.h	/^    nTuple<double, NDIMS> operator()(Generator &g) const$/;"	f	class:simpla::rectangle_distribution
operator ()	core/numeric/rectangle_distribution.h	/^    void operator()(Generator &g, T *res) const$/;"	f	class:simpla::rectangle_distribution
operator ()	core/numeric/simplex_distribution.h	/^	template<typename Generator> inline nTuple<NDIM, double> operator()($/;"	f	class:simpla::simplex_distribution
operator ()	core/numeric/sobol_engine.h	/^	result_type operator()()$/;"	f	class:simpla::sobol_engine
operator ()	core/parallel/test/multi_thread_test.cpp	/^	int operator()(int i) const$/;"	f	struct:my_hash
operator ()	core/particle/ParticleContainer.h	/^        id_type operator()(sample_type const &p) const$/;"	f	struct:simpla::particle::ParticleContainer::Hash
operator ()	core/particle/ParticleGenerator.h	/^    operator()(id_type const &s)$/;"	f	class:simpla::particle::ParticleGeneratorPerCell
operator ()	core/particle/obsolete/kinetic_particle.h	/^    constexpr id_type operator()(value_type const &p) const$/;"	f	struct:simpla::_impl::particle_hasher
operator *	core/geometry/primitive.h	/^Vector<CS> operator*(Vector<CS> const &x1, Real a)$/;"	f	namespace:simpla::geometry::model
operator *	core/gtl/array_view.h	/^    value_type &operator*() { return m_data_.template get<value_type>(&m_idx_[0]); }$/;"	f	struct:simpla::gtl::ArrayView::iterator
operator *	core/gtl/array_view.h	/^    value_type const &operator*() const { return m_data_.template get<value_type>(&m_idx_[0]); }$/;"	f	struct:simpla::gtl::ArrayView::iterator
operator *	core/gtl/cache.h	/^	T & operator*()$/;"	f	struct:simpla::Cache
operator *	core/gtl/cache.h	/^	T const & operator*() const$/;"	f	struct:simpla::Cache
operator *	core/gtl/containers/container_cache.h	/^	T & operator*()$/;"	f	struct:simpla::CacheContainer
operator *	core/gtl/containers/container_cache.h	/^	T const & operator*() const$/;"	f	struct:simpla::CacheContainer
operator *	core/gtl/expression_template.h	/^template<typename TE> inline TE const &operator*(One const &, TE const &e)$/;"	f	namespace:simpla
operator *	core/gtl/expression_template.h	/^template<typename TE> inline TE const &operator*(TE const &e, One const &)$/;"	f	namespace:simpla
operator *	core/gtl/expression_template.h	/^template<typename TE> inline Zero operator*(TE const &, Zero const &)$/;"	f	namespace:simpla
operator *	core/gtl/expression_template.h	/^template<typename TE> inline Zero operator*(Zero const &, TE const &)$/;"	f	namespace:simpla
operator *	core/gtl/iterator/block_iterator.h	/^    nTuple<TV, NDIMS> const &operator*() const { return m_self_; }$/;"	f	struct:simpla::block_iterator
operator *	core/gtl/iterator/indirect_iterator.h	/^	value_type & operator *()$/;"	f	struct:simpla::indirect_iterator
operator *	core/gtl/iterator/iterator_sequence.h	/^	value_type operator *() const$/;"	f	class:simpla::IteratorSequence
operator *	core/gtl/iterator/sp_indirect_iterator.h	/^    value_type &operator*()$/;"	f	struct:simpla::sp_indirect_iterator
operator *	core/gtl/iterator/sp_iterator.h	/^	operator*()$/;"	f	class:simpla::sp_back_insert_iterator
operator *	core/gtl/iterator/sp_iterator_mapped.h	/^	const_reference operator *() const$/;"	f	struct:simpla::Iterator
operator *	core/gtl/iterator/sp_iterator_mapped.h	/^	const_reference operator*() const$/;"	f	struct:simpla::Iterator
operator *	core/gtl/iterator/sp_iterator_mapped.h	/^	reference operator *()$/;"	f	struct:simpla::Iterator
operator *	core/gtl/iterator/sp_iterator_mapped.h	/^	reference operator*()$/;"	f	struct:simpla::Iterator
operator *	core/gtl/iterator/sp_iterator_shared_container.h	/^	reference operator*() const$/;"	f	class:simpla::TransformIterator
operator *	core/gtl/iterator/sp_iterator_shared_container.h	/^	reference operator*()$/;"	f	class:simpla::TransformIterator
operator *	core/gtl/iterator/sp_ntuple_range.h	/^    ntuple_type const &operator*() const$/;"	f	struct:simpla::sp_nTuple_range::iterator
operator *	core/gtl/utilities/lua_object.h	/^            lua_State *operator*() { return m_l_->m_state_; }$/;"	f	struct:simpla::lua::LuaObject::LuaState::accessor
operator *	core/gtl/utilities/lua_object.h	/^            lua_State *operator*() { return m_l_->m_state_; }$/;"	f	struct:simpla::lua::LuaObject::LuaState::const_accessor
operator *	core/gtl/utilities/lua_object.h	/^        std::pair<LuaObject, LuaObject> operator*() const { return value(); };$/;"	f	class:simpla::lua::LuaObject::iterator
operator *	core/manifold/mesh/MeshIds.h	/^        id_type operator*() const { return pack_(base_type::operator*()); }$/;"	f	struct:simpla::mesh::MeshEntityIdCoder::iterator
operator *	core/parallel/ParallelRandomGenerator.h	/^    value_type const &operator*() const { return m_count_; }$/;"	f	struct:simpla::parallel::DistributedCounter::input_iterator
operator *	core/parallel/obsoleted/blocked_range.h	/^	value_type operator*() const$/;"	f	struct:simpla::iterator
operator *	core/particle/ParticleGenerator.h	/^        value_type const &operator*() const { return m_value_; }$/;"	f	struct:simpla::particle::ParticleGenerator::input_iterator
operator *=	core/field/FieldDense.h	/^    inline this_type &operator*=(Other const &other)$/;"	f	class:simpla::Field
operator *=	core/gtl/ntuple.h	/^    inline this_type &operator*=(TR const &rhs)$/;"	f	struct:simpla::nTuple
operator +	core/geometry/implicit_function.h	/^ operator +(ImplicitFunction< T1...> const & l,ImplicitFunction< T2...> const &r)$/;"	f	namespace:simpla
operator +	core/geometry/primitive.h	/^Point<CS> operator+(Point<CS> const &x0, Vector<CS> const &v)$/;"	f	namespace:simpla::geometry::model
operator +	core/gtl/array_view.h	/^    iterator operator+(difference_type const &s) const$/;"	f	struct:simpla::gtl::ArrayView::iterator
operator +	core/gtl/expression_template.h	/^inline Zero operator+(Zero const &, Zero const &e)$/;"	f	namespace:simpla
operator +	core/gtl/expression_template.h	/^operator+(TE const &e, Zero const &)$/;"	f	namespace:simpla
operator +	core/gtl/expression_template.h	/^operator+(Zero const &, TE const &e)$/;"	f	namespace:simpla
operator +	core/gtl/iterator/block_iterator.h	/^    this_type operator+(ptrdiff_t const &n) const$/;"	f	struct:simpla::block_iterator
operator +	core/gtl/iterator/iterator_sequence.h	/^	this_type operator+(diff_type const & r) const$/;"	f	class:simpla::IteratorSequence
operator +	core/manifold/mesh/MeshIds.h	/^        iterator operator+(difference_type const &s) const$/;"	f	struct:simpla::mesh::MeshEntityIdCoder::iterator
operator ++	core/gtl/iterator/block_iterator.h	/^    this_type &operator++()$/;"	f	struct:simpla::block_iterator
operator ++	core/gtl/iterator/block_iterator.h	/^    this_type operator++(int) const$/;"	f	struct:simpla::block_iterator
operator ++	core/gtl/iterator/indirect_iterator.h	/^	indirect_iterator & operator++()$/;"	f	struct:simpla::indirect_iterator
operator ++	core/gtl/iterator/indirect_iterator.h	/^	indirect_iterator operator++(int) const$/;"	f	struct:simpla::indirect_iterator
operator ++	core/gtl/iterator/iterator_cycle.h	/^	iterator & operator ++()$/;"	f	struct:simpla::iterator_cycle
operator ++	core/gtl/iterator/iterator_cycle.h	/^	iterator operator ++(int) const$/;"	f	struct:simpla::iterator_cycle
operator ++	core/gtl/iterator/iterator_sequence.h	/^	this_type & operator ++()$/;"	f	class:simpla::IteratorSequence
operator ++	core/gtl/iterator/iterator_sequence.h	/^	this_type operator ++(int)$/;"	f	class:simpla::IteratorSequence
operator ++	core/gtl/iterator/sp_indirect_iterator.h	/^    sp_indirect_iterator operator++(int) const$/;"	f	struct:simpla::sp_indirect_iterator
operator ++	core/gtl/iterator/sp_iterator.h	/^	operator++()$/;"	f	class:simpla::sp_back_insert_iterator
operator ++	core/gtl/iterator/sp_iterator.h	/^	sp_back_insert_iterator operator++(int)$/;"	f	class:simpla::sp_back_insert_iterator
operator ++	core/gtl/iterator/sp_iterator_cycle.h	/^	this_type & operator++()$/;"	f	struct:simpla::CycleIterator
operator ++	core/gtl/iterator/sp_iterator_cycle.h	/^	this_type operator++(int) const$/;"	f	struct:simpla::CycleIterator
operator ++	core/gtl/iterator/sp_iterator_filter.h	/^	this_type & operator ++()$/;"	f	struct:simpla::sp_fliter_iterator
operator ++	core/gtl/iterator/sp_iterator_filter.h	/^	this_type operator ++(int) const$/;"	f	struct:simpla::sp_fliter_iterator
operator ++	core/gtl/iterator/sp_iterator_index_base.h	/^	this_type & operator++()$/;"	f	class:simpla::Iterator
operator ++	core/gtl/iterator/sp_iterator_mapped.h	/^	this_type & operator ++()$/;"	f	struct:simpla::Iterator
operator ++	core/gtl/iterator/sp_iterator_mapped.h	/^	this_type operator ++(int)$/;"	f	struct:simpla::Iterator
operator ++	core/gtl/iterator/sp_iterator_shared_container.h	/^	this_type & operator ++()$/;"	f	class:simpla::TransformIterator
operator ++	core/gtl/iterator/sp_iterator_shared_container.h	/^	this_type operator ++(int)$/;"	f	class:simpla::TransformIterator
operator ++	core/gtl/iterator/sp_ntuple_range.h	/^    this_type &operator++()$/;"	f	struct:simpla::sp_nTuple_range::iterator
operator ++	core/gtl/iterator/sp_ntuple_range.h	/^    this_type operator++(int)$/;"	f	struct:simpla::sp_nTuple_range::iterator
operator ++	core/gtl/ntuple.h	/^    this_type &operator++()$/;"	f	struct:simpla::nTuple
operator ++	core/gtl/utilities/lua_object.h	/^        iterator &operator++() { return Next(); }$/;"	f	class:simpla::lua::LuaObject::iterator
operator ++	core/parallel/ParallelRandomGenerator.h	/^    input_iterator &operator++()$/;"	f	struct:simpla::parallel::DistributedCounter::input_iterator
operator ++	core/parallel/obsoleted/blocked_range.h	/^	iterator & operator ++()$/;"	f	struct:simpla::iterator
operator ++	core/parallel/obsoleted/blocked_range.h	/^	iterator operator ++(int) const$/;"	f	struct:simpla::iterator
operator ++	core/particle/ParticleGenerator.h	/^        input_iterator &operator++()$/;"	f	struct:simpla::particle::ParticleGenerator::input_iterator
operator +=	core/field/FieldDense.h	/^    inline this_type &operator+=(Other const &other)$/;"	f	class:simpla::Field
operator +=	core/gtl/iterator/block_iterator.h	/^    this_type &operator+=(ptrdiff_t const &n)$/;"	f	struct:simpla::block_iterator
operator +=	core/gtl/ntuple.h	/^    inline this_type &operator+=(TR const &rhs)$/;"	f	struct:simpla::nTuple
operator -	core/geometry/implicit_function.h	/^				ImplicitFunction<T2...>>> operator-($/;"	f	namespace:simpla
operator -	core/geometry/implicit_function.h	/^		Expression<_impl::negate, ImplicitFunction<T...>, std::nullptr_t>> operator -($/;"	f	namespace:simpla
operator -	core/geometry/primitive.h	/^LineSegment<CS> operator-(Point<CS> const &x1, Point<CS> const &x0)$/;"	f	namespace:simpla::geometry::model
operator -	core/gtl/expression_template.h	/^operator-(TE const &e, Zero const &)$/;"	f	namespace:simpla
operator -	core/gtl/iterator/block_iterator.h	/^    ptrdiff_t operator-(this_type const &other) const$/;"	f	struct:simpla::block_iterator
operator -	core/gtl/iterator/block_iterator.h	/^    this_type operator-(ptrdiff_t const &n) const$/;"	f	struct:simpla::block_iterator
operator -	core/gtl/iterator/iterator_sequence.h	/^	diff_type operator-(this_type const & r) const$/;"	f	class:simpla::IteratorSequence
operator --	core/gtl/iterator/block_iterator.h	/^    this_type &operator--()$/;"	f	struct:simpla::block_iterator
operator --	core/gtl/iterator/block_iterator.h	/^    this_type operator--(int) const$/;"	f	struct:simpla::block_iterator
operator --	core/gtl/iterator/iterator_cycle.h	/^	iterator & operator --()$/;"	f	struct:simpla::iterator_cycle
operator --	core/gtl/iterator/iterator_cycle.h	/^	iterator operator --(int) const$/;"	f	struct:simpla::iterator_cycle
operator --	core/gtl/iterator/iterator_sequence.h	/^	this_type & operator --()$/;"	f	class:simpla::IteratorSequence
operator --	core/gtl/iterator/iterator_sequence.h	/^	this_type operator --(int)$/;"	f	class:simpla::IteratorSequence
operator --	core/gtl/iterator/sp_iterator_cycle.h	/^	this_type & operator--()$/;"	f	struct:simpla::CycleIterator
operator --	core/gtl/iterator/sp_iterator_cycle.h	/^	this_type operator--(int) const$/;"	f	struct:simpla::CycleIterator
operator --	core/gtl/iterator/sp_iterator_filter.h	/^	this_type & operator --()$/;"	f	struct:simpla::sp_fliter_iterator
operator --	core/gtl/iterator/sp_iterator_filter.h	/^	this_type operator --(int) const$/;"	f	struct:simpla::sp_fliter_iterator
operator --	core/gtl/iterator/sp_iterator_index_base.h	/^	this_type & operator--()$/;"	f	class:simpla::Iterator
operator --	core/gtl/iterator/sp_iterator_mapped.h	/^	this_type & operator --()$/;"	f	struct:simpla::Iterator
operator --	core/gtl/iterator/sp_iterator_mapped.h	/^	this_type operator --(int)$/;"	f	struct:simpla::Iterator
operator --	core/gtl/iterator/sp_iterator_shared_container.h	/^	this_type & operator --()$/;"	f	class:simpla::TransformIterator
operator --	core/gtl/iterator/sp_iterator_shared_container.h	/^	this_type operator --(int)$/;"	f	class:simpla::TransformIterator
operator --	core/gtl/iterator/sp_ntuple_range.h	/^    this_type &operator--()$/;"	f	struct:simpla::sp_nTuple_range::iterator
operator --	core/gtl/iterator/sp_ntuple_range.h	/^    this_type operator--(int)$/;"	f	struct:simpla::sp_nTuple_range::iterator
operator --	core/gtl/ntuple.h	/^    this_type &operator--()$/;"	f	struct:simpla::nTuple
operator --	core/parallel/obsoleted/blocked_range.h	/^	iterator & operator --()$/;"	f	struct:simpla::iterator
operator --	core/parallel/obsoleted/blocked_range.h	/^	iterator operator --(int) const$/;"	f	struct:simpla::iterator
operator -=	core/field/FieldDense.h	/^    inline this_type &operator-=(Other const &other)$/;"	f	class:simpla::Field
operator -=	core/gtl/iterator/block_iterator.h	/^    this_type &operator-=(ptrdiff_t const &n)$/;"	f	struct:simpla::block_iterator
operator -=	core/gtl/ntuple.h	/^    inline this_type &operator-=(TR const &rhs)$/;"	f	struct:simpla::nTuple
operator ->	core/gtl/iterator/indirect_iterator.h	/^	value_type & operator ->()$/;"	f	struct:simpla::indirect_iterator
operator ->	core/gtl/iterator/sp_indirect_iterator.h	/^    value_type &operator->()$/;"	f	struct:simpla::sp_indirect_iterator
operator ->	core/gtl/iterator/sp_iterator_mapped.h	/^	const_pointer operator ->() const$/;"	f	struct:simpla::Iterator
operator ->	core/gtl/iterator/sp_iterator_mapped.h	/^	const_pointer operator->() const$/;"	f	struct:simpla::Iterator
operator ->	core/gtl/iterator/sp_iterator_mapped.h	/^	pointer operator ->()$/;"	f	struct:simpla::Iterator
operator ->	core/gtl/iterator/sp_iterator_mapped.h	/^	pointer operator->()$/;"	f	struct:simpla::Iterator
operator ->	core/gtl/iterator/sp_iterator_shared_container.h	/^	pointer operator->() const$/;"	f	class:simpla::TransformIterator
operator ->	core/gtl/iterator/sp_iterator_shared_container.h	/^	pointer operator->()$/;"	f	class:simpla::TransformIterator
operator ->	core/gtl/utilities/lua_object.h	/^        std::pair<LuaObject, LuaObject> operator->() const { return value(); };$/;"	f	class:simpla::lua::LuaObject::iterator
operator ->	core/parallel/ParallelRandomGenerator.h	/^    value_type const *operator->() const { return &m_count_; }$/;"	f	struct:simpla::parallel::DistributedCounter::input_iterator
operator ->	core/parallel/obsoleted/blocked_range.h	/^	iterator * operator->()$/;"	f	struct:simpla::iterator
operator ->	core/parallel/obsoleted/blocked_range.h	/^	iterator const * operator->() const$/;"	f	struct:simpla::iterator
operator ->	core/particle/ParticleGenerator.h	/^        value_type const *operator->() const { return &m_value_; }$/;"	f	struct:simpla::particle::ParticleGenerator::input_iterator
operator /	core/gtl/expression_template.h	/^template<typename TE> inline Infinity operator\/(Infinity const &, TE const &e)$/;"	f	namespace:simpla
operator /	core/gtl/expression_template.h	/^template<typename TE> inline Infinity operator\/(TE const &e, Zero const &)$/;"	f	namespace:simpla
operator /	core/gtl/expression_template.h	/^template<typename TE> inline Zero operator\/(TE const &, Infinity const &)$/;"	f	namespace:simpla
operator /	core/gtl/expression_template.h	/^template<typename TE> inline Zero operator\/(Zero const &, TE const &e)$/;"	f	namespace:simpla
operator /=	core/field/FieldDense.h	/^    inline this_type &operator\/=(Other const &other)$/;"	f	class:simpla::Field
operator /=	core/gtl/ntuple.h	/^    inline this_type &operator\/=(TR const &rhs)$/;"	f	struct:simpla::nTuple
operator <	core/gtl/iterator/block_iterator.h	/^    bool operator<(this_type const &other) const { return (*this - other) < 0; }$/;"	f	struct:simpla::block_iterator
operator <<	applications/particle_solver/pic_engine_deltaf2.h	/^operator<<(OS& os, typename PICEngineDeltaF<TM, TS>::Point_s const & p)$/;"	f	namespace:simpla
operator <<	applications/particle_solver/pic_engine_ggauge.h	/^operator<<(OS& os, typename PICEngineGGauge<T...>::Point_s const & p)$/;"	f	namespace:simpla
operator <<	applications/particle_solver/pic_engine_implicit.h	/^operator<<(OS& os, typename PICEngineImplicit<TM...>::Point_s const & p)$/;"	f	namespace:simpla
operator <<	core/geometry/box.h	/^OS &operator<<(OS & os, Box<CoordinateSystem> const & geo)$/;"	f	namespace:simpla::geometry::model
operator <<	core/geometry/model.h	/^OS & operator<<(OS & os, Polygon<CS> const & poly)$/;"	f	namespace:simpla::geometry::model
operator <<	core/geometry/primitive.h	/^OS &operator<<(OS &os, CoVector<CoordinateSystem> const &geo)$/;"	f	namespace:simpla::geometry::model
operator <<	core/geometry/primitive.h	/^OS &operator<<(OS &os, Primitive<Dimension, CoordinateSystem, Tag> const &geo)$/;"	f	namespace:simpla::geometry::model
operator <<	core/geometry/primitive.h	/^OS &operator<<(OS &os, Vector<CoordinateSystem> const &geo)$/;"	f	namespace:simpla::geometry::model
operator <<	core/gtl/Properties.cpp	/^std::ostream &operator<<(std::ostream &os, Properties const &prop)$/;"	f	namespace:simpla
operator <<	core/gtl/ntuple_ext.h	/^std::ostream &operator<<(std::ostream &os, nTuple<T, M, M2, N...> const &v)$/;"	f	namespace:simpla
operator <<	core/gtl/ntuple_ext.h	/^std::ostream &operator<<(std::ostream &os, nTuple<T, M> const &v)$/;"	f	namespace:simpla
operator <<	core/gtl/utilities/log.h	/^    Logger &operator<<(StandardEndLine manip)$/;"	f	class:simpla::logger::Logger
operator <<	core/gtl/utilities/log.h	/^    Logger const &operator<<(Arg const &arg) const$/;"	f	class:simpla::logger::Logger
operator <<	core/gtl/utilities/log.h	/^    Logger const &operator<<(Arg const &arg)$/;"	f	class:simpla::logger::Logger
operator <<	core/gtl/utilities/log.h	/^    Logger const &operator<<(StandardEndLine manip) const$/;"	f	class:simpla::logger::Logger
operator <<	core/gtl/utilities/log.h	/^    Logger const &operator<<(const char *arg) const$/;"	f	class:simpla::logger::Logger
operator <<	core/gtl/utilities/log.h	/^    Logger const &operator<<(const char *arg)$/;"	f	class:simpla::logger::Logger
operator <<	core/gtl/utilities/lua_object.h	/^inline std::ostream &operator<<(std::ostream &os, LuaObject const &obj)$/;"	f	namespace:simpla::lua
operator <<	core/gtl/utilities/pretty_stream.h	/^operator<<(std::ostream &os, const std::complex<T> &tv)$/;"	f	namespace:std
operator <<	core/gtl/utilities/pretty_stream.h	/^operator<<(std::ostream &os, std::map<T1, T2> const &p)$/;"	f	namespace:std
operator <<	core/gtl/utilities/pretty_stream.h	/^operator<<(std::ostream &os, std::map<TX, TY, Others...> const &d)$/;"	f	namespace:std
operator <<	core/gtl/utilities/pretty_stream.h	/^operator<<(std::ostream &os, std::multimap<TX, TY, Others...> const &d)$/;"	f	namespace:std
operator <<	core/gtl/utilities/pretty_stream.h	/^operator<<(std::ostream &os, std::pair<T1, T2> const &p)$/;"	f	namespace:std
operator <<	core/gtl/utilities/pretty_stream.h	/^std::ostream &operator<<(std::ostream &os, std::list<U, Others...> const &d)$/;"	f	namespace:std
operator <<	core/gtl/utilities/pretty_stream.h	/^std::ostream &operator<<(std::ostream &os, std::set<U, Others...> const &d)$/;"	f	namespace:std
operator <<	core/gtl/utilities/pretty_stream.h	/^std::ostream &operator<<(std::ostream &os, std::tuple<T, Args ...> const &v)$/;"	f	namespace:std
operator <<	core/gtl/utilities/pretty_stream.h	/^std::ostream &operator<<(std::ostream &os, std::vector<U, Others...> const &d)$/;"	f	namespace:std
operator <<	core/gtl/utilities/pretty_stream.h	/^std::ostream &operator<<(std::ostream &os,$/;"	f	namespace:std
operator <<	core/manifold/ManifoldTraits.h	/^std::ostream &operator<<(std::ostream &os, const Manifold<TMesh, Policies...> &m) { return m.print(os); }$/;"	f	namespace:simpla
operator <<	core/particle/Particle.h	/^    std::ostream &operator<<(std::ostream &os) const { return this->print(os, 0); }$/;"	f	struct:simpla::particle::ParticleBase
operator <<	core/particle/Particle.h	/^inline std::ostream &operator<<(std::ostream &os, ParticleBase const &p) { return p.print(os, 0); };$/;"	f	namespace:simpla::particle
operator <<	core/particle/ParticleProxy.h	/^std::ostream &operator<<(std::ostream &os, ParticleProxyBase<TE, TB, TJ, TRho> const &p)$/;"	f	namespace:simpla::particle
operator <<	core/physics/PhysicalConstants.cpp	/^std::ostream &operator<<(std::ostream &os, PhysicalConstants const &self)$/;"	f	namespace:simpla
operator <<	core/task_flow/context_base.h	/^inline std::ostream & operator<<(std::ostream& os, ContextBase const & ctx)$/;"	f	namespace:simpla
operator <=	core/gtl/iterator/block_iterator.h	/^    bool operator<=(this_type const &other) const { return (*this - other) <= 0; }$/;"	f	struct:simpla::block_iterator
operator =	core/base/Attribute.h	/^    Attribute &operator=(Attribute const &other)$/;"	f	class:simpla::base::Attribute
operator =	core/base/Attribute.h	/^    AttributeEntity &operator=(AttributeEntity const &other)$/;"	f	class:simpla::base::AttributeEntity
operator =	core/base/Object.cpp	/^Object &Object::operator=(Object const &other)$/;"	f	class:simpla::base::Object
operator =	core/data_model/DataSpace.h	/^    DataSpace &operator=(const DataSpace &rhs)$/;"	f	class:simpla::data_model::DataSpace
operator =	core/data_model/DataType.cpp	/^DataType &DataType::operator=(DataType const$/;"	f	class:simpla::data_model::DataType
operator =	core/data_model/data_view.h	/^	this_type operator=(this_type const &other)$/;"	f	struct:simpla::data_view
operator =	core/field/FieldDense.h	/^    inline this_type &operator=(Other const &other)$/;"	f	class:simpla::Field
operator =	core/field/FieldDense.h	/^    inline this_type &operator=(this_type const &other)$/;"	f	class:simpla::Field
operator =	core/field/obsoleted/field_constant.h	/^	this_type &operator=(this_type const &other)$/;"	f	class:simpla::Field
operator =	core/field/obsoleted/field_sparse.h	/^	inline Field<AssignmentExpression<_impl::_assign, this_type, TR>> operator =($/;"	f	struct:simpla::Field
operator =	core/field/obsoleted/field_sparse.h	/^	inline Field<AssignmentExpression<_impl::_assign, this_type, this_type>> operator =($/;"	f	struct:simpla::Field
operator =	core/field/test/trash/field_continue.h	/^	inline Field<AssignmentExpression<_impl::_assign, this_type, TR>> operator =($/;"	f	struct:simpla::Field
operator =	core/field/test/trash/field_continue.h	/^	inline Field<AssignmentExpression<_impl::_assign, this_type, this_type>> operator =($/;"	f	struct:simpla::Field
operator =	core/gtl/Properties.h	/^    this_type &operator=(T const &v)$/;"	f	class:simpla::Properties
operator =	core/gtl/Properties.h	/^    this_type &operator=(this_type const &other)$/;"	f	class:simpla::Properties
operator =	core/gtl/any.h	/^    any &operator=(T const &v)$/;"	f	struct:simpla::any
operator =	core/gtl/any.h	/^    any &operator=(const any &a)$/;"	f	struct:simpla::any
operator =	core/gtl/array_view.h	/^    iterator &operator=(iterator const &other)$/;"	f	struct:simpla::gtl::ArrayView::iterator
operator =	core/gtl/containers/container_sparse.h	/^    this_type &operator=(this_type const &rhs)$/;"	f	class:simpla::SparseContainer
operator =	core/gtl/containers/sp_hash_container.h	/^	this_type & operator=(this_type const & other)$/;"	f	struct:simpla::SpHashContainer
operator =	core/gtl/containers/sp_ndarray.h	/^	this_type & operator=(this_type const & other)$/;"	f	class:simpla::ndArray
operator =	core/gtl/iterator/block_iterator.h	/^    this_type &operator=(this_type const &other)$/;"	f	struct:simpla::block_iterator
operator =	core/gtl/iterator/sp_iterator.h	/^	operator=(const value_type& __value)$/;"	f	class:simpla::sp_back_insert_iterator
operator =	core/gtl/iterator/sp_iterator.h	/^	operator=(const value_type&& __value)$/;"	f	class:simpla::sp_back_insert_iterator
operator =	core/gtl/iterator/sp_iterator_cycle.h	/^	this_type & operator=(this_type & other)$/;"	f	struct:simpla::CycleIterator
operator =	core/gtl/iterator/sp_ntuple_range.h	/^    iterator &operator=(iterator const &other)$/;"	f	struct:simpla::sp_nTuple_range::iterator
operator =	core/gtl/iterator/sp_ntuple_range.h	/^    this_type &operator=(this_type const &other)$/;"	f	struct:simpla::sp_nTuple_range
operator =	core/gtl/ntuple.h	/^    operator=(TR const &rhs)$/;"	f	struct:simpla::nTuple
operator =	core/gtl/ntuple.h	/^    operator=(TR const *rhs)$/;"	f	struct:simpla::nTuple
operator =	core/gtl/utilities/config_parser.h	/^        DictObject &operator=(DictObject const &other)$/;"	f	struct:simpla::ConfigParser::DictObject
operator =	core/gtl/utilities/lua_object.h	/^    LuaObject &operator=(LuaObject const &other)$/;"	f	class:simpla::lua::LuaObject
operator =	core/manifold/mesh/MeshIds.h	/^        iterator &operator=(base_type const &other)$/;"	f	struct:simpla::mesh::MeshEntityIdCoder::iterator
operator =	core/manifold/mesh/MeshIds.h	/^        iterator &operator=(iterator const &other)$/;"	f	struct:simpla::mesh::MeshEntityIdCoder::iterator
operator =	core/parallel/MPIDataType.h	/^    MPIDataType &operator=(MPIDataType const &other)$/;"	f	struct:simpla::MPIDataType
operator =	core/particle/Particle.h	/^    this_type &operator=(this_type const &other)$/;"	f	struct:simpla::particle::Particle
operator =	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^    vtkAMRSimPlaReaderBlock &operator=(const vtkAMRSimPlaReaderBlock &other)$/;"	f	class:vtkAMRSimPlaReaderBlock
operator ==	core/data_model/DataSet.h	/^    bool operator==(DataSet const &other) const { return is_equal(other.data.get()); }$/;"	f	struct:simpla::data_model::DataSet
operator ==	core/gtl/iterator/block_iterator.h	/^    bool operator==(this_type const &other) const { return m_self_ == other.m_self_; }$/;"	f	struct:simpla::block_iterator
operator ==	core/gtl/iterator/indirect_iterator.h	/^	bool operator==(this_type const & other) const$/;"	f	struct:simpla::indirect_iterator
operator ==	core/gtl/iterator/iterator_cycle.h	/^	bool operator==(iterator const & rhs) const$/;"	f	struct:simpla::iterator_cycle
operator ==	core/gtl/iterator/iterator_sequence.h	/^	bool operator ==(this_type const &other) const$/;"	f	class:simpla::IteratorSequence
operator ==	core/gtl/iterator/sp_indirect_iterator.h	/^    bool operator==(sp_indirect_iterator const &other) const$/;"	f	struct:simpla::sp_indirect_iterator
operator ==	core/gtl/iterator/sp_iterator_index_base.h	/^	bool operator==(this_type const &rhs) const$/;"	f	class:simpla::Iterator
operator ==	core/gtl/iterator/sp_iterator_mapped.h	/^	bool operator==(this_type const & other) const$/;"	f	struct:simpla::Iterator
operator ==	core/gtl/iterator/sp_iterator_shared_container.h	/^	bool operator==(this_type const & other) const$/;"	f	class:simpla::TransformIterator
operator ==	core/gtl/iterator/sp_ntuple_range.h	/^    bool operator==(this_type const &other) const$/;"	f	struct:simpla::sp_nTuple_range::iterator
operator ==	core/parallel/ParallelRandomGenerator.h	/^    bool operator==(input_iterator const &other) const { return m_count_ == other.m_count_; }$/;"	f	struct:simpla::parallel::DistributedCounter::input_iterator
operator ==	core/parallel/obsoleted/blocked_range.h	/^	bool operator==(iterator const & rhs) const$/;"	f	struct:simpla::iterator
operator ==	core/particle/ParticleGenerator.h	/^        bool operator==(input_iterator const &other) const { return m_count_ == other.m_count_; }$/;"	f	struct:simpla::particle::ParticleGenerator::input_iterator
operator >	core/gtl/iterator/block_iterator.h	/^    bool operator>(this_type const &other) const { return (*this - other) > 0; }$/;"	f	struct:simpla::block_iterator
operator >=	core/gtl/iterator/block_iterator.h	/^    bool operator>=(this_type const &other) const { return (*this - other) >= 0; }$/;"	f	struct:simpla::block_iterator
operator >>	core/gtl/ntuple_ext.h	/^operator>>(std::istream &is, nTuple<T, N> &tv)$/;"	f	namespace:simpla
operator >>	core/gtl/utilities/pretty_stream.h	/^operator>>(std::istream &is, std::vector<TV, Others...> &a)$/;"	f	namespace:std
operator T	core/gtl/utilities/config_parser.h	/^        operator T() const$/;"	f	struct:simpla::ConfigParser::DictObject
operator T	core/gtl/utilities/lua_object.h	/^    operator T() const { return as<T>(); }$/;"	f	class:simpla::lua::LuaObject
operator U	core/gtl/any.h	/^    template<class U> operator U() const { return as<U>(); }$/;"	f	struct:simpla::any
operator []	core/base/Attribute.h	/^    value_type &operator[](id_type const &s) { return at(s); }$/;"	f	class:simpla::base::Attribute
operator []	core/base/Attribute.h	/^    value_type const &operator[](id_type const &s) const { return at(s); }$/;"	f	class:simpla::base::Attribute
operator []	core/data_model/data_view.h	/^	value_type &operator[](size_t s) { return m_data_.get()[s]; }$/;"	f	struct:simpla::data_view
operator []	core/data_model/data_view.h	/^	value_type const &operator[](size_t s) const { return m_data_.get()[s]; }$/;"	f	struct:simpla::data_view
operator []	core/field/FieldDense.h	/^    value_type &operator[](id_type const &s) { return m_data_->at(s); }$/;"	f	class:simpla::Field
operator []	core/field/FieldDense.h	/^    value_type const &operator[](id_type const &s) const { return m_data_->at(s); }$/;"	f	class:simpla::Field
operator []	core/field/FieldFunction.h	/^    value_type operator[](id_type const &s) const$/;"	f	class:simpla::Field
operator []	core/field/obsoleted/field_sparse.h	/^	value_type & operator[](id_type const & s)$/;"	f	struct:simpla::Field
operator []	core/field/obsoleted/field_sparse.h	/^	value_type const & operator[](id_type const & s) const$/;"	f	struct:simpla::Field
operator []	core/field/test/trash/field_continue.h	/^	value_type & operator[](id_type const & s)$/;"	f	struct:simpla::Field
operator []	core/field/test/trash/field_continue.h	/^	value_type const & operator[](id_type const & s) const$/;"	f	struct:simpla::Field
operator []	core/gtl/Properties.h	/^    inline Properties &operator[](const char key[]) { return get(key); }$/;"	f	class:simpla::Properties
operator []	core/gtl/Properties.h	/^    inline Properties &operator[](key_type const &key) { return get(key); }$/;"	f	class:simpla::Properties
operator []	core/gtl/Properties.h	/^    inline Properties const &operator[](const char key[]) const$/;"	f	class:simpla::Properties
operator []	core/gtl/Properties.h	/^    inline Properties const &operator[](key_type const &key) const$/;"	f	class:simpla::Properties
operator []	core/gtl/containers/container_container.h	/^	value_type & operator[](key_type s) const$/;"	f	class:simpla::ContainerContainer
operator []	core/gtl/containers/container_container.h	/^	value_type & operator[](key_type s)$/;"	f	class:simpla::ContainerContainer
operator []	core/gtl/containers/container_dense.h	/^	value_type & operator[](key_type s) const$/;"	f	class:simpla::DenseContainer
operator []	core/gtl/containers/container_dense.h	/^	value_type & operator[](key_type s)$/;"	f	class:simpla::DenseContainer
operator []	core/gtl/containers/container_pool.h	/^	value_type & operator[](size_t s)$/;"	f	struct:simpla::ContainerPool
operator []	core/gtl/containers/container_pool.h	/^	value_type const& operator[](size_t s) const$/;"	f	struct:simpla::ContainerPool
operator []	core/gtl/containers/container_sparse.h	/^    value_type &operator[](key_type s) const$/;"	f	class:simpla::SparseContainer
operator []	core/gtl/containers/container_sparse.h	/^    value_type &operator[](key_type s)$/;"	f	class:simpla::SparseContainer
operator []	core/gtl/containers/sp_hash_container.h	/^	value_type & operator[](key_type const& s)$/;"	f	struct:simpla::SpHashContainer
operator []	core/gtl/containers/sp_hash_container.h	/^	value_type const& operator[](key_type const& s) const$/;"	f	struct:simpla::SpHashContainer
operator []	core/gtl/containers/sp_ndarray.h	/^	ndArray<value_type, ndims - 1> operator[](index_type s)$/;"	f	class:simpla::ndArray
operator []	core/gtl/containers/sp_ndarray.h	/^	value_type & operator[](index_tuple s) const$/;"	f	class:simpla::ndArray
operator []	core/gtl/containers/sp_ndarray.h	/^	value_type & operator[](index_tuple s)$/;"	f	class:simpla::ndArray
operator []	core/gtl/containers/sp_ndarray.h	/^	value_type & operator[](index_type s)$/;"	f	class:simpla::ndArray
operator []	core/gtl/containers/sp_ndarray.h	/^	value_type const & operator[](index_type s) const$/;"	f	class:simpla::ndArray
operator []	core/gtl/containers/unordered_set.h	/^    bucket_type &operator[](key_type const &key)$/;"	f	class:simpla::UnorderedSet
operator []	core/gtl/iterator/block_iterator.h	/^    nTuple<TV, NDIMS> operator[](int const &n) const$/;"	f	struct:simpla::block_iterator
operator []	core/gtl/ntuple.h	/^    sub_type &operator[](int s)$/;"	f	struct:simpla::nTuple
operator []	core/gtl/ntuple.h	/^    sub_type const &operator[](int s) const$/;"	f	struct:simpla::nTuple
operator []	core/gtl/utilities/config_parser.h	/^    DictObject operator[](std::string const &key) const$/;"	f	struct:simpla::ConfigParser
operator []	core/model/obsoleted/model.h	/^    tag_type operator[](id_type s) const$/;"	f	class:simpla::Model
operator []	core/numeric/interpolation.h	/^    inline value_type &operator[](size_t s)$/;"	f	class:simpla::MultiDimesionInterpolation
operator []	core/numeric/interpolation.h	/^    inline value_type const &operator[](size_t s) const$/;"	f	class:simpla::MultiDimesionInterpolation
operator []	core/particle/obsolete/probe_particle.h	/^    Point_s &operator[](size_t s)$/;"	f	struct:simpla::ProbeParticle
operator []	core/particle/obsolete/probe_particle.h	/^    Point_s const &operator[](size_t s) const$/;"	f	struct:simpla::ProbeParticle
operator []	core/physics/PhysicalConstants.h	/^    inline double operator[](std::string const &s) const$/;"	f	class:simpla::PhysicalConstants
operator bool	applications/contexts/explicit_em.h	/^    operator bool() const$/;"	f	struct:simpla::ExplicitEMContext
operator bool	core/field/FieldFunction.h	/^    operator bool() const { return !!m_fun_; }$/;"	f	class:simpla::Field
operator bool	core/gtl/Properties.h	/^    operator bool() const { return !empty() && (this->as<bool>()); }$/;"	f	class:simpla::Properties
operator bool	core/gtl/any.h	/^    operator bool() const { return ptr_ != nullptr; }$/;"	f	struct:simpla::any
operator bool	core/gtl/design_pattern/signal.h	/^    operator bool() const$/;"	f	struct:simpla::Signal::Slot
operator bool	core/gtl/expression_template.h	/^    operator bool() const$/;"	f	class:simpla::BooleanExpression
operator bool	core/gtl/function.h	/^    operator bool() const$/;"	f	class:simpla::Function
operator bool	core/gtl/ntuple.h	/^    operator bool() const$/;"	f	struct:simpla::nTuple
operator bool	core/gtl/utilities/config_parser.h	/^        operator bool() const$/;"	f	struct:simpla::ConfigParser::DictObject
operator bool	core/gtl/utilities/lua_object.h	/^    operator bool() const { return !L_.empty(); }$/;"	f	class:simpla::lua::LuaObject
operator bool	core/task_flow/context_base.h	/^	virtual operator bool() const$/;"	f	class:simpla::ContextBase
operator nTuple<CoordinateType, N...>	core/geometry/primitive.h	/^    inline operator nTuple<CoordinateType, N...>()$/;"	f	struct:simpla::geometry::model::Tensor
operator nTuple<U, I...>	core/gtl/ntuple.h	/^    operator nTuple<U, I...>() const$/;"	f	struct:simpla::nTuple
operator nTuple<U, N...>	core/gtl/ntuple.h	/^    operator nTuple<U, N...>() const$/;"	f	struct:simpla::nTuple
operator std::basic_string<char>	core/gtl/utilities/lua_object.h	/^    operator std::basic_string<char>() const { return as<std::string>(); }$/;"	f	class:simpla::lua::LuaObject
operator ||	core/geometry/implicit_function.h	/^				ImplicitFunction<T2...>>> operator ||($/;"	f	namespace:simpla
other	core/gtl/containers/UnorderedSet.h	/^    this_type &operator=(this_type const &other) = delete;$/;"	m	class:simpla::gtl::UnorderedSet
other	core/gtl/containers/UnorderedSet.h	/^    void swap(this_type const &other) = delete;$/;"	m	class:simpla::gtl::UnorderedSet
other	core/manifold/Manifold.h	/^    this_type &operator=(const this_type &other) = delete;$/;"	m	class:simpla::Manifold
other	core/manifold/mesh/CartesianCoRect.h	/^    CartesianCoRect(this_type const &other) = delete;$/;"	m	struct:simpla::mesh::CartesianCoRect
other	core/manifold/mesh/CoRectMesh.h	/^    Mesh(this_type const &other) = delete;$/;"	m	struct:simpla::mesh::Mesh
other	core/manifold/mesh/CylindricalCoRect.h	/^    CylindricalCoRect(this_type const &other) = delete;$/;"	m	class:simpla::mesh::CylindricalCoRect
other	core/manifold/mesh/CylindricalCoRect.h	/^    this_type &operator=(this_type const &other) = delete;$/;"	m	class:simpla::mesh::CylindricalCoRect
other	core/manifold/mesh/MeshBlock.h	/^    MeshBlock(this_type const &other) = delete;$/;"	m	struct:simpla::mesh::MeshBlock
other	core/manifold/mesh/RectMesh.h	/^    Mesh(this_type const &other) = delete;$/;"	m	struct:simpla::mesh::Mesh
other	core/manifold/mesh/RectMesh.h	/^    this_type &operator=(this_type const &other) = delete;$/;"	m	struct:simpla::mesh::Mesh
other	core/parallel/DistributedCounter.h	/^    DistributedCounter(DistributedCounter const &other) = delete;$/;"	m	struct:simpla::parallel::DistributedCounter
other	core/parallel/ParallelRandomGenerator.h	/^    DistributedCounter(DistributedCounter const &other) = delete;$/;"	m	struct:simpla::parallel::DistributedCounter
other	core/particle/ParticleContainer.h	/^    this_type &operator=(this_type const &other) = delete;$/;"	m	struct:simpla::particle::ParticleContainer
other	core/particle/ParticleContainer.h	/^    void swap(this_type const &other) = delete;$/;"	m	struct:simpla::particle::ParticleContainer
other	core/particle/ParticleGenerator.h	/^    ParticleGenerator(ParticleGenerator const &other) = delete;$/;"	m	struct:simpla::particle::ParticleGenerator
out_stream	example/em_tokamak/tokamak.cpp	/^    io::XDMFStream out_stream;$/;"	m	struct:simpla::EMTokamak	file:
outer	core/geometry/model.h	/^	inline ring_type const& outer() const$/;"	f	struct:simpla::geometry::model::Polygon
outer	core/geometry/model.h	/^	inline ring_type& outer()$/;"	f	struct:simpla::geometry::model::Polygon
outer_range	core/manifold/mesh/MeshBlock.h	/^    range_type outer_range() const$/;"	f	struct:simpla::mesh::MeshBlock
output	scripts/PostProcesse/particle_time_scripts.py	/^output = self.GetOutput()$/;"	v
overlap_box	core/manifold/obsoleted/mesh_graph.h	/^    typename m::box_type overlap_box;$/;"	m	struct:simpla::mesh::MeshMapEdge
pInstance_	core/gtl/design_pattern/singleton_holder.h	/^	static T * volatile pInstance_;$/;"	m	class:simpla::SingletonHolder
pInstance_	core/gtl/design_pattern/singleton_holder.h	/^T * volatile SingletonHolder<T>::pInstance_ = 0;$/;"	m	class:simpla::SingletonHolder
p_	core/gtl/iterator/iterator_cycle.h	/^	base_iterator p_;$/;"	m	struct:simpla::iterator_cycle
pack	core/manifold/mesh/MeshIds.h	/^    static constexpr id_type pack(T const &idx)$/;"	f	struct:simpla::mesh::MeshEntityIdCoder
pack	core/manifold/mesh/MeshIds.h	/^    static constexpr id_type pack(id_type i0, id_type i1, id_type i2)$/;"	f	struct:simpla::mesh::MeshEntityIdCoder
pack_	core/manifold/mesh/MeshIds.h	/^        id_type pack_(nTuple<index_type, ndims + 1> const &idx) const$/;"	f	struct:simpla::mesh::MeshEntityIdCoder::iterator
pack_index	core/manifold/mesh/MeshIds.h	/^    static constexpr id_type pack_index(T const &idx, int n_id = 0)$/;"	f	struct:simpla::mesh::MeshEntityIdCoder
pages_	core/gtl/containers/container_pool.h	/^	std::vector<std::shared_ptr<value_type>> pages_;$/;"	m	struct:simpla::ContainerPool
parallel	core/parallel/DistributedCounter.h	/^namespace simpla { namespace parallel$/;"	n	namespace:simpla
parallel	core/parallel/DistributedObject.cpp	/^namespace simpla { namespace parallel$/;"	n	namespace:simpla	file:
parallel	core/parallel/DistributedObject.h	/^namespace simpla { namespace parallel$/;"	n	namespace:simpla
parallel	core/parallel/MPIAuxFunctions.cpp	/^namespace simpla { namespace parallel$/;"	n	namespace:simpla	file:
parallel	core/parallel/MPIAuxFunctions.h	/^namespace simpla { namespace parallel$/;"	n	namespace:simpla
parallel	core/parallel/MPIComm.cpp	/^namespace simpla { namespace parallel$/;"	n	namespace:simpla	file:
parallel	core/parallel/MPIComm.h	/^namespace simpla { namespace parallel$/;"	n	namespace:simpla
parallel	core/parallel/MPIUpdate.cpp	/^namespace simpla { namespace parallel$/;"	n	namespace:simpla	file:
parallel	core/parallel/MPIUpdate.h	/^namespace simpla { namespace parallel$/;"	n	namespace:simpla
parallel	core/parallel/Parallel.cpp	/^namespace simpla { namespace parallel$/;"	n	namespace:simpla	file:
parallel	core/parallel/Parallel.h	/^namespace simpla { namespace parallel$/;"	n	namespace:simpla
parallel	core/parallel/ParallelRandomGenerator.h	/^namespace simpla { namespace parallel$/;"	n	namespace:simpla
parallel	core/parallel/ParallelTbb.h	/^namespace simpla { namespace parallel$/;"	n	namespace:simpla
parallel	core/parallel/concurrent_unordered_multiset.h	/^namespace simpla { namespace parallel$/;"	n	namespace:simpla
parallel	core/parallel/obsoleted/distributed_comm.h	/^namespace parallel$/;"	n	namespace:simpla
parallel	core/parallel/obsoleted/parallel_traits.h	/^namespace parallel$/;"	n	namespace:simpla
parallel_do	core/parallel/ParallelDummy.h	/^void parallel_do(Range const &range, OP const &op)$/;"	f	namespace:simpla::serial
parallel_for	core/parallel/ParallelDummy.h	/^void parallel_for(Range const &range, OP const &op)$/;"	f	namespace:simpla::serial
parallel_for	core/parallel/obsoleted/multi_thread_openmp.h	/^void parallel_for(TRange & range, std::function<TRange &> const & fun, size_t grain_size = 0)$/;"	f	namespace:simpla
parallel_for_each	core/parallel/obsoleted/multi_thread_openmp.h	/^void parallel_for_each(TRange & range, TF const & fun, size_t grain_size = 0)$/;"	f	namespace:simpla
parallel_move	core/manifold/obsoleted/fiber_bundle.h	/^    void parallel_move(point_type *p, Real dt, vector_type const &a, Others &&... others) const$/;"	f	struct:simpla::manifold::DirectMap
parallel_policy	core/manifold/policy/ParallelPolicy.h	/^    typedef this_type parallel_policy;$/;"	t	struct:simpla::manifold::policy::ParallelPolicy
parallel_reduce	core/parallel/obsoleted/multi_thread_openmp.h	/^void parallel_reduce(TRange const & range, TRes *res, TFun const &fun, Reduction const &red_fun,$/;"	f	namespace:simpla
parallel_reduce	core/parallel/obsoleted/multi_thread_std_thread.h	/^void parallel_reduce(TRange && range, TRes const & identity, TRes *res,$/;"	f	namespace:simpla
parent	core/base/Attribute.h	/^    virtual std::shared_ptr<AttributeObject> parent() { return m_parent_.lock(); }$/;"	f	class:simpla::base::AttributeObject
parent_	core/gtl/utilities/lua_object.h	/^        int parent_;$/;"	m	class:simpla::lua::LuaObject::iterator
parent_container_type	core/gtl/containers/container_container.h	/^	typedef std::map<key_type, value_type> parent_container_type;$/;"	t	class:simpla::ContainerContainer
parse_cmd_line	core/gtl/utilities/parse_command_line.cpp	/^void parse_cmd_line(int argc, char **argv,$/;"	f	namespace:simpla
parse_file	core/gtl/utilities/lua_object.cpp	/^void LuaObject::parse_file(std::string const &filename)$/;"	f	class:simpla::lua::LuaObject
parse_string	core/gtl/utilities/lua_object.cpp	/^void LuaObject::parse_string(std::string const &str)$/;"	f	class:simpla::lua::LuaObject
parser	core/gtl/utilities/parser_configure.h	/^void ParserConfigure<TDict>::parser(dict_type const &dict, std::string const & prefix)$/;"	f	class:simpla::ParserConfigure
parser_url	core/io/IOStream.cpp	/^IOStream::parser_url(std::string const &url_hint) const$/;"	f	class:simpla::io::IOStream
partial_{t}boldsymbol{E} & = & frac{1}{c^{2}}nablatimesboldsymbol{B}-frac{1}{varepsilon_{0}}sum_{s}boldsymbol{J}_{s}-boldsymbol{J}_{ext}label{eq:Ampere s Law	docs/tex/FDTD_Plasma.tex	/^%% LyX 2.0.6 created this file.  For more info, see http:\/\/www.lyx.org\/.$/;"	P
particle	core/particle/Particle.h	/^namespace simpla { namespace particle$/;"	n	namespace:simpla
particle	core/particle/ParticleConstraint.h	/^namespace simpla { namespace particle$/;"	n	namespace:simpla
particle	core/particle/ParticleContainer.h	/^namespace simpla { namespace particle$/;"	n	namespace:simpla
particle	core/particle/ParticleEngine.h	/^namespace simpla { namespace particle$/;"	n	namespace:simpla
particle	core/particle/ParticleFactory.h	/^namespace simpla { namespace particle$/;"	n	namespace:simpla
particle	core/particle/ParticleGenerator.h	/^namespace simpla { namespace particle$/;"	n	namespace:simpla
particle	core/particle/ParticleProxy.h	/^namespace simpla { namespace particle$/;"	n	namespace:simpla
particle	core/particle/ParticleTracker.h	/^namespace simpla { namespace particle$/;"	n	namespace:simpla
particle	core/particle/pre_define/GuidingCenter.h	/^namespace simpla { namespace particle { namespace engine$/;"	n	namespace:simpla
particle	core/particle/pre_define/GuidingCenter.h	/^namespace simpla { namespace particle$/;"	n	namespace:simpla
particle	core/particle/pre_define/PICBoris.h	/^namespace simpla { namespace particle { namespace engine$/;"	n	namespace:simpla
particle	core/particle/pre_define/PICBoris.h	/^namespace simpla { namespace particle$/;"	n	namespace:simpla
particle	core/particle/pre_define/PICGyro.h	/^namespace simpla { namespace particle { namespace engine$/;"	n	namespace:simpla
particle	core/particle/pre_define/PICGyro.h	/^namespace simpla { namespace particle$/;"	n	namespace:simpla
particle_hasher	core/particle/obsolete/kinetic_particle.h	/^    particle_hasher()$/;"	f	struct:simpla::_impl::particle_hasher
particle_hasher	core/particle/obsolete/kinetic_particle.h	/^    particle_hasher(domain_type const &d)$/;"	f	struct:simpla::_impl::particle_hasher
particle_hasher	core/particle/obsolete/kinetic_particle.h	/^struct particle_hasher$/;"	s	namespace:simpla::_impl
particle_sp	example/em_tokamak/tokamak.cpp	/^    std::map<std::string, std::shared_ptr<particle::ParticleBase>> particle_sp;$/;"	m	struct:simpla::EMTokamak	file:
particle_type	core/particle/ParticleGenerator.h	/^    typedef TP particle_type;$/;"	t	class:simpla::particle::ParticleGeneratorPerCell
particle_type	core/particle/ParticleProxy.h	/^    typedef TP particle_type;$/;"	t	class:simpla::particle::ParticleProxy
particle_type	core/particle/test/kinetic_particle_test.cpp	/^	typedef KineticParticle<mesh_type, engine_type> particle_type;$/;"	t	class:TestKineticParticle	file:
particle_type	core/particle/test/kinetic_particle_test.h	/^	typedef KineticParticle<mesh_type, engine_type> particle_type;$/;"	t	class:TestKineticParticle
particles_	applications/contexts/explicit_em.h	/^    std::map<std::string, std::shared_ptr<ParticleBase>> particles_;$/;"	m	struct:simpla::ExplicitEMContext
patch	core/base/Patch.h	/^    virtual std::shared_ptr<object_type> patch(size_t id) const$/;"	f	class:simpla::base::Patch
patch	core/base/Patch.h	/^    virtual std::shared_ptr<object_type> patch(size_t id)$/;"	f	class:simpla::base::Patch
patch	core/field/obsoleted/field_patch.h	/^    field_type patch(size_t id) const$/;"	f	class:simpla::FieldAMRPolicy
patch	core/field/obsoleted/field_patch.h	/^    field_type patch(size_t id)$/;"	f	class:simpla::FieldAMRPolicy
patch	core/manifold/obsoleted/amr_policy.h	/^patch(size_t id, Field<Expression<TOP, Args...>> const &expr)$/;"	f	namespace:simpla::manifold::policy::_impl
patch	core/manifold/obsoleted/amr_policy.h	/^patch(size_t id, Field<T...> &f) { return std::move(*std::dynamic_pointer_cast<Field<T...> >(f.patch(id))); };$/;"	f	namespace:simpla::manifold::policy::_impl
patch	core/manifold/obsoleted/amr_policy.h	/^patch(size_t id, T const &f) { return (f); };$/;"	f	namespace:simpla::manifold::policy::_impl
patch	core/manifold/obsoleted/patch/mesh_patch.h	/^patch(size_t id, Field<Expression<TOP, Args...> > const &expr)$/;"	f	namespace:simpla::mesh::_impl
patch	core/manifold/obsoleted/patch/mesh_patch.h	/^patch(size_t id, Field<T...> &f) { return std::move(*std::dynamic_pointer_cast<Field<T...> >(f.patch(id))); };$/;"	f	namespace:simpla::mesh::_impl
patch	core/manifold/obsoleted/patch/mesh_patch.h	/^patch(size_t id, T const &f) { return (f); };$/;"	f	namespace:simpla::mesh::_impl
patch_policy	core/base/Attribute.h	/^    typedef Patch<Attribute<TV, IFORM, TMesh>> patch_policy;$/;"	t	class:simpla::base::Attribute
patch_policy	core/base/Patch.h	/^    typedef Patch<object_type> patch_policy;$/;"	t	class:simpla::base::Patch
patch_type	core/manifold/obsoleted/amr_policy.h	/^    typedef typename mesh_type::patch_type patch_type;$/;"	t	class:simpla::manifold::policy::AMR
path	core/io/XDMFStream.cpp	/^std::string XDMFStream::path() const$/;"	f	class:simpla::io::XDMFStream
path_	core/gtl/containers/container_save_cache.h	/^	std::string path_;$/;"	m	class:simpla::ContainerSaveCache
path_	core/gtl/utilities/lua_object.h	/^        std::string path_;$/;"	m	class:simpla::lua::LuaObject::iterator
path_	core/gtl/utilities/lua_object.h	/^    std::string path_;$/;"	m	class:simpla::lua::LuaObject
peak	core/geometry/primitive.h	/^struct peak<model::Primitive<Dimension, Others...>>$/;"	s	namespace:simpla::geometry::traits
periodic_id_mask	core/manifold/mesh/MeshBlock.h	/^    id_type periodic_id_mask() const$/;"	f	struct:simpla::mesh::MeshBlock
phy_solver	core/phy_solver/em_fluid.h	/^namespace simpla { namespace phy_solver$/;"	n	namespace:simpla
pic	core/particle/test/kinetic_particle_test.cpp	/^	static constexpr size_t pic = 10;$/;"	m	class:TestKineticParticle	file:
pic	core/particle/test/kinetic_particle_test.cpp	/^constexpr size_t TestKineticParticle::pic;$/;"	m	class:TestKineticParticle	file:
pimpl_	core/data_model/DataType.h	/^    std::unique_ptr<pimpl_s> pimpl_;$/;"	m	struct:simpla::data_model::DataType
pimpl_	core/gtl/utilities/memory_pool.h	/^    std::unique_ptr<pimpl_s> pimpl_;$/;"	m	class:simpla::MemoryPool
pimpl_	core/parallel/DistributedObject.h	/^    std::unique_ptr<pimpl_s> pimpl_;$/;"	m	struct:simpla::parallel::DistributedObject
pimpl_	core/parallel/MPIComm.h	/^    std::unique_ptr<pimpl_s> pimpl_;$/;"	m	class:simpla::parallel::MPIComm
pimpl_s	core/data_model/DataSpace.cpp	/^struct DataSpace::pimpl_s$/;"	s	class:simpla::data_model::DataSpace	file:
pimpl_s	core/data_model/DataType.cpp	/^DataType::pimpl_s::pimpl_s() :$/;"	f	class:simpla::data_model::DataType::pimpl_s
pimpl_s	core/data_model/DataType.cpp	/^DataType::pimpl_s::pimpl_s(pimpl_s &&other) :$/;"	f	class:simpla::data_model::DataType::pimpl_s
pimpl_s	core/data_model/DataType.cpp	/^DataType::pimpl_s::pimpl_s(pimpl_s const$/;"	f	class:simpla::data_model::DataType::pimpl_s
pimpl_s	core/data_model/DataType.cpp	/^struct DataType::pimpl_s$/;"	s	class:simpla::data_model::DataType	file:
pimpl_s	core/gtl/utilities/memory_pool.cpp	/^struct MemoryPool::pimpl_s$/;"	s	class:simpla::MemoryPool	file:
pimpl_s	core/io/HDF5Stream.cpp	/^HDF5Stream::pimpl_s::pimpl_s()$/;"	f	class:simpla::io::HDF5Stream::pimpl_s
pimpl_s	core/io/HDF5Stream.cpp	/^struct HDF5Stream::pimpl_s$/;"	s	class:simpla::io::HDF5Stream	file:
pimpl_s	core/model/GEqdsk.cpp	/^struct GEqdsk::pimpl_s$/;"	s	class:simpla::GEqdsk	file:
pimpl_s	core/parallel/DistributedObject.cpp	/^DistributedObject::pimpl_s::pimpl_s() : m_object_id_(GLOBAL_COMM.generate_object_id())$/;"	f	class:simpla::parallel::DistributedObject::pimpl_s
pimpl_s	core/parallel/DistributedObject.cpp	/^struct DistributedObject::pimpl_s$/;"	s	class:simpla::parallel::DistributedObject	file:
pimpl_s	core/parallel/MPIComm.cpp	/^struct MPIComm::pimpl_s$/;"	s	class:simpla::parallel::MPIComm	file:
pimpl_s	core/parallel/trash/distributed_unordered_set.cpp	/^struct DistributedUnorderedSetBase::pimpl_s$/;"	s	class:simpla::DistributedUnorderedSetBase	file:
pimpl_s	plugins/vtk_reader/vtkAMRSimPlaParticlesReader.cpp	/^struct vtkAMRSimPlaParticlesReader::pimpl_s$/;"	s	class:vtkAMRSimPlaParticlesReader	file:
pimpl_s	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^class vtkAMRSimPlaReader::pimpl_s$/;"	c	class:vtkAMRSimPlaReader	file:
pimpl_s	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^vtkAMRSimPlaReader::pimpl_s::pimpl_s()$/;"	f	class:vtkAMRSimPlaReader::pimpl_s
pixel_intersects_polygon	core/geometry/cut_cell.h	/^void pixel_intersects_polygon(TM const & mesh, int node_id,$/;"	f	namespace:simpla
pixels_	core/numeric/simplex_distribution.h	/^	nTuple<NDIM + 1, nTuple<NDIM, double>> pixels_;$/;"	m	class:simpla::simplex_distribution
plasma_region_vertex	core/phy_solver/em_fluid.h	/^    model::IdSet<mesh_type> plasma_region_vertex;$/;"	m	class:simpla::phy_solver::EMFluid
plasma_region_vertex	example/em_tokamak/tokamak.cpp	/^    model::IdSet<mesh_type> plasma_region_vertex;$/;"	m	struct:simpla::EMTokamak	file:
plasma_region_volume	core/phy_solver/em_fluid.h	/^    model::IdSet<mesh_type> plasma_region_volume;$/;"	m	class:simpla::phy_solver::EMFluid
plasma_region_volume	example/em_tokamak/tokamak.cpp	/^    model::IdSet<mesh_type> plasma_region_volume;$/;"	m	struct:simpla::EMTokamak	file:
pnt2d	core/geometry/obsolete/line_cliping.h	/^	struct pnt2d$/;"	s	class:simpla::polygon_clip
pnt2ds	core/geometry/obsolete/line_cliping.h	/^	typedef pnt2d pnt2ds[MAXSIZE]; \/* Global variables *\/$/;"	t	class:simpla::polygon_clip
pod_type	core/gtl/ntuple.h	/^    typedef value_type pod_type;$/;"	t	struct:simpla::nTuple
pod_type	core/gtl/ntuple.h	/^struct pod_type<nTuple<BooleanExpression<TOP, T...> > >$/;"	s	namespace:simpla::traits
pod_type	core/gtl/ntuple.h	/^struct pod_type<nTuple<T, N...>>$/;"	s	namespace:simpla::traits
pod_type	core/gtl/type_traits.h	/^template<typename T> struct pod_type$/;"	s	namespace:simpla::traits
point	core/manifold/mesh/MeshBlock.h	/^    virtual point_type point(id_type const &s) const$/;"	f	struct:simpla::mesh::MeshBlock
point	core/manifold/mesh/MeshIds.h	/^    static point_type point(id_type const &s)$/;"	f	struct:simpla::mesh::MeshEntityIdCoder
point	core/manifold/mesh/MeshIds.h	/^    static point_type point(nTuple<index_type, ndims> const &idx)$/;"	f	struct:simpla::mesh::MeshEntityIdCoder
point	core/manifold/mesh/RectMesh.h	/^    point_type point(Args &&...args) const$/;"	f	struct:simpla::mesh::Mesh
point2d_type	core/geometry/polygon.h	/^    typedef nTuple<Real, 2> point2d_type;$/;"	t	struct:simpla::geometry::Polygon
point_order	core/geometry/boost_gemetry_adapted.h	/^struct point_order<sgm::Polyline<CS, Others ...> >$/;"	s	namespace:boost::geometry::traits
point_order	core/geometry/chains.h	/^struct point_order<model::Chains<PrimitiveType, Others...>>$/;"	s	namespace:simpla::geometry::traits
point_type	core/field/FieldDense.h	/^    typedef typename mesh_type::point_type point_type;$/;"	t	class:simpla::Field
point_type	core/field/FieldFunction.h	/^    typedef typename mesh_type::point_type point_type;$/;"	t	class:simpla::Field
point_type	core/field/test/field_diff_calculus_test.h	/^    typedef typename mesh_type::point_type point_type;$/;"	t	class:FETLTest
point_type	core/geometry/CoordinateSystem.h	/^template<typename CS> struct point_type$/;"	s	namespace:simpla::geometry::traits
point_type	core/geometry/GeoObject.h	/^    typedef nTuple<Real, 3> point_type;$/;"	t	class:simpla::geometry::GeoObject
point_type	core/geometry/boost_gemetry_adapted.h	/^struct point_type<sgm::Box<CS>>$/;"	s	namespace:boost::geometry::traits
point_type	core/geometry/boost_gemetry_adapted.h	/^struct point_type<sgm::Primitive<1, CS, sg::tags::simplex> >$/;"	s	namespace:boost::geometry::traits
point_type	core/geometry/chains.h	/^    typedef typename traits::point_type<coordinate_system>::type point_type;$/;"	t	struct:simpla::geometry::model::Chains
point_type	core/geometry/csCartesian.h	/^    typedef nTuple<scalar_type, 3> point_type;$/;"	t	struct:simpla::geometry::CartesianMetric
point_type	core/geometry/csCylindrical.h	/^    typedef nTuple<scalar_type, 3> point_type;$/;"	t	struct:simpla::geometry::Metric
point_type	core/geometry/model.h	/^	typedef Point<CS> point_type;$/;"	t	struct:simpla::geometry::model::Polygon
point_type	core/geometry/model.h	/^	typedef typename traits::point_type<CS>::type point_type;$/;"	t	struct:simpla::geometry::model::Primitive
point_type	core/geometry/model.h	/^	typedef typename traits::point_type<CS>::type point_type;$/;"	t	struct:simpla::geometry::model::Surface
point_type	core/geometry/primitive.h	/^struct point_type<model::Primitive<Dimension, CoordinateSystem, Tag>>$/;"	s	namespace:simpla::geometry::traits
point_type	core/manifold/mesh/CoRectMesh.h	/^    typedef typename metric_type::point_type point_type;$/;"	t	struct:simpla::mesh::Mesh
point_type	core/manifold/mesh/GeneralMap.h	/^    typedef TP point_type;$/;"	t	struct:simpla::mesh::SquareMap
point_type	core/manifold/mesh/LinearMap.h	/^    typedef nTuple<Real, 3> point_type;$/;"	t	struct:simpla::mesh::LinearMap
point_type	core/manifold/mesh/MeshIds.h	/^    typedef nTuple<Real, ndims> point_type;$/;"	t	struct:simpla::mesh::MeshEntityIdCoder
point_type	core/manifold/obsoleted/amr_policy.h	/^    typedef typename mesh_type::point_type point_type;$/;"	t	class:simpla::manifold::policy::AMR
point_type	core/manifold/obsoleted/fiber_bundle.h	/^    typedef E point_type; \/\/!< coordinates in the total space,$/;"	t	class:simpla::manifold::FiberBundle
point_type	core/manifold/obsoleted/fiber_bundle.h	/^    typedef P point_type;$/;"	t	struct:simpla::manifold::DirectMap
point_type	core/model/GEqdsk.h	/^    typedef nTuple<Real, 3> point_type;$/;"	t	class:simpla::GEqdsk
point_type	core/model/obsoleted/trans_revolve.h	/^    typedef nTuple<Real, 3> point_type;$/;"	t	struct:simpla::TransformRevolve
point_type	core/particle/Particle.h	/^    typedef typename mesh_type::point_type point_type;$/;"	t	struct:simpla::particle::Particle
point_type	core/particle/ParticleContainer.h	/^    typedef typename mesh_type::point_type point_type;$/;"	t	struct:simpla::particle::ParticleContainer
point_type	core/particle/ParticleGenerator.h	/^    typedef typename mesh_type::point_type point_type;$/;"	t	class:simpla::particle::ParticleGeneratorPerCell
point_type	core/particle/ParticleTracker.h	/^    typedef typename P::point_type point_type;$/;"	t	class:simpla::particle::enable_tracking
point_type	core/particle/pre_define/GuidingCenter.h	/^    typedef typename geometry::CylindricalMetric::point_type point_type;$/;"	t	struct:simpla::particle::engine::GuidingCenterEngine
point_type	core/particle/pre_define/PICBoris.h	/^    typedef typename mesh_type::point_type point_type;$/;"	t	struct:simpla::particle::engine::BorisEngine
point_type	core/particle/pre_define/PICGyro.h	/^    typedef typename mesh_type::point_type point_type;$/;"	t	struct:simpla::particle::engine::GyroParticleWithCylindricalCoord
point_type	core/phy_solver/em_fluid.h	/^    typedef typename mesh_type::point_type point_type;$/;"	t	class:simpla::phy_solver::EMFluid
point_type	example/em_tokamak/tokamak.cpp	/^    typedef typename mesh_type::point_type point_type;$/;"	t	struct:simpla::EMTokamak	file:
point_type	example/pic/demo_pic.h	/^	typedef pic_demo point_type;$/;"	t	struct:simpla::FiberBundle
pointer	core/data_model/DataSet.h	/^    template<typename TV> TV *pointer() { return reinterpret_cast<TV *>(data.get()); }$/;"	f	struct:simpla::data_model::DataSet
pointer	core/data_model/DataSet.h	/^    template<typename TV> TV const *pointer() const { return reinterpret_cast<TV *>(data.get()); }$/;"	f	struct:simpla::data_model::DataSet
pointer	core/gtl/containers/container_dense.h	/^	typedef value_type * pointer;$/;"	t	class:simpla::DenseContainer
pointer	core/gtl/iterator/iterator.h	/^	typedef typename iterator::pointer pointer;$/;"	t	struct:std::iterator_traits
pointer	core/gtl/iterator/sp_iterator_mapped.h	/^	typedef value_type* pointer;$/;"	t	struct:simpla::Iterator
pointer	core/gtl/iterator/sp_iterator_shared_container.h	/^	typedef value_type* pointer;$/;"	t	class:simpla::TransformIterator
pointer	core/gtl/iterator/sp_iterator_shared_container.h	/^	typedef value_type* pointer;$/;"	t	struct:simpla::_impl::StorageSharedContainer
points	core/geometry/test/geometry_test.cpp	/^	std::vector<coordinate_tuple> points;$/;"	m	class:TestModel	file:
points	core/model/test/model_test.cpp	/^	std::vector<coordinates_type> points;$/;"	m	class:TestModel	file:
policy	core/manifold/obsoleted/amr_policy.h	/^namespace simpla { namespace manifold { namespace policy$/;"	n	namespace:simpla::manifold
policy	core/manifold/obsoleted/embedded_policy.h	/^namespace simpla { namespace manifold { namespace policy$/;"	n	namespace:simpla::manifold
policy	core/manifold/obsoleted/time_integrator_policy.h	/^namespace simpla { namespace manifold { namespace policy$/;"	n	namespace:simpla::manifold
policy	core/manifold/policy/FvmStructuredPolicy.h	/^namespace simpla { namespace manifold { namespace policy$/;"	n	namespace:simpla::manifold
policy	core/manifold/policy/IOPolicy.h	/^namespace manifold { namespace policy$/;"	n	namespace:simpla::manifold
policy	core/manifold/policy/LinearInterpolatorPolicy.h	/^namespace simpla { namespace manifold { namespace policy$/;"	n	namespace:simpla::manifold
policy	core/manifold/policy/ParallelPolicy.h	/^namespace simpla { namespace manifold { namespace policy$/;"	n	namespace:simpla::manifold
policy	core/manifold/policy/StoragePolicy.h	/^namespace manifold { namespace policy$/;"	n	namespace:simpla::manifold
poly	core/geometry/obsolete/polygons.h	/^} poly_t, *poly;$/;"	t	typeref:struct:__anon2
poly_append	core/geometry/obsolete/polygons.h	/^void poly_append(poly p, vec v)$/;"	f
poly_clip	core/geometry/obsolete/polygons.h	/^poly poly_clip(poly sub, poly clip)$/;"	f
poly_edge_clip	core/geometry/obsolete/polygons.h	/^void poly_edge_clip(poly sub, vec x0, vec x1, int left, poly res)$/;"	f
poly_free	core/geometry/obsolete/polygons.h	/^void poly_free(poly p)$/;"	f
poly_new	core/geometry/obsolete/polygons.h	/^poly poly_new()$/;"	f
poly_t	core/geometry/obsolete/polygons.h	/^} poly_t, *poly;$/;"	t	typeref:struct:__anon2
poly_winding	core/geometry/obsolete/polygons.h	/^int poly_winding(poly p)$/;"	f
polygon_clip	core/geometry/obsolete/line_cliping.h	/^class polygon_clip$/;"	c	namespace:simpla
polygon_type	core/geometry/boost_gemetry_adapted.h	/^	typedef sgm::Polygon<CS> polygon_type;$/;"	t	struct:boost::geometry::traits::exterior_ring
polygon_type	core/geometry/boost_gemetry_adapted.h	/^	typedef sgm::Polygon<CS> polygon_type;$/;"	t	struct:boost::geometry::traits::interior_rings
polygon_type	core/model/obsoleted/revolve_polygon.h	/^    typedef Polygon<2> polygon_type;$/;"	t	struct:simpla::RevolvePolygon
pool_	core/gtl/utilities/memory_pool.cpp	/^    std::multimap<size_t, void *> pool_;$/;"	m	struct:simpla::MemoryPool::pimpl_s	file:
pool_depth_	core/gtl/utilities/memory_pool.cpp	/^    size_t pool_depth_ = 0;$/;"	m	struct:simpla::MemoryPool::pimpl_s	file:
pop	core/gtl/utilities/memory_pool.cpp	/^void *MemoryPool::pimpl_s::pop(size_t s)$/;"	f	class:simpla::MemoryPool::pimpl_s
pop	core/gtl/utilities/memory_pool.cpp	/^void *MemoryPool::pop(size_t s)$/;"	f	class:simpla::MemoryPool
pop_from_lua	core/gtl/utilities/lua_object_ext.h	/^inline unsigned int pop_from_lua(lua_State *L, int idx, T *v, Args *... rest)$/;"	f	namespace:simpla::lua::_impl
pop_from_lua	core/gtl/utilities/lua_object_ext.h	/^inline unsigned int pop_from_lua(lua_State *L, int)$/;"	f	namespace:simpla::lua::_impl
post_process	applications/contexts/explicit_em.h	/^bool ExplicitEMContext<TM>::post_process()$/;"	f	class:simpla::ExplicitEMContext
power2	core/gtl/type_traits.h	/^T power2(T const &v)$/;"	f	namespace:simpla
power3	core/gtl/type_traits.h	/^T power3(T const &v)$/;"	f	namespace:simpla
pre_process	applications/contexts/explicit_em.h	/^bool ExplicitEMContext<TM>::pre_process()$/;"	f	class:simpla::ExplicitEMContext
pred_	core/gtl/iterator/sp_range_filter.h	/^	pred_function pred_;$/;"	m	struct:simpla::FilterRange
pred_function	core/gtl/iterator/sp_range_filter.h	/^	typedef std::function<bool(value_type const &)> pred_function;$/;"	t	struct:simpla::FilterRange
predicate_fun	core/gtl/iterator/sp_iterator_filter.h	/^	typedef TPred predicate_fun;$/;"	t	struct:simpla::sp_fliter_iterator
prev	core/gtl/iterator/sp_iterator_mapped.h	/^	void prev()$/;"	f	struct:simpla::Iterator
prev	core/parallel/obsoleted/blocked_range.h	/^	void prev()$/;"	f	struct:simpla::iterator
previous	core/gtl/mpl.h	/^	typedef cat_tuple_t<T0, typename split_tuple<I - 1, T...>::previous> previous;$/;"	t	struct:simpla::mpl::split_tuple
previous	core/gtl/mpl.h	/^	typedef std::tuple<> previous;$/;"	t	struct:simpla::mpl::split_tuple
primary_type	core/gtl/ntuple.h	/^struct primary_type<nTuple<BooleanExpression<TOP, T...> > >$/;"	s	namespace:simpla::traits
primary_type	core/gtl/ntuple.h	/^struct primary_type<nTuple<T, N...>>$/;"	s	namespace:simpla::traits
primary_type	core/gtl/type_traits.h	/^template<typename T> struct primary_type$/;"	s	namespace:simpla::traits
primitive_type	core/geometry/chains.h	/^    typedef TPrimitive primitive_type;$/;"	t	struct:simpla::geometry::model::Chains
primitive_type	core/geometry/model.h	/^	typedef Primitive<2, CS, TAG> primitive_type;$/;"	t	struct:simpla::geometry::model::Surface
print	applications/contexts/explicit_em.h	/^    std::ostream &print(std::ostream &os) const$/;"	f	struct:simpla::ExplicitEMContext
print	applications/particle_solver/fluid_cold_engine.h	/^	std::ostream& print(std::ostream & os) const$/;"	f	class:simpla::Particle
print	applications/particle_solver/pic_engine_deltaf2.h	/^	std::ostream & print(std::ostream & os) const$/;"	f	struct:simpla::PICEngineDeltaF
print	applications/particle_solver/pic_engine_ggauge.h	/^	OS & print(OS & os) const$/;"	f	class:simpla::PICEngineGGauge
print	applications/particle_solver/pic_engine_implicit.h	/^	OS & print(OS & os) const$/;"	f	struct:simpla::PICEngineImplicit
print	core/base/DataObject.cpp	/^std::ostream &DataObject::print(std::ostream &os, int indent) const$/;"	f	class:simpla::base::DataObject
print	core/base/Object.cpp	/^std::ostream &Object::print(std::ostream &os, int indent) const$/;"	f	class:simpla::base::Object
print	core/data_model/DataSet.cpp	/^std::ostream &DataSet::print(std::ostream &os) const$/;"	f	class:simpla::data_model::DataSet
print	core/data_model/DataSpace.cpp	/^std::ostream &DataSpace::print(std::ostream &os, int indent) const$/;"	f	class:simpla::data_model::DataSpace
print	core/data_model/DataType.cpp	/^std::ostream &DataType::print(std::ostream &os, int indent) const$/;"	f	class:simpla::data_model::DataType
print	core/gtl/Properties.cpp	/^std::ostream &Properties::print(std::ostream &os, int indent) const$/;"	f	class:simpla::Properties
print	core/gtl/any.h	/^    std::ostream &print(std::ostream &os, int indent = 0) const$/;"	f	struct:simpla::Derived
print	core/gtl/any.h	/^    std::ostream &print(std::ostream &os, int indent = 0) const$/;"	f	struct:simpla::any
print	core/gtl/containers/unordered_set.h	/^    virtual std::ostream &print(std::ostream &os) const$/;"	f	class:simpla::UnorderedSet
print	core/gtl/design_pattern/factory.h	/^	OS & print(OS & os) const$/;"	f	struct:simpla::Factory
print	core/gtl/utilities/parser_configure.h	/^ParserConfigure<TDict>::print(std::ostream & os)$/;"	f	class:simpla::ParserConfigure
print	core/gtl/utilities/pretty_stream.h	/^std::ostream &print(std::ostream &os, T const &first, Others &&... others)$/;"	f	namespace:std
print	core/manifold/Manifold.h	/^    virtual std::ostream &print(std::ostream &os, int indent = 0) const$/;"	f	class:simpla::Manifold
print	core/manifold/mesh/CartesianCoRect.h	/^    virtual std::ostream &print(std::ostream &os, int indent = 1) const$/;"	f	struct:simpla::mesh::CartesianCoRect
print	core/manifold/mesh/CoRectMesh.h	/^    virtual std::ostream &print(std::ostream &os, int indent = 1) const$/;"	f	struct:simpla::mesh::Mesh
print	core/manifold/mesh/CylindricalCoRect.h	/^    virtual std::ostream &print(std::ostream &os, int indent = 1) const$/;"	f	class:simpla::mesh::CylindricalCoRect
print	core/manifold/mesh/RectMesh.h	/^    virtual std::ostream &print(std::ostream &os, int indent = 1) const$/;"	f	struct:simpla::mesh::Mesh
print	core/manifold/obsoleted/embedded_policy.h	/^    template<typename OS> OS &print(OS &os) const$/;"	f	struct:simpla::manifold::policy::EmbeddedPolicy
print	core/manifold/obsoleted/time_integrator_policy.h	/^    virtual std::ostream &print(std::ostream &os) const$/;"	f	struct:simpla::manifold::policy::TimeIntegrator
print	core/manifold/policy/IOPolicy.h	/^    virtual std::ostream &print(std::ostream &os) const$/;"	f	struct:simpla::manifold::policy::IOPolicy
print	core/manifold/policy/ParallelPolicy.h	/^    virtual std::ostream &print(std::ostream &os) const$/;"	f	struct:simpla::manifold::policy::ParallelPolicy
print	core/manifold/policy/StoragePolicy.h	/^    virtual std::ostream &print(std::ostream &os) const$/;"	f	struct:simpla::manifold::policy::StoragePolicy
print	core/model/GEqdsk.cpp	/^std::ostream &GEqdsk::print(std::ostream &os)$/;"	f	class:simpla::GEqdsk
print	core/particle/Particle.h	/^    virtual std::ostream &print(std::ostream &os, int indent = 0) const$/;"	f	struct:simpla::particle::Particle
print	core/particle/ParticleContainer.h	/^std::ostream &ParticleContainer<P, M>::print(std::ostream &os, int indent) const$/;"	f	class:simpla::particle::ParticleContainer
print	core/particle/ParticleProxy.h	/^    std::ostream &print(std::ostream &os, int indent) const { return m_self_->print(os, indent); }$/;"	f	class:simpla::particle::ParticleProxy
print	core/particle/obsolete/kinetic_particle.h	/^    std::ostream &print(std::ostream &os) const$/;"	f	struct:KineticParticle
print	core/particle/obsolete/probe_particle.h	/^    std::ostream &print(std::ostream &os) const$/;"	f	struct:simpla::ProbeParticle
print	core/physics/PhysicalConstants.cpp	/^std::ostream &PhysicalConstants::print(std::ostream &os) const$/;"	f	class:simpla::PhysicalConstants
printNdArray	core/gtl/utilities/pretty_stream.h	/^printNdArray(std::ostream &os, TV const *v, int rank, TI const *d,$/;"	f	namespace:simpla
print_	applications/contexts/explicit_em.h	/^OS &ExplicitEMContext<TM>::print_(OS &os) const$/;"	f	class:simpla::ExplicitEMContext
print_	applications/particle_solver/fluid_cold_engine.h	/^	OS & print_(OS& os) const$/;"	f	class:simpla::Particle
print_helper	core/gtl/utilities/pretty_stream.h	/^std::ostream &print_helper(std::ostream &os, std::tuple<Args ...> const &v, std::integral_constant<int, 0>)$/;"	f	namespace:std::_impl
print_helper	core/gtl/utilities/pretty_stream.h	/^std::ostream &print_helper(std::ostream &os, std::tuple<Args ...> const &v, std::integral_constant<int, N>)$/;"	f	namespace:std::_impl
process_num	core/parallel/MPIComm.cpp	/^int MPIComm::process_num() const$/;"	f	class:simpla::parallel::MPIComm
product_type	core/gtl/design_pattern/factory.h	/^			TProduct, std::shared_ptr<TProduct>>::type product_type;$/;"	t	struct:simpla::Factory
profile	core/model/GEqdsk.cpp	/^Real GEqdsk::profile(std::string const &name, Real p_psi) const$/;"	f	class:simpla::GEqdsk
profile	core/model/GEqdsk.h	/^    Real profile(std::string const &name, Real R, Real Z) const { return profile(name, psi(R, Z)); }$/;"	f	class:simpla::GEqdsk
profile	core/model/GEqdsk.h	/^    Real profile(std::string const &name, point_type const &x) const$/;"	f	class:simpla::GEqdsk
project	core/manifold/obsoleted/fiber_bundle.h	/^    inline typename mesh_type::point_type project(point_type const &p) const$/;"	f	struct:simpla::manifold::DirectMap
project	core/particle/ParticleTracker.h	/^    point_type project(sample_type const &p) const { return P::project(p.p); }$/;"	f	class:simpla::particle::enable_tracking
project	core/particle/pre_define/GuidingCenter.h	/^    point_type project(sample_type const &z) const { return z.x; }$/;"	f	struct:simpla::particle::engine::GuidingCenterEngine
project	core/particle/pre_define/PICBoris.h	/^    point_type project(sample_type const &z) const { return z.x; }$/;"	f	struct:simpla::particle::engine::BorisEngine
project	core/particle/pre_define/PICGyro.h	/^    point_type project(sample_type const &z) const { return z.X; }$/;"	f	struct:simpla::particle::engine::GyroParticleWithCylindricalCoord
project	core/particle/test/particle_generator_test.cpp	/^    Vec3 project(sample_type const &p) const { return p.z.x; }$/;"	f	struct:simpla::PICDemo
project	example/pic/demo_pic.h	/^	inline typename base_manifold::point_type project(point_type const &p, Args &&...args) const$/;"	f	struct:simpla::FiberBundle
project_map_type	core/manifold/obsoleted/fiber_bundle.h	/^    typedef PI project_map_type; \/\/!<  projection map$/;"	t	class:simpla::manifold::FiberBundle
properties	applications/particle_solver/fluid_cold_engine.h	/^	Properties properties;$/;"	m	class:simpla::Particle
properties	core/base/Attribute.h	/^    virtual Properties &properties() { return m_properties_; };$/;"	f	class:simpla::base::Attribute
properties	core/base/Attribute.h	/^    virtual Properties const &properties() const { return m_properties_; };$/;"	f	class:simpla::base::Attribute
properties	core/data_model/DataSet.h	/^    Properties properties;$/;"	m	struct:simpla::data_model::DataSet
properties	core/particle/Particle.h	/^    virtual Properties &properties() { return m_data_->properties(); };$/;"	f	struct:simpla::particle::Particle
properties	core/particle/Particle.h	/^    virtual Properties const &properties() const { return m_data_->properties(); };$/;"	f	struct:simpla::particle::Particle
properties	core/particle/ParticleProxy.h	/^    virtual Properties &properties() { return m_self_->properties(); }$/;"	f	class:simpla::particle::ParticleProxy
properties	core/particle/ParticleProxy.h	/^    virtual Properties const &properties() const { return m_self_->properties(); }$/;"	f	class:simpla::particle::ParticleProxy
proportional_split	core/parallel/ParallelDummy.h	/^struct proportional_split$/;"	s	namespace:simpla::serial::tags
psi	core/model/GEqdsk.cpp	/^Real GEqdsk::psi(Real R, Real Z) const$/;"	f	class:simpla::GEqdsk
ptr_	core/gtl/any.h	/^    BasePtr ptr_;$/;"	m	struct:simpla::any
pts	scripts/PostProcesse/particle_time_scripts.py	/^pts=vtk.vtkPoints()$/;"	v
pts	scripts/PostProcesse/pv_prog_source.py	/^pts=vtk.vtkPoints()$/;"	v
pull_back	applications/particle_solver/pic_engine_fullf.h	/^	static inline std::tuple<coordinate_tuple, vector_type, scalar_type> pull_back(Point_s const & p)$/;"	f	class:simpla::PICEngineFullF
pull_back	applications/particle_solver/pic_engine_ggauge.h	/^	inline Real pull_back(Point_s const & p, nTuple<3, Real> *x, nTuple<3, Real> * v) const$/;"	f	class:simpla::PICEngineGGauge
pull_back	core/field/obsoleted/field_sparse.h	/^	template<typename TFun> void pull_back(TFun const &fun)$/;"	f	struct:simpla::Field
pull_back	core/field/test/trash/field_continue.h	/^	template<typename TFun> void pull_back(TFun const &fun)$/;"	f	struct:simpla::Field
push	core/gtl/utilities/log.cpp	/^void LoggerStreams::push(int level, std::string const &msg)$/;"	f	class:simpla::logger::LoggerStreams
push	core/gtl/utilities/log.h	/^    Logger &push(LoggerStreamManipulator manip)$/;"	f	class:simpla::logger::Logger
push	core/gtl/utilities/log.h	/^    inline this_type &push(T const &value)$/;"	f	class:simpla::logger::Logger
push	core/gtl/utilities/log.h	/^    inline this_type const &push(T const &value) const$/;"	f	class:simpla::logger::Logger
push	core/gtl/utilities/memory_pool.cpp	/^void MemoryPool::pimpl_s::push(void *p, size_t s)$/;"	f	class:simpla::MemoryPool::pimpl_s
push	core/gtl/utilities/memory_pool.cpp	/^void MemoryPool::push(void *p, size_t s)$/;"	f	class:simpla::MemoryPool
push	core/particle/Particle.h	/^    virtual void push(Real t0, Real t1)$/;"	f	struct:simpla::particle::Particle
push	core/particle/ParticleProxy.h	/^    virtual void push(Real dt, Real t, TE const &E, TB const &B) { m_self_->push(dt, t, E, B); }$/;"	f	class:simpla::particle::ParticleProxy
push	core/particle/ParticleTracker.h	/^    void push(sample_type *p, Args &&...args) const$/;"	f	class:simpla::particle::enable_tracking
push	core/particle/pre_define/GuidingCenter.h	/^    void push(sample_type *p0, Real dt, Real t0, TE const &fE, TB const &fB) const$/;"	f	struct:simpla::particle::engine::GuidingCenterEngine
push	core/particle/pre_define/PICBoris.h	/^    void push(Real t0, Real t1, sample_type *p0) const$/;"	f	struct:simpla::particle::engine::BorisEngine
push	core/particle/pre_define/PICGyro.h	/^    void push(Real dt, Real t0, sample_type *p0) const$/;"	f	struct:simpla::particle::engine::GyroParticleWithCylindricalCoord
push	core/particle/test/particle_generator_test.cpp	/^    void push(sample_type *p, Real dt, Real t, TE const &E, TB const &B)$/;"	f	struct:simpla::PICDemo
push_back	core/data_model/DataType.cpp	/^void DataType::push_back(DataType &&d_type, std::string const &name, int pos)$/;"	f	class:simpla::data_model::DataType
push_back	core/geometry/polygon.cpp	/^void Polygon<2>::push_back(point_type const &pp)$/;"	f	class:simpla::geometry::Polygon
push_back	core/particle/obsolete/kinetic_particle.h	/^    void push_back(Args &&...args)$/;"	f	struct:KineticParticle
push_back	core/particle/obsolete/probe_particle.h	/^    void push_back(Args &&...args)$/;"	f	struct:simpla::ProbeParticle
push_buffer	core/io/HDF5Stream.cpp	/^void HDF5Stream::push_buffer(std::string const &url, data_model::DataSet const &ds)$/;"	f	class:simpla::io::HDF5Stream
push_container_to_lua	core/gtl/utilities/lua_object_ext.h	/^void push_container_to_lua(lua_State *L, TC const &v)$/;"	f	namespace:simpla::lua::_impl
push_forward	applications/particle_solver/pic_engine_deltaf.h	/^	static inline Point_s push_forward(coordinate_tuple const & x, Vec3 const &v, scalar_type f)$/;"	f	struct:simpla::ParticleEngine
push_forward	applications/particle_solver/pic_engine_fullf.h	/^	static inline Point_s push_forward(coordinate_tuple const & x, vector_type const &v, scalar_type f)$/;"	f	class:simpla::PICEngineFullF
push_forward	applications/particle_solver/pic_engine_ggauge.h	/^	inline void push_forward(nTuple<3, Real> const&x, nTuple<3, Real> const& v, Point_s * p) const$/;"	f	class:simpla::PICEngineGGauge
push_forward	core/particle/ParticleTracker.h	/^    std::tuple<point_type, vector_type> push_forward(point_type const &p) const$/;"	f	class:simpla::particle::enable_tracking
push_forward	core/particle/obsolete/simple_particle.h	/^	Point_s push_forward(coordinate_tuple const & x, vector_type const &v,$/;"	f	struct:simpla::SimpleParticleEngine
push_forward	core/particle/pre_define/GuidingCenter.h	/^    std::tuple<point_type, vector_type> push_forward(sample_type const &z) const$/;"	f	struct:simpla::particle::engine::GuidingCenterEngine
push_forward	core/particle/pre_define/PICBoris.h	/^    std::tuple<point_type, vector_type> push_forward(sample_type const &z) const$/;"	f	struct:simpla::particle::engine::BorisEngine
push_forward	example/pic/demo_pic.h	/^	inline vector_type push_forward(point_type const &p, Args &&...args) const$/;"	f	struct:simpla::FiberBundle
push_front	core/gtl/containers/unordered_set.h	/^    void push_front(TV &&v, Hash const &hasher)$/;"	f	class:simpla::UnorderedSet
push_to_lua	core/gtl/utilities/lua_object_ext.h	/^inline unsigned int push_to_lua(lua_State *L)$/;"	f	namespace:simpla::lua::_impl
push_to_lua	core/gtl/utilities/lua_object_ext.h	/^inline unsigned int push_to_lua(lua_State *L, T const &v, Args const &... rest)$/;"	f	namespace:simpla::lua::_impl
pwd	core/io/IOStream.cpp	/^std::string IOStream::pwd() const { return (current_file_name() + ":" + current_group_name()); }$/;"	f	class:simpla::io::IOStream
q	applications/fokker_planck/lhw.cpp	/^	Real q;$/;"	m	struct:PICDeltaF	file:
q	applications/particle_solver/fluid_cold_engine.h	/^	const Real q;$/;"	m	class:simpla::Particle
q	applications/particle_solver/pic_engine_deltaf2.h	/^	Real m, cmr_, q, q_k_;$/;"	m	struct:simpla::PICEngineDeltaF
q	applications/particle_solver/pic_engine_ggauge.h	/^	Real q;$/;"	m	class:simpla::PICEngineGGauge
q	applications/particle_solver/pic_engine_implicit.h	/^	Real q;$/;"	m	struct:simpla::PICEngineImplicit
q	core/field/test/field_diff_calculus_test.h	/^    Real q(point_type const &x) const$/;"	f	class:FETLTest
q	scripts/animation.py	/^q=linspace(0,6.28\/4,128)$/;"	v
q_	applications/particle_solver/pic_engine_fullf.h	/^	Real q_;$/;"	m	class:simpla::PICEngineFullF
q_	core/physics/PhysicalConstants.h	/^    std::map<std::string, double> q_; \/\/physical quantity$/;"	m	class:simpla::PhysicalConstants
q_kT_	applications/fokker_planck/lhw.cpp	/^	Real cmr_, q_kT_;$/;"	m	struct:PICDeltaF	file:
q_kT_	applications/particle_solver/pic_engine_deltaf.h	/^	Real cmr_, q_kT_;$/;"	m	struct:simpla::ParticleEngine
q_kT_	core/particle/obsolete/simple_particle.h	/^	Real cmr_, q_kT_;$/;"	m	struct:simpla::SimpleParticleEngine
q_kT_	example/probe_particle/demo_probe_particle.h	/^	Real cmr_, q_kT_;$/;"	m	struct:simpla::ProbeDemo
q_k_	applications/particle_solver/pic_engine_deltaf2.h	/^	Real m, cmr_, q, q_k_;$/;"	m	struct:simpla::PICEngineDeltaF
r	core/geometry/obsolete/geometry_object.h	/^	Real r;$/;"	m	struct:simpla::geometry_object::Cylinder
r	core/geometry/obsolete/geometry_object.h	/^	Real r;$/;"	m	struct:simpla::geometry_object::Ring
r	core/geometry/obsolete/geometry_object.h	/^	Real r;$/;"	m	struct:simpla::geometry_object::Sphere
r	scripts/animation.py	/^r=linspace(1.2,2.8,128)$/;"	v
range	core/base/Attribute.h	/^    typename mesh_type::range_type range() { return this->mesh().template range<IFORM>(); }$/;"	f	class:simpla::base::Attribute
range	core/field/FieldDense.h	/^    typename mesh_type::range_type range() const { return mesh().template range<iform>(); }$/;"	f	class:simpla::Field
range	core/manifold/mesh/MeshBlock.h	/^    range_type range() const$/;"	f	struct:simpla::mesh::MeshBlock
range	core/parallel/obsoleted/blocked_range.h	/^	range()$/;"	f	struct:simpla::range
range	core/parallel/obsoleted/blocked_range.h	/^	range(index_tuple const & b, index_tuple const& e, id_type shift) :$/;"	f	struct:simpla::range
range	core/parallel/obsoleted/blocked_range.h	/^	range(range const & that) :$/;"	f	struct:simpla::range
range	core/parallel/obsoleted/blocked_range.h	/^struct range$/;"	s	namespace:simpla
range_type	core/geometry/obsolete/surface.h	/^	typedef typename mesh_type::range_type range_type;$/;"	t	class:simpla::Surface
range_type	core/gtl/containers/unordered_set.h	/^    typedef std::set<key_type> range_type;$/;"	t	class:simpla::UnorderedSet
range_type	core/manifold/mesh/MeshIds.h	/^        range_type() : m_iform_(VERTEX), m_min_(), m_max_(m_min_), m_grain_size_(m_min_) { }$/;"	f	struct:simpla::mesh::MeshEntityIdCoder::range_type
range_type	core/manifold/mesh/MeshIds.h	/^        range_type(T0 const &b, T1 const &e, index_tuple const &grain_size, int IFORM = VERTEX)$/;"	f	struct:simpla::mesh::MeshEntityIdCoder::range_type
range_type	core/manifold/mesh/MeshIds.h	/^        range_type(index_tuple const &b, index_tuple const &e, int IFORM = VERTEX)$/;"	f	struct:simpla::mesh::MeshEntityIdCoder::range_type
range_type	core/manifold/mesh/MeshIds.h	/^        range_type(range_type &r, parallel::tags::split)$/;"	f	struct:simpla::mesh::MeshEntityIdCoder::range_type
range_type	core/manifold/mesh/MeshIds.h	/^        range_type(this_type &r, parallel::tags::proportional_split const &proportion)$/;"	f	struct:simpla::mesh::MeshEntityIdCoder::range_type
range_type	core/manifold/mesh/MeshIds.h	/^        range_type(this_type const &r)$/;"	f	struct:simpla::mesh::MeshEntityIdCoder::range_type
range_type	core/manifold/mesh/MeshIds.h	/^    struct range_type$/;"	s	struct:simpla::mesh::MeshEntityIdCoder
range_type	core/manifold/obsoleted/fiber_bundle.h	/^    typedef typename mesh_type::range_type range_type;$/;"	t	class:simpla::manifold::FiberBundle
range_type	core/parallel/obsoleted/distributed_unordered_set.h	/^	typedef TRange range_type;$/;"	t	struct:simpla::Distributed
range_type	core/particle/Particle.h	/^    typedef typename mesh_type::range_type range_type;$/;"	t	struct:simpla::particle::Particle
range_type	core/particle/ParticleContainer.h	/^    typedef typename mesh_type::range_type range_type;$/;"	t	struct:simpla::particle::ParticleContainer
range_type	core/phy_solver/em_fluid.h	/^    typedef typename mesh_type::range_type range_type;$/;"	t	class:simpla::phy_solver::EMFluid
range_type	example/em_tokamak/tokamak.cpp	/^    typedef typename mesh_type::range_type range_type;$/;"	t	struct:simpla::EMTokamak	file:
rank	core/base/Attribute.h	/^    virtual int rank() const { return 0; }$/;"	f	class:simpla::base::AttributeObject
rank	core/base/Attribute.h	/^    virtual int rank() const { return traits::rank<TV>::value; }$/;"	f	class:simpla::base::Attribute
rank	core/data_model/DataType.cpp	/^int DataType::rank() const$/;"	f	class:simpla::data_model::DataType
rank	core/gtl/ntuple.h	/^struct rank<nTuple<T, N...>> : public std::integral_constant<int,$/;"	s	namespace:simpla::traits
rank	core/gtl/type_traits.h	/^struct rank : public std::integral_constant<int, std::rank<T>::value>$/;"	s	namespace:simpla::traits
rank	core/manifold/Calculus.h	/^struct rank<Field<T...> > : public std::integral_constant<int, 3>$/;"	s	namespace:simpla::traits
raw_cast	core/gtl/type_cast.h	/^T & raw_cast(U& s)$/;"	f	namespace:simpla
raw_cast	core/gtl/type_cast.h	/^T raw_cast(U&& s)$/;"	f	namespace:simpla
rbegin	core/gtl/iterator/sp_range_filter.h	/^	iterator rbegin() const$/;"	f	struct:simpla::FilterRange
rbegin	core/gtl/iterator/sp_range_filter.h	/^	iterator rbegin()$/;"	f	struct:simpla::FilterRange
rbegin	core/parallel/obsoleted/blocked_range.h	/^	iterator rbegin() const$/;"	f	struct:simpla::range
read	core/io/HDF5Stream.cpp	/^std::string HDF5Stream::read(std::string const &url, data_model::DataSet *ds, size_t flag)$/;"	f	class:simpla::io::HDF5Stream
read_from	scripts/PreProcess/input_geqdsk.py	/^    def read_from(self,f):$/;"	m	class:GEQDSK
read_geqdsk	scripts/geqdsk.py	/^def read_geqdsk(filename):           $/;"	f
read_geqdsk	scripts/read_geqdsk.py	/^def read_geqdsk(filename):$/;"	f
real	core/gtl/complex.h	/^template<typename T> inline constexpr T real(T const &v)$/;"	f	namespace:std
real	core/gtl/sp_complex.h	/^template<typename T> inline constexpr T real(T const &v)$/;"	f	namespace:std
record_size	core/io/WriteBuffer.h	/^    void record_size(size_t s) { m_record_size_ = s; }$/;"	f	class:simpla::io::WriteBuffer
rectangle_distribution	core/numeric/rectangle_distribution.h	/^    rectangle_distribution()$/;"	f	class:simpla::rectangle_distribution
rectangle_distribution	core/numeric/rectangle_distribution.h	/^    rectangle_distribution(TBox const &b)$/;"	f	class:simpla::rectangle_distribution
rectangle_distribution	core/numeric/rectangle_distribution.h	/^    rectangle_distribution(nTuple<double, NDIMS> const &xmin,$/;"	f	class:simpla::rectangle_distribution
rectangle_distribution	core/numeric/rectangle_distribution.h	/^    rectangle_distribution(rectangle_distribution const &other) :$/;"	f	class:simpla::rectangle_distribution
rectangle_distribution	core/numeric/rectangle_distribution.h	/^class rectangle_distribution$/;"	c	namespace:simpla
recursive_try_index_aux	core/gtl/type_traits.h	/^struct recursive_try_index_aux$/;"	s	namespace:simpla::traits::_impl
recursive_try_index_aux	core/gtl/type_traits.h	/^struct recursive_try_index_aux<0>$/;"	s	namespace:simpla::traits::_impl
recv_buffer	core/parallel/DistributedObject.h	/^    std::vector<link_s> recv_buffer;$/;"	m	struct:simpla::parallel::DistributedObject
recv_buffer	core/parallel/obsoleted/distributed_unordered_set.h	/^		std::shared_ptr<value_type> recv_buffer;$/;"	m	struct:simpla::Distributed::connection_node
recv_range	core/parallel/obsoleted/distributed_unordered_set.h	/^		range_type recv_range;$/;"	m	struct:simpla::Distributed::connection_node
recv_size	core/parallel/obsoleted/distributed_unordered_set.h	/^		size_t recv_size;$/;"	m	struct:simpla::Distributed::connection_node
reduce	core/gtl/ntuple.h	/^T const &reduce(TOP const &op, T const &v)$/;"	f	namespace:simpla
reduce	core/gtl/ntuple.h	/^traits::value_type_t<nTuple<Expression<T...> > > reduce(TOP const &op,$/;"	f	namespace:simpla
reduce	core/gtl/ntuple.h	/^traits::value_type_t<nTuple<T, N...>> reduce(TOP const &op,$/;"	f	namespace:simpla
reduce	core/parallel/MPIAuxFunctions.cpp	/^void reduce(void const *send_data, void *recv_data, size_t count,$/;"	f	namespace:simpla::parallel
reduce	core/parallel/MPIAuxFunctions.h	/^T reduce(T send, std::string const &op_c = "Sum")$/;"	f	namespace:simpla::parallel
reduce	core/parallel/MPIAuxFunctions.h	/^nTuple<T, DIMS> reduce(nTuple<T, DIMS> const &send, std::string const &op_c =$/;"	f	namespace:simpla::parallel
reduce	core/parallel/MPIAuxFunctions.h	/^void reduce(T *p_send, std::string const &op_c = "Sum")$/;"	f	namespace:simpla::parallel
reduce	core/parallel/MPIAuxFunctions.h	/^void reduce(T *send_data, T *recv_data, size_t count,$/;"	f	namespace:simpla::parallel
reduce	core/parallel/MPIAuxFunctions.h	/^void reduce(nTuple<T, DIMS> *p_send, std::string const &op_c = "Sum")$/;"	f	namespace:simpla::parallel
reference	core/field/FieldDense.h	/^    void reference(this_type &other) { m_data_ = other.m_data_; }$/;"	f	class:simpla::Field
reference	core/field/FieldTraits.h	/^struct reference<Field<TM, TV, Others...> >$/;"	s	namespace:simpla::traits
reference	core/gtl/containers/container_dense.h	/^	typedef value_type & reference;$/;"	t	class:simpla::DenseContainer
reference	core/gtl/iterator/iterator.h	/^	typedef typename iterator::reference reference;$/;"	t	struct:std::iterator_traits
reference	core/gtl/iterator/sp_iterator_mapped.h	/^	typedef value_type& reference;$/;"	t	struct:simpla::Iterator
reference	core/gtl/iterator/sp_iterator_shared_container.h	/^	typedef value_type& reference;$/;"	t	class:simpla::TransformIterator
reference	core/gtl/iterator/sp_iterator_shared_container.h	/^	typedef value_type& reference;$/;"	t	struct:simpla::_impl::StorageSharedContainer
reference	core/gtl/ntuple.h	/^struct reference<nTuple<T, M, N...>>$/;"	s	namespace:simpla::traits
reference	core/gtl/ntuple.h	/^struct reference<nTuple<T>>$/;"	s	namespace:simpla::traits
reference	core/gtl/type_traits.h	/^template<typename T> struct reference$/;"	s	namespace:simpla::traits
reference_topology_geometry	core/io/XDMFStream.cpp	/^void XDMFStream::reference_topology_geometry(std::string const &id)$/;"	f	class:simpla::io::XDMFStream
refinement	core/base/Patch.h	/^    virtual void refinement() { }$/;"	f	class:simpla::base::Patch
refinement	core/field/obsoleted/field_patch.h	/^    virtual void refinement(size_t id)$/;"	f	class:simpla::FieldAMRPolicy
refinement	core/manifold/obsoleted/amr_policy.h	/^AMR<TM>::refinement(Args &&...args)$/;"	f	class:simpla::manifold::policy::AMR
refinement	core/manifold/obsoleted/patch/mesh_patch.h	/^MeshPatch<TM>::refinement(box_type const &b)$/;"	f	class:simpla::mesh::MeshPatch
refinement_ratio	core/manifold/obsoleted/amr_policy.h	/^    size_t refinement_ratio() const { return m_refinement_ratio_; }$/;"	f	class:simpla::manifold::policy::AMR
refinement_ratio	core/manifold/obsoleted/amr_policy.h	/^    void refinement_ratio(size_t r) { m_refinement_ratio_ = r; }$/;"	f	class:simpla::manifold::policy::AMR
refinement_ratio	core/manifold/obsoleted/patch/mesh_patch.h	/^    size_t refinement_ratio() const { return m_refinement_ratio_; }$/;"	f	class:simpla::mesh::MeshPatch
refinement_ratio	core/manifold/obsoleted/patch/mesh_patch.h	/^    void refinement_ratio(size_t r) { m_refinement_ratio_ = r; }$/;"	f	class:simpla::mesh::MeshPatch
reflect	core/geometry/GeoAlgorithm.h	/^constexpr Vec3 reflect(T0 const &v, T1 const &normal)$/;"	f	namespace:simpla::geometry
reflect	core/geometry/algorithm.h	/^model::Polyline<CS> reflect(model::LineSegment<CS> const &poly, TGeoObject const &obj)$/;"	f	namespace:simpla::geometry
reflect	core/particle/ParticleConstraint.h	/^void reflect(Particle<P, M> &p, model::Surface<M> const &surface)$/;"	f	namespace:simpla::particle
reflect_point_by_plane	core/geometry/GeoAlgorithm.h	/^inline Vec3 reflect_point_by_plane(T0 const &x0, T1 const &p0, T2 const &p1,$/;"	f	namespace:simpla::geometry
reflect_vector_by_plane	core/geometry/GeoAlgorithm.h	/^inline Vec3 reflect_vector_by_plane(T0 const &v, T1 const &p0, T2 const &p1,$/;"	f	namespace:simpla::geometry
register_app	core/task_flow/application.h	/^std::string register_app(std::string const &name, Args &&...args)$/;"	f	namespace:simpla
register_app	core/task_flow/use_case.h	/^std::string register_app(std::string const &name, Args &&...args)$/;"	f	namespace:simpla::use_case
register_callback	core/gtl/utilities/parser_configure.h	/^void ParserConfigure<TDict>::register_callback(std::string const & key, TFun const & fun, std::string const& desc)$/;"	f	class:simpla::ParserConfigure
register_material	core/model/obsoleted/model.h	/^    int register_material(std::string const &name)$/;"	f	class:simpla::Model
register_module	core/gtl/utilities/parser_configure.h	/^void ParserConfigure<TDict>::register_module(std::string const & prefix, std::string const& desc)$/;"	f	class:simpla::ParserConfigure
register_task	core/task_flow/task.h	/^    static bool register_task(std::string const &k, std::shared_ptr<task_type> t)$/;"	f	struct:simpla::task_flow::_impl::TaskRegistry
registered_material_	core/model/obsoleted/model.h	/^    std::map<std::string, tag_type> registered_material_;$/;"	m	class:simpla::Model
rehash	core/gtl/containers/UnorderedSet.h	/^UnorderedSet<ValueType, Key>::rehash(Hash const &hash, TRange const &r0, buffer_type *out_buffer)$/;"	f	class:simpla::gtl::UnorderedSet
rehash	core/gtl/containers/UnorderedSet.h	/^UnorderedSet<ValueType, Key>::rehash(Hash const &hash, buffer_type *out_buffer)$/;"	f	class:simpla::gtl::UnorderedSet
rehash	core/gtl/containers/UnorderedSet.h	/^UnorderedSet<ValueType, Key>::rehash(Hash const &hash, key_type const &key, buffer_type *out_buffer)$/;"	f	class:simpla::gtl::UnorderedSet
rehash	core/gtl/containers/unordered_set.h	/^    void rehash(Hash const &hasher)$/;"	f	class:simpla::UnorderedSet
rehash	core/gtl/containers/unordered_set.h	/^    void rehash(TRange const &r, Hash const &hasher)$/;"	f	class:simpla::UnorderedSet
rehash	core/parallel/obsoleted/distributed_unordered_set.h	/^void Distributed<UnorderedSet<TV, Others...>>::rehash(Hash const &hasher)$/;"	f	class:simpla::Distributed
rehash	core/particle/Particle.h	/^    virtual void rehash() { \/*m_data_->rehash();*\/ }$/;"	f	struct:simpla::particle::Particle
rehash	core/particle/ParticleContainer.h	/^ParticleContainer<P, M>::rehash()$/;"	f	class:simpla::particle::ParticleContainer
rehash	core/particle/ParticleContainer.h	/^ParticleContainer<V, K>::rehash(TRange const &r0, buffer_type *out_buffer)$/;"	f	class:simpla::particle::ParticleContainer
rehash	core/particle/ParticleContainer.h	/^ParticleContainer<V, K>::rehash(buffer_type *out_buffer)$/;"	f	class:simpla::particle::ParticleContainer
rehash	core/particle/ParticleContainer.h	/^ParticleContainer<V, K>::rehash(id_type const &key, buffer_type *out_buffer)$/;"	f	class:simpla::particle::ParticleContainer
rehash	core/particle/ParticleProxy.h	/^    virtual void rehash() { m_self_->rehash(); }$/;"	f	class:simpla::particle::ParticleProxy
rehash_one	core/gtl/containers/unordered_set.h	/^    size_t rehash_one(key_type key, base_container_type &other, Hash const &hasher)$/;"	f	class:simpla::UnorderedSet
remove_if	core/gtl/containers/UnorderedSet.h	/^UnorderedSet<ValueType, Key>::remove_if(Predicate const &pred)$/;"	f	class:simpla::gtl::UnorderedSet
remove_if	core/gtl/containers/UnorderedSet.h	/^UnorderedSet<ValueType, Key>::remove_if(Predicate const &pred, key_type const &r0)$/;"	f	class:simpla::gtl::UnorderedSet
remove_if	core/gtl/containers/UnorderedSet.h	/^UnorderedSet<ValueType, Key>::remove_if(Predicate const &pred, key_type const &s)$/;"	f	class:simpla::gtl::UnorderedSet
remove_if	core/gtl/containers/UnorderedSet.h	/^UnorderedSet<ValueType, Key>::remove_if(Predicate const &pred, typename base_type::value_type const &item)$/;"	f	class:simpla::gtl::UnorderedSet
remove_if	core/particle/ParticleContainer.h	/^ParticleContainer<V, K>::remove_if(Predicate const &pred) { remove_if(pred, container_type::range()); }$/;"	f	class:simpla::particle::ParticleContainer
remove_if	core/particle/ParticleContainer.h	/^ParticleContainer<V, K>::remove_if(Predicate const &pred, TRange const &r0)$/;"	f	class:simpla::particle::ParticleContainer
remove_if	core/particle/ParticleContainer.h	/^ParticleContainer<V, K>::remove_if(Predicate const &pred, id_type const &s)$/;"	f	class:simpla::particle::ParticleContainer
remove_observer	core/gtl/design_pattern/observer.h	/^	void remove_observer(std::shared_ptr<observer_type> &observer)$/;"	f	struct:simpla::Observable
rend	core/gtl/iterator/sp_range_filter.h	/^	iterator rend() const$/;"	f	struct:simpla::FilterRange
rend	core/gtl/iterator/sp_range_filter.h	/^	iterator rend()$/;"	f	struct:simpla::FilterRange
rend	core/parallel/obsoleted/blocked_range.h	/^	iterator rend() const$/;"	f	struct:simpla::range
replace_tuple	core/gtl/mpl.h	/^struct replace_tuple<I, U, std::nullptr_t>$/;"	s	namespace:simpla::mpl
replace_tuple	core/gtl/mpl.h	/^struct replace_tuple<I, U, std::tuple<T...> >$/;"	s	namespace:simpla::mpl
replace_tuple	core/gtl/mpl.h	/^struct replace_tuple<I, U,H<T...> >$/;"	s	namespace:simpla::mpl
req_time	scripts/PostProcesse/particle_time_scripts.py	/^req_time = GetUpdateTimestep(self)$/;"	v
res	core/gtl/test/ntuple_perf_test.cpp	/^	value_type aA[N], aB[N], aC[N], aD[N], res[N];$/;"	m	class:nTuplePerf1	file:
res	core/gtl/test/ntuple_perf_test.cpp	/^	value_type aA[N][M], aB[N][M], aC[N][M], aD[N][M], res[N][M];$/;"	m	class:nTuplePerf2	file:
res	core/gtl/test/ntuple_reduce_test.cpp	/^	typename traits::pod_type<T>::type aA, aB, aC, aD, res;$/;"	m	class:TestNtupleReduce	file:
reserve	core/parallel/DistributedCounter.h	/^    void reserve(size_t num)$/;"	f	struct:simpla::parallel::DistributedCounter
reserve	core/parallel/ParallelRandomGenerator.h	/^    void reserve(size_t num)$/;"	f	struct:simpla::parallel::DistributedCounter
reset	core/numeric/rectangle_distribution.h	/^    inline void reset(nTuple<double, NDIMS> const &xmin,$/;"	f	class:simpla::rectangle_distribution
result_of	core/gtl/type_traits.h	/^template<typename _Signature> struct result_of$/;"	s	namespace:simpla::traits
result_of	core/gtl/type_traits_ext.h	/^template<typename F, typename ...Args> struct result_of<F(Args...)>$/;"	s	namespace:simpla
result_type	core/gtl/design_pattern/signal.h	/^    typedef TResult result_type;$/;"	t	struct:simpla::Signal
result_type	core/gtl/function.h	/^    typedef TV result_type;$/;"	t	class:simpla::Function
result_type	core/numeric/sobol_engine.h	/^	typedef T result_type;$/;"	t	class:simpla::sobol_engine
rho	applications/particle_solver/fluid_cold_engine.h	/^	rho_type rho;$/;"	m	class:simpla::Particle
rho1	core/phy_solver/em_fluid.h	/^        traits::field_t<scalar_type, mesh_type, VERTEX> rho1;$/;"	m	struct:simpla::phy_solver::EMFluid::fluid_s
rho1	example/em_tokamak/tokamak.cpp	/^        traits::field_t<scalar_type, mesh_type, VERTEX> rho1;$/;"	m	struct:simpla::EMTokamak::fluid_s	file:
rho_type	applications/field_solver/implicitPushE.h	/^    typedef field<scalar_type, VERTEX> rho_type;$/;"	t	class:simpla::ImplicitPushE
rho_type	applications/particle_solver/fluid_cold_engine.h	/^	typedef typename mesh_type:: template field<VERTEX, scalar_type> rho_type;$/;"	t	class:simpla::Particle
rho_type	applications/particle_solver/pic_engine_ggauge.h	/^	typedef typename mesh_type:: template field<VERTEX, scalar_type> rho_type;$/;"	t	class:simpla::PICEngineGGauge
rho_type	applications/particle_solver/pic_engine_implicit.h	/^	typedef typename mesh_type:: template field<VERTEX, scalar_type> rho_type;$/;"	t	struct:simpla::PICEngineImplicit
rhs	core/gtl/expression_template.h	/^    typename traits::reference<TR>::type rhs;$/;"	m	struct:simpla::AssignmentExpression
ridge	core/geometry/primitive.h	/^struct ridge<model::Primitive<Dimension, Others...>>$/;"	s	namespace:simpla::geometry::traits
right	core/parallel/ParallelDummy.h	/^    size_t right() { return m_right_; }$/;"	f	struct:simpla::serial::tags::proportional_split
right_action	core/manifold/mesh/GeneralMap.h	/^    typedef LinearMap right_action;$/;"	t	struct:simpla::mesh::GeneralMap
ring_const_type	core/geometry/boost_gemetry_adapted.h	/^struct ring_const_type<sgm::Polygon<CS>>$/;"	s	namespace:boost::geometry::traits
ring_mutable_type	core/geometry/boost_gemetry_adapted.h	/^struct ring_mutable_type<sgm::Polygon<CS>>$/;"	s	namespace:boost::geometry::traits
ring_type	core/geometry/model.h	/^	typedef Polyline<CS, tags::is_closed> ring_type;$/;"	t	struct:simpla::geometry::model::Polygon
ring_type	core/geometry/model.h	/^	typedef Polyline<CS, tags::is_closed> ring_type;$/;"	t	struct:simpla::geometry::model::Surface
root	core/gtl/enable_create_from_this.h	/^	object_type & root()$/;"	f	struct:simpla::enable_create_from_this
root	core/gtl/enable_create_from_this.h	/^	object_type const & root() const$/;"	f	struct:simpla::enable_create_from_this
root_	core/gtl/enable_create_from_this.h	/^	holder root_;$/;"	m	struct:simpla::enable_create_from_this
root_holder	core/gtl/enable_create_from_this.h	/^	holder root_holder() const$/;"	f	struct:simpla::enable_create_from_this
root_holder	core/gtl/enable_create_from_this.h	/^	holder root_holder()$/;"	f	struct:simpla::enable_create_from_this
rotate	core/manifold/mesh/MeshIds.h	/^    static constexpr id_type rotate(id_type const &s)$/;"	f	struct:simpla::mesh::MeshEntityIdCoder
s0	applications/field_solver/pml.h	/^	typename mesh_type:: template field<VERTEX, Real> s0, s1, s2;$/;"	m	class:simpla::PML
s1	applications/field_solver/pml.h	/^	typename mesh_type:: template field<VERTEX, Real> s0, s1, s2;$/;"	m	class:simpla::PML
s2	applications/field_solver/pml.h	/^	typename mesh_type:: template field<VERTEX, Real> s0, s1, s2;$/;"	m	class:simpla::PML
s_	core/gtl/utilities/memory_pool.h	/^        size_t s_;$/;"	m	struct:simpla::MemoryPool::deleter_s
s_	core/physics/PhysicalConstants.h	/^    double s_;    \/\/<< time	[second]$/;"	m	class:simpla::PhysicalConstants
sample	core/particle/ParticleTracker.h	/^    sample_type sample(Args &&...args) const$/;"	f	class:simpla::particle::enable_tracking
sample	core/particle/pre_define/GuidingCenter.h	/^    sample_type sample(point_type const &x, vector_type const &v, Real f) const { return sample_type{x, v, f, 1.0}; }$/;"	f	struct:simpla::particle::engine::GuidingCenterEngine
sample	core/particle/pre_define/PICBoris.h	/^    sample_type sample(point_type const &x, vector_type const &v, Real f) const { return sample_type{x, v, f, 1.0}; }$/;"	f	struct:simpla::particle::engine::BorisEngine
sample	core/particle/test/particle_generator_test.cpp	/^    sample_type sample(Vec3 const &x, Vec3 const &v, Real f) const$/;"	f	struct:simpla::PICDemo
sample	core/particle/test/particle_generator_test.cpp	/^    sample_type sample(point_type const &z, Real f) const$/;"	f	struct:simpla::PICDemo
sample_type	core/particle/Particle.h	/^    typedef typename engine_type::sample_type sample_type;$/;"	t	struct:simpla::particle::Particle
sample_type	core/particle/ParticleContainer.h	/^    typedef typename ParticleEngine::sample_type sample_type;$/;"	t	struct:simpla::particle::ParticleContainer
save	applications/contexts/explicit_em.h	/^std::string ExplicitEMContext<TM>::save(std::string const &path) const$/;"	f	class:simpla::ExplicitEMContext
save	applications/particle_solver/fluid_cold_engine.h	/^std::string Particle<TM, ColdFluid, PolicyFluidParticle>::save($/;"	f	class:simpla::Particle
save	core/gtl/containers/container_save_cache.h	/^	std::string save(std::string const & path, bool is_forced = false)$/;"	f	class:simpla::ContainerSaveCache
save	core/io/IOExt.h	/^std::string save(std::string const &url, T const *data, int ndims,$/;"	f	namespace:simpla
save	core/io/IOExt.h	/^std::string save(std::string const &url, std::vector<T> const &data, size_t flag = 0UL)$/;"	f	namespace:simpla
save	core/physics/PhysicalConstants.cpp	/^std::ostream &PhysicalConstants::save(std::ostream &os) const$/;"	f	class:simpla::PhysicalConstants
scalar_field	core/particle/pre_define/PICGyro.h	/^    typedef traits::field_t<scalar_type, mesh_type, VERTEX> scalar_field;$/;"	t	struct:simpla::particle::engine::GyroParticleWithCylindricalCoord
scalar_type	applications/contexts/explicit_em.h	/^    typedef typename mesh_type::scalar_type scalar_type;$/;"	t	struct:simpla::ExplicitEMContext
scalar_type	applications/field_solver/implicitPushE.h	/^    typedef typename mesh_type::scalar_type scalar_type;$/;"	t	class:simpla::ImplicitPushE
scalar_type	applications/field_solver/pml.h	/^	typedef typename mesh_type::scalar_type scalar_type;$/;"	t	class:simpla::PML
scalar_type	applications/fokker_planck/lhw.cpp	/^	typedef std::complex<Real> scalar_type;$/;"	t	struct:PICDeltaF	file:
scalar_type	applications/particle_solver/fluid_cold_engine.h	/^	typedef typename mesh_type::scalar_type scalar_type;$/;"	t	class:simpla::Particle
scalar_type	applications/particle_solver/pic_engine_deltaf.h	/^	typedef Real scalar_type;$/;"	t	struct:simpla::ParticleEngine
scalar_type	applications/particle_solver/pic_engine_deltaf2.h	/^	typedef TS scalar_type;$/;"	t	struct:simpla::PICEngineDeltaF
scalar_type	applications/particle_solver/pic_engine_fullf.h	/^	typedef Real scalar_type;$/;"	t	class:simpla::PICEngineFullF
scalar_type	applications/particle_solver/pic_engine_ggauge.h	/^	typedef typename mesh_type::scalar_type scalar_type;$/;"	t	class:simpla::PICEngineGGauge
scalar_type	applications/particle_solver/pic_engine_implicit.h	/^	typedef typename mesh_type::scalar_type scalar_type;$/;"	t	struct:simpla::PICEngineImplicit
scalar_type	core/field/test/field_basic_algebra_test.h	/^    typedef Real scalar_type;$/;"	t	class:TestField
scalar_type	core/field/test/field_diff_calculus_test.h	/^    typedef typename mesh_type::scalar_type scalar_type;$/;"	t	class:FETLTest
scalar_type	core/field/test/field_dummy.cpp	/^	typedef typename mesh_type::scalar_type scalar_type;$/;"	t	class:FieldTest	file:
scalar_type	core/field/test/trash/fetl_test3.h	/^	typedef typename manifold_type::scalar_type scalar_type;$/;"	t	class:TestFETL
scalar_type	core/geometry/CoordinateSystem.h	/^template<typename CS> struct scalar_type$/;"	s	namespace:simpla::geometry::traits
scalar_type	core/geometry/csCartesian.h	/^    typedef Real scalar_type;$/;"	t	struct:simpla::geometry::CartesianMetric
scalar_type	core/geometry/csCylindrical.h	/^    typedef Real scalar_type;$/;"	t	struct:simpla::geometry::Metric
scalar_type	core/manifold/obsoleted/fiber_bundle.h	/^    typedef Real scalar_type;$/;"	t	class:simpla::manifold::FiberBundle
scalar_type	core/particle/obsolete/simple_particle.h	/^	typedef double scalar_type;$/;"	t	struct:simpla::SimpleParticleEngine
scalar_type	core/particle/pre_define/PICBoris.h	/^    typedef typename mesh_type::scalar_type scalar_type;$/;"	t	struct:simpla::particle::engine::BorisEngine
scalar_type	core/particle/pre_define/PICGyro.h	/^    typedef typename mesh_type::scalar_type scalar_type;$/;"	t	struct:simpla::particle::engine::GyroParticleWithCylindricalCoord
scalar_type	core/phy_solver/em_fluid.h	/^    typedef typename mesh_type::scalar_type scalar_type;$/;"	t	class:simpla::phy_solver::EMFluid
scalar_type	example/em_tokamak/tokamak.cpp	/^    typedef Real scalar_type;$/;"	t	struct:simpla::EMTokamak	file:
scalar_type	example/pic/demo_pic.h	/^	typedef Real scalar_type;$/;"	t	struct:simpla::FiberBundle
scalar_type	example/probe_particle/demo_probe_particle.h	/^	typedef Real scalar_type;$/;"	t	struct:simpla::ProbeDemo
scatter	core/field/obsoleted/field_sparse.h	/^	void scatter(Args && ... args)$/;"	f	struct:simpla::Field
scatter	core/field/test/trash/field_continue.h	/^	void scatter(Args && ... args)$/;"	f	struct:simpla::Field
search_cache	core/model/Constraint.h	/^void search_cache(TM const &m, TRange const &r0, CellCache<TM> const &cache, int flag, Func const &func)$/;"	f	namespace:simpla::model
sed	core/numeric/sobol_engine.h	/^	inline void sed(size_t s)$/;"	f	class:simpla::sobol_engine
seed_	core/numeric/sobol_engine.h	/^	size_t seed_;$/;"	m	class:simpla::sobol_engine
seed_type	core/particle/ParticleGenerator.h	/^    typedef TSeed seed_type;$/;"	t	struct:simpla::particle::ParticleGenerator
select_boundary	core/geometry/select.h	/^void select_boundary(TDict const &dict, Domain<TM...> *domain)$/;"	f	namespace:simpla
select_boundary	core/model/obsoleted/select.h	/^void select_boundary(TDict const &dict, Domain<TM, IFORM> *domain)$/;"	f	namespace:simpla
select_boundary_by_polylines	core/geometry/select.h	/^void select_boundary_by_polylines(Domain<TM...> *domain, TI const & ib,$/;"	f	namespace:simpla
select_boundary_by_polylines	core/model/obsoleted/select.h	/^void select_boundary_by_polylines(Domain<TM, IFORM> *domain, TI const & ib,$/;"	f	namespace:simpla
select_cell_cross_polylines	core/geometry/select.h	/^void select_cell_cross_polylines(PIP const & point_in_polygon, TDomain * domain,$/;"	f	namespace:simpla
select_cell_cross_polylines	core/model/obsoleted/select.h	/^void select_cell_cross_polylines(PIP const & point_in_polygon, TDomain * domain,$/;"	f	namespace:simpla
select_hyperslab	core/data_model/DataSpace.cpp	/^DataSpace &DataSpace::select_hyperslab(index_type const *start,$/;"	f	class:simpla::data_model::DataSpace
select_ids_in_polylines	core/geometry/select.h	/^std::function<bool(TCoord const &)> select_ids_in_polylines($/;"	f	namespace:simpla
select_ids_in_polylines	core/model/obsoleted/select.h	/^std::function<bool(TCoord const &)> select_ids_in_polylines($/;"	f	namespace:simpla
select_ids_in_rectangle	core/model/obsoleted/select.h	/^void select_ids_in_rectangle(TCoord const & v0, TCoord const & v1)$/;"	f	namespace:simpla
select_ids_on_polylines	core/geometry/select.h	/^std::function<bool(TCoord const &)> select_ids_on_polylines($/;"	f	namespace:simpla
select_ids_on_polylines	core/model/obsoleted/select.h	/^std::function<bool(TCoord const &)> select_ids_on_polylines($/;"	f	namespace:simpla
select_point	core/data_model/DataSpace.cpp	/^void DataSpace::select_point(const size_t *idx)$/;"	f	class:simpla::data_model::DataSpace
select_point	core/data_model/DataSpace.cpp	/^void DataSpace::select_point(size_t pos) { m_pimpl_->m_selected_points_.push_back(pos); }$/;"	f	class:simpla::data_model::DataSpace
select_points	core/data_model/DataSpace.cpp	/^void DataSpace::select_points(size_t num, const size_t *tags)$/;"	f	class:simpla::data_model::DataSpace
select_vetrices_near_to_polylines	core/geometry/select.h	/^void select_vetrices_near_to_polylines(TDomain const& domain, TI const & ib,$/;"	f	namespace:simpla
select_vetrices_near_to_polylines	core/model/obsoleted/select.h	/^void select_vetrices_near_to_polylines(TDomain const& domain, TI const & ib,$/;"	f	namespace:simpla
selected_points	core/data_model/DataSpace.cpp	/^std::vector<size_t> &DataSpace::selected_points() { return m_pimpl_->m_selected_points_; };$/;"	f	class:simpla::data_model::DataSpace
selected_points	core/data_model/DataSpace.cpp	/^std::vector<size_t> const &DataSpace::selected_points() const { return m_pimpl_->m_selected_points_; };$/;"	f	class:simpla::data_model::std::DataSpace
self	core/base/Attribute.h	/^    virtual this_type &self() { return *this; }$/;"	f	class:simpla::base::Attribute
self	core/base/Attribute.h	/^    virtual this_type const &self() const { return *this; }$/;"	f	class:simpla::base::Attribute
self	core/manifold/Manifold.h	/^    virtual this_type &self() { return (*this); }$/;"	f	class:simpla::Manifold
self	core/manifold/Manifold.h	/^    virtual this_type const &self() const { return (*this); }$/;"	f	class:simpla::Manifold
self	core/particle/ParticleProxy.h	/^    particle_type &self() { return *m_self_; }$/;"	f	class:simpla::particle::ParticleProxy
self	core/particle/ParticleProxy.h	/^    particle_type const &self() const { return *m_self_; }$/;"	f	class:simpla::particle::ParticleProxy
self	core/particle/obsolete/probe_particle.h	/^    this_type &self()$/;"	f	struct:simpla::ProbeParticle
self	core/particle/obsolete/probe_particle.h	/^    this_type const &self() const$/;"	f	struct:simpla::ProbeParticle
self_	core/gtl/utilities/lua_object.h	/^    int self_;$/;"	m	class:simpla::lua::LuaObject
self_	core/parallel/obsoleted/blocked_range.h	/^	nTuple<index_type, ndims> self_, begin_, end_;$/;"	m	struct:simpla::iterator
send_buffer	core/parallel/DistributedObject.h	/^    std::vector<link_s> send_buffer;$/;"	m	struct:simpla::parallel::DistributedObject
send_buffer	core/parallel/obsoleted/distributed_unordered_set.h	/^		std::shared_ptr<value_type> send_buffer;$/;"	m	struct:simpla::Distributed::connection_node
send_range	core/parallel/obsoleted/distributed_unordered_set.h	/^		range_type send_range;$/;"	m	struct:simpla::Distributed::connection_node
send_size	core/parallel/obsoleted/distributed_unordered_set.h	/^		size_t send_size;$/;"	m	struct:simpla::Distributed::connection_node
seq2ntuple	core/gtl/ntuple.h	/^nTuple<TInts, sizeof...(N)> seq2ntuple(integer_sequence<TInts, N...>)$/;"	f	namespace:simpla::traits
seq_concat	core/gtl/type_traits.h	/^struct seq_concat<First, Others...>$/;"	s	namespace:simpla::traits
seq_concat	core/gtl/type_traits.h	/^struct seq_concat<First>$/;"	s	namespace:simpla::traits
seq_concat	core/gtl/type_traits.h	/^struct seq_concat<integer_sequence<_Tp, _M...>, integer_sequence<_Tp, _N...> >$/;"	s	namespace:simpla::traits
seq_for	core/gtl/integer_sequence.h	/^void seq_for(integer_sequence<size_t, N...>, Args &&... args)$/;"	f	namespace:simpla::mpl
seq_for	core/gtl/integer_sequence.h	/^void seq_for(integer_sequence<size_t, N>, Args &&... args)$/;"	f	namespace:simpla::mpl
seq_for_each	core/gtl/integer_sequence.h	/^void seq_for_each(integer_sequence<TInts, N...>, TOP const &op)$/;"	f	namespace:simpla::mpl
seq_get	core/gtl/integer_sequence.h	/^struct seq_get<0, integer_sequence<Tp, M, I ...> >$/;"	s	namespace:simpla::mpl
seq_get	core/gtl/integer_sequence.h	/^struct seq_get<0, integer_sequence<Tp> >$/;"	s	namespace:simpla::mpl
seq_get	core/gtl/integer_sequence.h	/^struct seq_get<N, integer_sequence<Tp, M, I ...> >$/;"	s	namespace:simpla::mpl
seq_max	core/gtl/integer_sequence.h	/^struct seq_max<>$/;"	s	namespace:simpla::mpl
seq_max	core/gtl/integer_sequence.h	/^struct seq_max<U, T...>$/;"	s	namespace:simpla::mpl
seq_max	core/gtl/integer_sequence.h	/^struct seq_max<U, T>$/;"	s	namespace:simpla::mpl
seq_max	core/gtl/integer_sequence.h	/^struct seq_max<U, void>$/;"	s	namespace:simpla::mpl
seq_max	core/gtl/integer_sequence.h	/^struct seq_max<U>$/;"	s	namespace:simpla::mpl
seq_max	core/gtl/integer_sequence.h	/^struct seq_max<integer_sequence<_Tp, N...>, integer_sequence<_Tp, M...>>$/;"	s	namespace:simpla::mpl
seq_min	core/gtl/integer_sequence.h	/^struct seq_min<>$/;"	s	namespace:simpla::mpl
seq_min	core/gtl/integer_sequence.h	/^struct seq_min<U, T...>$/;"	s	namespace:simpla::mpl
seq_min	core/gtl/integer_sequence.h	/^struct seq_min<U, void>$/;"	s	namespace:simpla::mpl
seq_min	core/gtl/integer_sequence.h	/^struct seq_min<U>$/;"	s	namespace:simpla::mpl
seq_print	core/gtl/integer_sequence.h	/^std::ostream &seq_print(integer_sequence<TInts, N...>, std::ostream &os, TA const &d)$/;"	f	namespace:simpla::mpl
seq_value	core/gtl/type_traits.h	/^struct seq_value<integer_sequence<_Tp, N...> >$/;"	s	namespace:simpla::traits
serial	core/parallel/ParallelDummy.h	/^namespace simpla { namespace serial$/;"	n	namespace:simpla
set	core/geometry/boost_gemetry_adapted.h	/^	static inline void set(sgm::Box<CS>& b, T const& value)$/;"	f	struct:boost::geometry::traits::indexed_access
set	core/geometry/boost_gemetry_adapted.h	/^	static inline void set(sgm::Primitive<N, CS, TAG>& b, T const& value)$/;"	f	struct:boost::geometry::traits::indexed_access
set	core/geometry/boost_gemetry_adapted.h	/^	static inline void set(sgm::Primitive<N, CS, TAG>& point, T const& value)$/;"	f	struct:boost::geometry::traits::access
set	core/gtl/Properties.h	/^    template<typename T> void set(std::string const &key, T const &v) { get(key) = v; }$/;"	f	class:simpla::Properties
set	core/gtl/ntuple.h	/^    static void set(nTuple<T, M...> &v, U const &u)$/;"	f	struct:simpla::traits::access
set	core/gtl/type_traits.h	/^    static void set(T &v, U const &u)$/;"	f	struct:simpla::traits::_impl::access_helper
set	core/gtl/type_traits.h	/^    static void set(T &v, U const &u)$/;"	f	struct:simpla::traits::access
set	core/gtl/type_traits.h	/^    static void set(T *v, U const &u)$/;"	f	struct:simpla::traits::access
set	core/gtl/type_traits.h	/^    static void set(std::pair<T0, T1> &v, U const &u)$/;"	f	struct:simpla::traits::access
set	core/gtl/type_traits.h	/^    static void set(std::tuple<T...> &v, U const &u)$/;"	f	struct:simpla::traits::access
set	core/gtl/utilities/lua_object.cpp	/^bool LuaObject::set(std::string const &key, Properties const &res) const$/;"	f	class:simpla::lua::LuaObject
set	core/gtl/utilities/lua_object.h	/^    inline void set(int s, T const &v)$/;"	f	class:simpla::lua::LuaObject
set	core/gtl/utilities/lua_object.h	/^    inline void set(std::string const &name, T const &v)$/;"	f	class:simpla::lua::LuaObject
set	core/manifold/mesh/GeneralMap.h	/^    template<typename ...Others> void set(Others &&...others) { }$/;"	f	struct:simpla::mesh::SquareMap
set	core/manifold/mesh/GeneralMap.h	/^    void set(TB0 const &src_box, TB1 const &dest_box, TD const &dims, Others &&...others)$/;"	f	struct:simpla::mesh::GeneralMap
set	core/manifold/mesh/LinearMap.h	/^    void set(TB0 const &src_box, TB1 const &dest_box, nTuple<size_t, 3> const &dims = {10, 10, 10})$/;"	f	struct:simpla::mesh::LinearMap
set	core/model/obsoleted/model.h	/^    void set(TR const &r, tag_type const &tag)$/;"	f	class:simpla::Model
set	core/model/obsoleted/model.h	/^    void set(id_type const &s, tag_type const &tag)$/;"	f	class:simpla::Model
set_attribute	core/io/HDF5Stream.cpp	/^void HDF5Stream::pimpl_s::set_attribute(hid_t loc_id, Properties const &prop)$/;"	f	class:simpla::io::HDF5Stream::pimpl_s
set_attribute	core/io/HDF5Stream.cpp	/^void HDF5Stream::pimpl_s::set_attribute(hid_t loc_id, std::string const &name,$/;"	f	class:simpla::io::HDF5Stream::pimpl_s
set_attribute	core/io/HDF5Stream.cpp	/^void HDF5Stream::set_attribute(std::string const &url, Properties const &any_v)$/;"	f	class:simpla::io::HDF5Stream
set_attribute	core/io/IOStream.h	/^    void set_attribute(std::string const &url, T const &v)$/;"	f	class:simpla::io::IOStream
set_attribute	core/io/IOStream.h	/^    void set_attribute(std::string const &url, char const str[])$/;"	f	class:simpla::io::IOStream
set_grid	core/manifold/policy/IOPolicy.h	/^    virtual void set_grid()$/;"	f	struct:simpla::manifold::policy::IOPolicy
set_line_width	core/gtl/utilities/log.cpp	/^    void set_line_width(int lineWidth)$/;"	f	struct:simpla::logger::LoggerStreams
set_mpi_comm	core/gtl/utilities/log.cpp	/^void set_mpi_comm(int r, int s)$/;"	f	namespace:simpla::logger
set_property	applications/particle_solver/fluid_cold_engine.h	/^	template<typename T> void set_property(std::string const & name, T const&v)$/;"	f	class:simpla::Particle
set_property_	applications/particle_solver/fluid_cold_engine.h	/^	void set_property_(std::string const & name, any const&v)$/;"	f	class:simpla::Particle
set_stdout_level	core/gtl/utilities/log.cpp	/^    inline void set_stdout_level(int l)$/;"	f	struct:simpla::logger::LoggerStreams
set_stdout_level	core/gtl/utilities/log.cpp	/^void set_stdout_level(int l)$/;"	f	namespace:simpla::logger
set_tags_	core/particle/ParticleGenerator.h	/^        void set_tags_(std::integral_constant<bool, false>, value_type *v) const { }$/;"	f	struct:simpla::particle::ParticleGenerator::input_iterator
set_tags_	core/particle/ParticleGenerator.h	/^        void set_tags_(std::integral_constant<bool, true>, value_type *v) const { v->_tag = m_count_; }$/;"	f	struct:simpla::particle::ParticleGenerator::input_iterator
set_topology_geometry	core/io/XDMFStream.cpp	/^void XDMFStream::set_topology_geometry(std::string const &name, data_model::DataSet const &ds)$/;"	f	class:simpla::io::XDMFStream
set_topology_geometry	core/io/XDMFStream.cpp	/^void XDMFStream::set_topology_geometry(std::string const &name, int ndims, size_t const *dims, Real const *xmin,$/;"	f	class:simpla::io::XDMFStream
setup	core/task_flow/task_flow_base.h	/^    virtual void setup(int argc, char **argv) { };$/;"	f	class:simpla::task_flow::ContextBase
shape	core/data_model/DataSpace.cpp	/^DataSpace::data_shape_s &DataSpace::shape()$/;"	f	class:simpla::data_model::DataSpace
shape	core/data_model/DataSpace.cpp	/^DataSpace::data_shape_s const &DataSpace::shape() const$/;"	f	class:simpla::data_model::DataSpace::DataSpace
shift_	core/gtl/iterator/iterator_cycle.h	/^	size_t shift_ = 0, length_ = 1;$/;"	m	struct:simpla::iterator_cycle
shift_	core/parallel/obsoleted/blocked_range.h	/^	id_type shift_ = 0UL;$/;"	m	struct:simpla::range
shift_	core/parallel/obsoleted/blocked_range.h	/^	id_type shift_;$/;"	m	struct:simpla::iterator
sigma_	applications/field_solver/pml.h	/^	inline Real sigma_(Real r, Real expN, Real dB)$/;"	f	class:simpla::PML
simpla	applications/contexts/context_cartesian.cpp	/^namespace simpla$/;"	n	file:
simpla	applications/contexts/context_cylindrical.cpp	/^namespace simpla$/;"	n	file:
simpla	applications/contexts/context_factory.h	/^namespace simpla$/;"	n
simpla	applications/contexts/explicit_em.h	/^namespace simpla$/;"	n
simpla	applications/field_solver/implicitPushE.h	/^namespace simpla$/;"	n
simpla	applications/field_solver/pml.h	/^namespace simpla$/;"	n
simpla	applications/particle_solver/fluid_cold_engine.h	/^namespace simpla$/;"	n
simpla	applications/particle_solver/pic_engine_deltaf.h	/^namespace simpla$/;"	n
simpla	applications/particle_solver/pic_engine_deltaf2.h	/^namespace simpla$/;"	n
simpla	applications/particle_solver/pic_engine_fullf.h	/^namespace simpla$/;"	n
simpla	applications/particle_solver/pic_engine_ggauge.h	/^namespace simpla$/;"	n
simpla	applications/particle_solver/pic_engine_implicit.h	/^namespace simpla$/;"	n
simpla	applications/particle_solver/register_particle.h	/^namespace simpla$/;"	n
simpla	core/base/Attribute.h	/^namespace simpla { namespace base$/;"	n
simpla	core/base/DataObject.cpp	/^namespace simpla { namespace base$/;"	n	file:
simpla	core/base/DataObject.h	/^namespace simpla { namespace base$/;"	n
simpla	core/base/LifeClick.h	/^namespace simpla { namespace base$/;"	n
simpla	core/base/Object.cpp	/^namespace simpla { namespace base$/;"	n	file:
simpla	core/base/Object.h	/^namespace simpla { namespace base$/;"	n
simpla	core/base/Patch.h	/^namespace simpla { namespace base$/;"	n
simpla	core/data_model/DataSet.cpp	/^namespace simpla { namespace data_model$/;"	n	file:
simpla	core/data_model/DataSet.h	/^namespace simpla { namespace data_model$/;"	n
simpla	core/data_model/DataSpace.cpp	/^namespace simpla { namespace data_model$/;"	n	file:
simpla	core/data_model/DataSpace.h	/^namespace simpla { namespace data_model$/;"	n
simpla	core/data_model/DataType.cpp	/^namespace simpla$/;"	n	file:
simpla	core/data_model/DataType.h	/^namespace simpla { namespace data_model$/;"	n
simpla	core/data_model/DataType.h	/^namespace simpla { namespace traits$/;"	n
simpla	core/data_model/DataTypeExt.h	/^namespace simpla$/;"	n
simpla	core/data_model/data_view.h	/^namespace simpla$/;"	n
simpla	core/field/FieldDense.h	/^namespace simpla$/;"	n
simpla	core/field/FieldExpression.h	/^namespace simpla {$/;"	n
simpla	core/field/FieldFunction.h	/^namespace simpla$/;"	n
simpla	core/field/FieldTraits.h	/^namespace simpla$/;"	n
simpla	core/field/obsoleted/field_comm.h	/^namespace simpla$/;"	n
simpla	core/field/obsoleted/field_constant.h	/^namespace simpla$/;"	n
simpla	core/field/obsoleted/field_constraint.h	/^namespace simpla$/;"	n
simpla	core/field/obsoleted/field_patch.h	/^namespace simpla$/;"	n
simpla	core/field/obsoleted/field_sparse.h	/^namespace simpla$/;"	n
simpla	core/field/obsoleted/load_field.h	/^namespace simpla$/;"	n
simpla	core/field/test/field_io_test.h	/^namespace simpla$/;"	n
simpla	core/field/test/trash/field_continue.h	/^namespace simpla$/;"	n
simpla	core/geometry/CoordinateSystem.h	/^namespace simpla { namespace geometry$/;"	n
simpla	core/geometry/GeoAlgorithm.h	/^namespace simpla$/;"	n
simpla	core/geometry/GeoObject.h	/^namespace simpla { namespace geometry$/;"	n
simpla	core/geometry/algorithm.h	/^namespace simpla {$/;"	n
simpla	core/geometry/boost_gemetry_adapted.h	/^namespace simpla$/;"	n
simpla	core/geometry/box.h	/^namespace simpla$/;"	n
simpla	core/geometry/chains.h	/^namespace simpla {$/;"	n
simpla	core/geometry/csCartesian.h	/^namespace simpla { namespace geometry$/;"	n
simpla	core/geometry/csCylindrical.h	/^namespace simpla$/;"	n
simpla	core/geometry/cube.h	/^namespace simpla$/;"	n
simpla	core/geometry/cut_cell.h	/^namespace simpla$/;"	n
simpla	core/geometry/geometry.h	/^namespace simpla { namespace geometry$/;"	n
simpla	core/geometry/implicit_function.h	/^namespace simpla$/;"	n
simpla	core/geometry/model.h	/^namespace simpla$/;"	n
simpla	core/geometry/obsolete/geometry_object.h	/^namespace simpla$/;"	n
simpla	core/geometry/obsolete/line_cliping.h	/^namespace simpla$/;"	n
simpla	core/geometry/obsolete/polygon.h	/^namespace simpla$/;"	n
simpla	core/geometry/obsolete/surface.h	/^namespace simpla$/;"	n
simpla	core/geometry/polygon.cpp	/^namespace simpla { namespace geometry$/;"	n	file:
simpla	core/geometry/polygon.h	/^namespace simpla { namespace geometry$/;"	n
simpla	core/geometry/primitive.h	/^namespace simpla { namespace geometry$/;"	n
simpla	core/geometry/primitive_ext.h	/^namespace simpla { namespace geometry$/;"	n
simpla	core/geometry/select.h	/^namespace simpla$/;"	n
simpla	core/geometry/simplex.h	/^namespace simpla$/;"	n
simpla	core/gtl/Properties.cpp	/^namespace simpla$/;"	n	file:
simpla	core/gtl/Properties.h	/^namespace simpla$/;"	n
simpla	core/gtl/any.h	/^namespace simpla$/;"	n
simpla	core/gtl/array_view.h	/^namespace simpla { namespace gtl$/;"	n
simpla	core/gtl/array_view.h	/^namespace simpla { namespace tags$/;"	n
simpla	core/gtl/cache.h	/^namespace simpla$/;"	n
simpla	core/gtl/check_concept.h	/^namespace simpla$/;"	n
simpla	core/gtl/complex.h	/^namespace simpla$/;"	n
simpla	core/gtl/concept_check.h	/^namespace simpla$/;"	n
simpla	core/gtl/containers/UnorderedSet.h	/^namespace simpla$/;"	n
simpla	core/gtl/containers/container_cache.h	/^namespace simpla$/;"	n
simpla	core/gtl/containers/container_container.h	/^namespace simpla$/;"	n
simpla	core/gtl/containers/container_dense.h	/^namespace simpla$/;"	n
simpla	core/gtl/containers/container_pool.h	/^namespace simpla$/;"	n
simpla	core/gtl/containers/container_save_cache.h	/^namespace simpla$/;"	n
simpla	core/gtl/containers/container_sparse.h	/^namespace simpla {$/;"	n
simpla	core/gtl/containers/container_traits.h	/^namespace simpla$/;"	n
simpla	core/gtl/containers/iterator_proxy.h	/^namespace simpla$/;"	n
simpla	core/gtl/containers/sp_hash_container.h	/^namespace simpla$/;"	n
simpla	core/gtl/containers/sp_indirect_container.h	/^namespace simpla$/;"	n
simpla	core/gtl/containers/sp_ndarray.h	/^namespace simpla$/;"	n
simpla	core/gtl/containers/unordered_set.h	/^namespace simpla$/;"	n
simpla	core/gtl/design_pattern/design_pattern.h	/^namespace simpla$/;"	n
simpla	core/gtl/design_pattern/factory.h	/^namespace simpla$/;"	n
simpla	core/gtl/design_pattern/observer.h	/^namespace simpla$/;"	n
simpla	core/gtl/design_pattern/signal.h	/^namespace simpla {$/;"	n
simpla	core/gtl/design_pattern/singleton_holder.h	/^namespace simpla$/;"	n
simpla	core/gtl/design_pattern/strategy.h	/^namespace simpla {$/;"	n
simpla	core/gtl/design_pattern/visitor.h	/^namespace simpla$/;"	n
simpla	core/gtl/enable_create_from_this.h	/^namespace simpla$/;"	n
simpla	core/gtl/expression_template.h	/^namespace simpla$/;"	n
simpla	core/gtl/function.h	/^namespace simpla$/;"	n
simpla	core/gtl/function_cache.h	/^namespace simpla$/;"	n
simpla	core/gtl/integer_sequence.h	/^namespace simpla$/;"	n
simpla	core/gtl/iterator/block_iterator.h	/^namespace simpla$/;"	n
simpla	core/gtl/iterator/indirect_iterator.h	/^namespace simpla$/;"	n
simpla	core/gtl/iterator/iterator.h	/^namespace simpla$/;"	n
simpla	core/gtl/iterator/iterator_cycle.h	/^namespace simpla$/;"	n
simpla	core/gtl/iterator/iterator_sequence.h	/^namespace simpla$/;"	n
simpla	core/gtl/iterator/range.h	/^namespace simpla$/;"	n
simpla	core/gtl/iterator/sp_indirect_iterator.h	/^namespace simpla {$/;"	n
simpla	core/gtl/iterator/sp_iterator.h	/^namespace simpla$/;"	n
simpla	core/gtl/iterator/sp_iterator_cached.h	/^namespace simpla$/;"	n
simpla	core/gtl/iterator/sp_iterator_cycle.h	/^namespace simpla$/;"	n
simpla	core/gtl/iterator/sp_iterator_filter.h	/^namespace simpla$/;"	n
simpla	core/gtl/iterator/sp_iterator_index_base.h	/^namespace simpla$/;"	n
simpla	core/gtl/iterator/sp_iterator_mapped.h	/^namespace simpla$/;"	n
simpla	core/gtl/iterator/sp_iterator_shared_container.h	/^namespace simpla$/;"	n
simpla	core/gtl/iterator/sp_ntuple_range.h	/^namespace simpla {$/;"	n
simpla	core/gtl/iterator/sp_range_filter.h	/^namespace simpla$/;"	n
simpla	core/gtl/mpl.h	/^namespace simpla$/;"	n
simpla	core/gtl/ntuple.h	/^namespace simpla$/;"	n
simpla	core/gtl/ntuple_ext.h	/^namespace simpla$/;"	n
simpla	core/gtl/optional.h	/^namespace simpla$/;"	n
simpla	core/gtl/primitives.h	/^namespace simpla$/;"	n
simpla	core/gtl/range/block_range.h	/^namespace simpla$/;"	n
simpla	core/gtl/sp_complex.h	/^namespace simpla$/;"	n
simpla	core/gtl/type_cast.h	/^namespace simpla$/;"	n
simpla	core/gtl/type_traits.h	/^namespace simpla$/;"	n
simpla	core/gtl/type_traits_ext.h	/^namespace simpla$/;"	n
simpla	core/gtl/utilities/config_parser.cpp	/^namespace simpla$/;"	n	file:
simpla	core/gtl/utilities/config_parser.h	/^namespace simpla$/;"	n
simpla	core/gtl/utilities/log.cpp	/^namespace simpla$/;"	n	file:
simpla	core/gtl/utilities/log.h	/^namespace simpla$/;"	n
simpla	core/gtl/utilities/logo.cpp	/^namespace simpla {$/;"	n	file:
simpla	core/gtl/utilities/logo.h	/^namespace simpla$/;"	n
simpla	core/gtl/utilities/lua_object.cpp	/^namespace simpla$/;"	n	file:
simpla	core/gtl/utilities/lua_object.h	/^namespace simpla { namespace lua$/;"	n
simpla	core/gtl/utilities/lua_object.h	/^namespace simpla$/;"	n
simpla	core/gtl/utilities/lua_object_ext.h	/^namespace simpla$/;"	n
simpla	core/gtl/utilities/memory_pool.cpp	/^namespace simpla$/;"	n	file:
simpla	core/gtl/utilities/memory_pool.h	/^namespace simpla$/;"	n
simpla	core/gtl/utilities/misc_utilities.h	/^namespace simpla$/;"	n
simpla	core/gtl/utilities/parse_command_line.cpp	/^namespace simpla$/;"	n	file:
simpla	core/gtl/utilities/parse_command_line.h	/^namespace simpla$/;"	n
simpla	core/gtl/utilities/parser_configure.h	/^namespace simpla$/;"	n
simpla	core/gtl/utilities/pretty_stream.h	/^namespace simpla$/;"	n
simpla	core/gtl/utilities/utilities.h	/^namespace simpla$/;"	n
simpla	core/io/HDF5Stream.cpp	/^namespace simpla { namespace io$/;"	n	file:
simpla	core/io/HDF5Stream.h	/^namespace simpla { namespace io$/;"	n
simpla	core/io/IO.cpp	/^namespace simpla { namespace io$/;"	n	file:
simpla	core/io/IO.h	/^namespace simpla { namespace io$/;"	n
simpla	core/io/IO.h	/^namespace simpla$/;"	n
simpla	core/io/IOExt.h	/^namespace simpla$/;"	n
simpla	core/io/IOStream.cpp	/^namespace simpla { namespace io$/;"	n	file:
simpla	core/io/IOStream.h	/^namespace simpla { namespace io$/;"	n
simpla	core/io/WriteBuffer.cpp	/^namespace simpla { namespace io$/;"	n	file:
simpla	core/io/WriteBuffer.h	/^namespace simpla { namespace io$/;"	n
simpla	core/io/XDMFIO.cpp	/^namespace simpla { namespace io$/;"	n	file:
simpla	core/io/XDMFIO.h	/^namespace simpla$/;"	n
simpla	core/io/XDMFStream.cpp	/^namespace simpla { namespace io$/;"	n	file:
simpla	core/io/XDMFStream.h	/^namespace simpla { namespace io$/;"	n
simpla	core/io/xdmf_stream_samr.h	/^namespace simpla { namespace io$/;"	n
simpla	core/io/xdmf_stream_samr.h	/^namespace simpla { template<typename ...> class Field; }$/;"	n
simpla	core/manifold/Calculus.h	/^namespace simpla$/;"	n
simpla	core/manifold/Manifold.h	/^namespace simpla$/;"	n
simpla	core/manifold/ManifoldTraits.h	/^namespace simpla$/;"	n
simpla	core/manifold/mesh/CartesianCoRect.h	/^namespace simpla { namespace mesh$/;"	n
simpla	core/manifold/mesh/CoRectMesh.h	/^namespace simpla { namespace mesh$/;"	n
simpla	core/manifold/mesh/CylindricalCoRect.h	/^namespace simpla { namespace mesh$/;"	n
simpla	core/manifold/mesh/GeneralMap.h	/^namespace simpla { namespace mesh$/;"	n
simpla	core/manifold/mesh/LinearMap.h	/^namespace simpla { namespace mesh$/;"	n
simpla	core/manifold/mesh/Mesh.h	/^namespace simpla { namespace geometry { namespace traits$/;"	n
simpla	core/manifold/mesh/Mesh.h	/^namespace simpla { namespace mesh$/;"	n
simpla	core/manifold/mesh/MeshBlock.cpp	/^namespace simpla { namespace mesh$/;"	n	file:
simpla	core/manifold/mesh/MeshBlock.h	/^namespace simpla { namespace mesh$/;"	n
simpla	core/manifold/mesh/MeshCommon.h	/^namespace simpla$/;"	n
simpla	core/manifold/mesh/MeshIds.h	/^namespace simpla { namespace mesh$/;"	n
simpla	core/manifold/mesh/RectMesh.h	/^namespace simpla { namespace mesh$/;"	n
simpla	core/manifold/obsoleted/amr_policy.h	/^namespace simpla { namespace manifold { namespace policy$/;"	n
simpla	core/manifold/obsoleted/amr_policy.h	/^namespace simpla { template<typename ...> class Field; }$/;"	n
simpla	core/manifold/obsoleted/block.h	/^namespace simpla$/;"	n
simpla	core/manifold/obsoleted/ebmesh.h	/^namespace simpla$/;"	n
simpla	core/manifold/obsoleted/embedded_policy.h	/^namespace simpla { namespace manifold { namespace policy$/;"	n
simpla	core/manifold/obsoleted/fiber_bundle.h	/^namespace simpla { namespace manifold$/;"	n
simpla	core/manifold/obsoleted/mesh_graph.h	/^namespace simpla { namespace mesh$/;"	n
simpla	core/manifold/obsoleted/mesh_layout.h	/^namespace simpla { namespace mesh$/;"	n
simpla	core/manifold/obsoleted/patch/mesh_patch.h	/^namespace simpla { namespace mesh$/;"	n
simpla	core/manifold/obsoleted/patch/mesh_patch.h	/^namespace simpla$/;"	n
simpla	core/manifold/obsoleted/samr_object.h	/^namespace simpla { namespace mesh$/;"	n
simpla	core/manifold/obsoleted/time_integrator_policy.h	/^namespace simpla { namespace manifold { namespace policy$/;"	n
simpla	core/manifold/obsoleted/time_integrator_policy.h	/^namespace simpla { namespace traits$/;"	n
simpla	core/manifold/policy/FvmStructuredPolicy.h	/^namespace simpla { namespace manifold { namespace policy$/;"	n
simpla	core/manifold/policy/FvmStructuredPolicy.h	/^namespace simpla$/;"	n
simpla	core/manifold/policy/IOPolicy.h	/^namespace simpla$/;"	n
simpla	core/manifold/policy/LinearInterpolatorPolicy.h	/^namespace simpla { namespace manifold { namespace policy$/;"	n
simpla	core/manifold/policy/ParallelPolicy.h	/^namespace simpla { namespace manifold { namespace policy$/;"	n
simpla	core/manifold/policy/StoragePolicy.h	/^namespace simpla$/;"	n
simpla	core/manifold/pre_define/PreDefine.h	/^namespace simpla { namespace manifold$/;"	n
simpla	core/manifold/pre_define/PreDefine.h	/^namespace simpla { namespace tags { struct function; }}$/;"	n
simpla	core/manifold/pre_define/PreDefine.h	/^namespace simpla { namespace traits$/;"	n
simpla	core/manifold/pre_define/mock.h	/^namespace simpla$/;"	n
simpla	core/manifold/pre_define/riemannian.h	/^namespace simpla$/;"	n
simpla	core/model/Constraint.h	/^namespace simpla { namespace model$/;"	n
simpla	core/model/GEqdsk.cpp	/^namespace simpla$/;"	n	file:
simpla	core/model/GEqdsk.h	/^namespace simpla$/;"	n
simpla	core/model/geqdsk_xdmf.cpp	/^namespace simpla$/;"	n	file:
simpla	core/model/obsoleted/mesh_snap.h	/^namespace simpla$/;"	n
simpla	core/model/obsoleted/model.cpp	/^namespace simpla$/;"	n	file:
simpla	core/model/obsoleted/model.h	/^namespace simpla$/;"	n
simpla	core/model/obsoleted/model_traits.h	/^namespace simpla$/;"	n
simpla	core/model/obsoleted/revolve_polygon.h	/^namespace simpla$/;"	n
simpla	core/model/obsoleted/select.h	/^namespace simpla$/;"	n
simpla	core/model/obsoleted/trans_revolve.h	/^namespace simpla$/;"	n
simpla	core/numeric/cholesky.h	/^namespace simpla$/;"	n
simpla	core/numeric/compound_distribution.h	/^namespace simpla$/;"	n
simpla	core/numeric/find_root.h	/^namespace simpla$/;"	n
simpla	core/numeric/half_split.h	/^namespace simpla$/;"	n
simpla	core/numeric/icdf_distribution.h	/^namespace simpla$/;"	n
simpla	core/numeric/integration.h	/^namespace simpla$/;"	n
simpla	core/numeric/interpolation.h	/^namespace simpla$/;"	n
simpla	core/numeric/inverse_function.h	/^namespace simpla$/;"	n
simpla	core/numeric/ksp_cg.h	/^namespace simpla$/;"	n
simpla	core/numeric/multi_normal_distribution.h	/^namespace simpla$/;"	n
simpla	core/numeric/normal_distribution_icdf.h	/^namespace simpla$/;"	n
simpla	core/numeric/rectangle_distribution.h	/^namespace simpla$/;"	n
simpla	core/numeric/simplex_distribution.h	/^namespace simpla$/;"	n
simpla	core/numeric/sobol_engine.h	/^namespace simpla$/;"	n
simpla	core/parallel/DistributedCounter.h	/^namespace simpla { namespace parallel$/;"	n
simpla	core/parallel/DistributedObject.cpp	/^namespace simpla { namespace parallel$/;"	n	file:
simpla	core/parallel/DistributedObject.h	/^namespace simpla { namespace data_model { class DataSet; }}$/;"	n
simpla	core/parallel/DistributedObject.h	/^namespace simpla { namespace parallel$/;"	n
simpla	core/parallel/MPIAuxFunctions.cpp	/^namespace simpla { namespace parallel$/;"	n	file:
simpla	core/parallel/MPIAuxFunctions.h	/^namespace simpla { namespace parallel$/;"	n
simpla	core/parallel/MPIComm.cpp	/^namespace simpla { namespace parallel$/;"	n	file:
simpla	core/parallel/MPIComm.h	/^namespace simpla { namespace parallel$/;"	n
simpla	core/parallel/MPIDataType.cpp	/^namespace simpla$/;"	n	file:
simpla	core/parallel/MPIDataType.h	/^namespace simpla$/;"	n
simpla	core/parallel/MPIUpdate.cpp	/^namespace simpla { namespace parallel$/;"	n	file:
simpla	core/parallel/MPIUpdate.h	/^namespace simpla { namespace parallel$/;"	n
simpla	core/parallel/Parallel.cpp	/^namespace simpla { namespace parallel$/;"	n	file:
simpla	core/parallel/Parallel.h	/^namespace simpla { namespace parallel$/;"	n
simpla	core/parallel/ParallelDummy.h	/^namespace simpla { namespace serial$/;"	n
simpla	core/parallel/ParallelRandomGenerator.h	/^namespace simpla { namespace parallel$/;"	n
simpla	core/parallel/ParallelTbb.h	/^namespace simpla { namespace parallel$/;"	n
simpla	core/parallel/concurrent_unordered_multiset.h	/^namespace simpla { namespace parallel$/;"	n
simpla	core/parallel/obsoleted/blocked_range.h	/^namespace simpla$/;"	n
simpla	core/parallel/obsoleted/distributed.h	/^namespace simpla$/;"	n
simpla	core/parallel/obsoleted/distributed_array.cpp	/^namespace simpla$/;"	n	file:
simpla	core/parallel/obsoleted/distributed_array.h	/^namespace simpla$/;"	n
simpla	core/parallel/obsoleted/distributed_comm.h	/^namespace simpla$/;"	n
simpla	core/parallel/obsoleted/distributed_unordered_set.h	/^namespace simpla$/;"	n
simpla	core/parallel/obsoleted/multi_thread_openmp.h	/^namespace simpla$/;"	n
simpla	core/parallel/obsoleted/multi_thread_std_thread.h	/^namespace simpla$/;"	n
simpla	core/parallel/obsoleted/multi_thread_tbb.h	/^namespace simpla$/;"	n
simpla	core/parallel/obsoleted/parallel_traits.h	/^namespace simpla$/;"	n
simpla	core/parallel/obsoleted/seq_range.h	/^namespace simpla$/;"	n
simpla	core/parallel/trash/distributed_unordered_set.cpp	/^namespace simpla$/;"	n	file:
simpla	core/particle/Particle.h	/^namespace simpla { namespace particle$/;"	n
simpla	core/particle/Particle.h	/^namespace simpla { template<typename ...> class Field; }$/;"	n
simpla	core/particle/ParticleConstraint.h	/^namespace simpla { namespace particle$/;"	n
simpla	core/particle/ParticleContainer.h	/^namespace simpla { namespace particle$/;"	n
simpla	core/particle/ParticleEngine.h	/^namespace simpla { namespace particle$/;"	n
simpla	core/particle/ParticleFactory.h	/^namespace simpla { namespace particle$/;"	n
simpla	core/particle/ParticleGenerator.h	/^namespace simpla { namespace particle$/;"	n
simpla	core/particle/ParticleProxy.h	/^namespace simpla { namespace particle$/;"	n
simpla	core/particle/ParticleTracker.h	/^namespace simpla { namespace particle$/;"	n
simpla	core/particle/obsolete/bc_absorb.h	/^namespace simpla$/;"	n
simpla	core/particle/obsolete/bc_cycle.h	/^namespace simpla {$/;"	n
simpla	core/particle/obsolete/bc_reflect.h	/^namespace simpla {$/;"	n
simpla	core/particle/obsolete/kinetic_particle.h	/^namespace simpla$/;"	n
simpla	core/particle/obsolete/load_particle.h	/^namespace simpla {$/;"	n
simpla	core/particle/obsolete/probe_particle.h	/^namespace simpla {$/;"	n
simpla	core/particle/obsolete/simple_particle.h	/^namespace simpla$/;"	n
simpla	core/particle/obsolete/sync_particle.h	/^namespace simpla {$/;"	n
simpla	core/particle/pre_define/GuidingCenter.h	/^namespace simpla { namespace particle { namespace engine$/;"	n
simpla	core/particle/pre_define/GuidingCenter.h	/^namespace simpla { namespace particle$/;"	n
simpla	core/particle/pre_define/PICBoris.h	/^namespace simpla { namespace particle { namespace engine$/;"	n
simpla	core/particle/pre_define/PICBoris.h	/^namespace simpla { namespace particle$/;"	n
simpla	core/particle/pre_define/PICGyro.h	/^namespace simpla { namespace particle { namespace engine$/;"	n
simpla	core/particle/pre_define/PICGyro.h	/^namespace simpla { namespace particle$/;"	n
simpla	core/particle/pre_define/SimpleParticleGenerator.h	/^namespace simpla$/;"	n
simpla	core/particle/test/particle_generator_test.cpp	/^namespace simpla$/;"	n	file:
simpla	core/phy_solver/em_fluid.h	/^namespace simpla { namespace phy_solver$/;"	n
simpla	core/physics/PhysicalConstants.cpp	/^namespace simpla$/;"	n	file:
simpla	core/physics/PhysicalConstants.h	/^namespace simpla$/;"	n
simpla	core/sp_config.h	/^namespace simpla$/;"	n
simpla	core/task_flow/application.cpp	/^namespace simpla$/;"	n	file:
simpla	core/task_flow/application.h	/^namespace simpla$/;"	n
simpla	core/task_flow/context.cpp	/^namespace simpla { namespace task_flow$/;"	n	file:
simpla	core/task_flow/context.h	/^namespace simpla { namespace task_flow$/;"	n
simpla	core/task_flow/context_base.h	/^namespace simpla$/;"	n
simpla	core/task_flow/task.cpp	/^namespace simpla { namespace task_flow { namespace _impl$/;"	n	file:
simpla	core/task_flow/task.h	/^namespace simpla { namespace task_flow$/;"	n
simpla	core/task_flow/task_flow_base.h	/^namespace simpla { namespace task_flow$/;"	n
simpla	core/task_flow/use_case.h	/^namespace simpla { namespace use_case$/;"	n
simpla	example/em_tokamak/tokamak.cpp	/^namespace simpla$/;"	n	file:
simpla	example/em_tokamak/tokamak.h	/^namespace simpla { namespace task_flow$/;"	n
simpla	example/model/demo_model.cpp	/^namespace simpla$/;"	n	file:
simpla	example/pic/collision_pic.h	/^namespace simpla$/;"	n
simpla	example/pic/demo_pic.h	/^namespace simpla$/;"	n
simpla	example/probe_particle/demo_probe_particle.h	/^namespace simpla$/;"	n
simplex_area	core/geometry/csCartesian.h	/^    static inline Real simplex_area(point_type const &p0, point_type const &p1, point_type const &p2)$/;"	f	struct:simpla::geometry::CartesianMetric
simplex_area	core/geometry/csCylindrical.h	/^    static Real simplex_area(point_type const &p0, point_type const &p1, point_type const &p2)$/;"	f	struct:simpla::geometry::Metric
simplex_distribution	core/numeric/simplex_distribution.h	/^	simplex_distribution(Args ... args) :$/;"	f	class:simpla::simplex_distribution
simplex_distribution	core/numeric/simplex_distribution.h	/^class simplex_distribution$/;"	c	namespace:simpla
simplex_length	core/geometry/csCartesian.h	/^    static inline Real simplex_length(point_type const &p0, point_type const &p1)$/;"	f	struct:simpla::geometry::CartesianMetric
simplex_length	core/geometry/csCylindrical.h	/^    static Real simplex_length(point_type const &p0, point_type const &p1)$/;"	f	struct:simpla::geometry::Metric
simplex_volume	core/geometry/csCartesian.h	/^    static inline Real simplex_volume(point_type const &p0, point_type const &p1, point_type const &p2,$/;"	f	struct:simpla::geometry::CartesianMetric
simplex_volume	core/geometry/csCylindrical.h	/^    static Real simplex_volume(point_type const &p0, point_type const &p1, point_type const &p2, point_type const &p3)$/;"	f	struct:simpla::geometry::Metric
sindq	applications/particle_solver/pic_engine_ggauge.h	/^	Real cosdq[NMATE], sindq[NMATE];$/;"	m	class:simpla::PICEngineGGauge
size	core/data_model/DataSpace.cpp	/^size_t DataSpace::size() const$/;"	f	class:simpla::data_model::DataSpace
size	core/data_model/DataType.cpp	/^size_t DataType::size() const$/;"	f	class:simpla::data_model::DataType
size	core/data_model/data_view.h	/^	size_t size() const { return m_index_range_.size(); }$/;"	f	struct:simpla::data_view
size	core/gtl/any.h	/^    virtual int size() const { return _size_of(m_value); };$/;"	f	struct:simpla::Derived
size	core/gtl/containers/container_container.h	/^	size_t size() const$/;"	f	class:simpla::ContainerContainer
size	core/gtl/containers/container_dense.h	/^	size_t size() const$/;"	f	class:simpla::DenseContainer
size	core/gtl/containers/container_sparse.h	/^    size_t size() const$/;"	f	class:simpla::SparseContainer
size	core/gtl/containers/sp_hash_container.h	/^	constexpr size_t size() const$/;"	f	struct:simpla::SpHashContainer
size	core/gtl/containers/sp_ndarray.h	/^	constexpr size_t size() const$/;"	f	class:simpla::ndArray
size	core/gtl/containers/unordered_set.h	/^    long size(key_type const &key) const$/;"	f	class:simpla::UnorderedSet
size	core/gtl/containers/unordered_set.h	/^    size_t size() const$/;"	f	class:simpla::UnorderedSet
size	core/gtl/design_pattern/factory.h	/^	size_t size() const$/;"	f	struct:simpla::Factory
size	core/gtl/iterator/range.h	/^    size_type size() const { return (m_end_ - m_begin_); };$/;"	f	class:simpla::Range
size	core/gtl/iterator/sp_ntuple_range.h	/^    size_t size() const$/;"	f	struct:simpla::sp_nTuple_range
size	core/gtl/range/block_range.h	/^    size_type size() const { return traits::distance(m_begin_, m_end_); };$/;"	f	class:simpla::BlockRange
size	core/gtl/type_traits.h	/^    static constexpr int size()$/;"	f	struct:simpla::integer_sequence
size	core/gtl/utilities/lua_object.cpp	/^size_t LuaObject::size() const$/;"	f	class:simpla::lua::LuaObject
size	core/gtl/utilities/memory_pool.cpp	/^double MemoryPool::size() const$/;"	f	class:simpla::MemoryPool
size	core/manifold/mesh/MeshIds.h	/^        size_t size() const$/;"	f	struct:simpla::mesh::MeshEntityIdCoder::range_type
size	core/parallel/MPIDataType.cpp	/^size_t MPIDataType::size() const$/;"	f	class:simpla::MPIDataType
size	core/parallel/obsoleted/blocked_range.h	/^	int size() const$/;"	f	struct:simpla::BlockedRange
size	core/particle/Particle.h	/^    virtual size_t size() const { return m_data_->count(); }$/;"	f	struct:simpla::particle::Particle
size	core/particle/ParticleProxy.h	/^    virtual size_t size() const { return m_self_->size(); }$/;"	f	class:simpla::particle::ParticleProxy
size_all	core/gtl/containers/unordered_set.h	/^    size_t size_all(TRange const &range) const$/;"	f	class:simpla::UnorderedSet
size_in_byte	core/data_model/DataType.cpp	/^size_t DataType::size_in_byte() const$/;"	f	class:simpla::data_model::DataType
size_of_range	core/gtl/utilities/misc_utilities.h	/^template<typename TR> size_t size_of_range(TR const &range)$/;"	f	namespace:simpla
size_type	core/gtl/array_view.h	/^    typedef size_t size_type;$/;"	t	struct:simpla::gtl::ArrayViewBase
size_type	core/gtl/iterator/range.h	/^    typedef size_t size_type;$/;"	t	class:simpla::Range
size_type	core/gtl/range/block_range.h	/^    typedef size_t size_type;$/;"	t	class:simpla::BlockRange
size_type	core/parallel/obsoleted/blocked_range.h	/^	typedef size_t size_type;$/;"	t	struct:simpla::BlockedRange
slen	core/geometry/obsolete/polygons.h	172;"	d
slice	core/data_model/data_view.h	/^	this_type slice(Args &&...args)$/;"	f	struct:simpla::data_view
snap	core/model/obsoleted/mesh_snap.h	/^void snap(TGeo const &geo )$/;"	f	namespace:simpla
sobol_engine	core/numeric/sobol_engine.h	/^	sobol_engine() :$/;"	f	class:simpla::sobol_engine
sobol_engine	core/numeric/sobol_engine.h	/^class sobol_engine$/;"	c	namespace:simpla
sp_alloc_array	core/gtl/utilities/memory_pool.h	/^std::shared_ptr<T> sp_alloc_array(size_t s)$/;"	f	namespace:simpla
sp_alloc_memory	core/gtl/utilities/memory_pool.cpp	/^std::shared_ptr<void> sp_alloc_memory(size_t s)$/;"	f	namespace:simpla
sp_back_insert_iterator	core/gtl/iterator/sp_iterator.h	/^	explicit sp_back_insert_iterator(container_type p)$/;"	f	class:simpla::sp_back_insert_iterator
sp_back_insert_iterator	core/gtl/iterator/sp_iterator.h	/^class sp_back_insert_iterator<T*> : public std::iterator<$/;"	c	namespace:simpla
sp_fliter_iterator	core/gtl/iterator/sp_iterator_filter.h	/^	sp_fliter_iterator()$/;"	f	struct:simpla::sp_fliter_iterator
sp_fliter_iterator	core/gtl/iterator/sp_iterator_filter.h	/^	sp_fliter_iterator(base_iterator first, base_iterator last,$/;"	f	struct:simpla::sp_fliter_iterator
sp_fliter_iterator	core/gtl/iterator/sp_iterator_filter.h	/^	sp_fliter_iterator(this_type const & other)$/;"	f	struct:simpla::sp_fliter_iterator
sp_fliter_iterator	core/gtl/iterator/sp_iterator_filter.h	/^struct sp_fliter_iterator: public BaseIterator$/;"	s	namespace:simpla
sp_indirect_iterator	core/gtl/iterator/sp_indirect_iterator.h	/^    sp_indirect_iterator(base_iterator_type const &base_it)$/;"	f	struct:simpla::sp_indirect_iterator
sp_indirect_iterator	core/gtl/iterator/sp_indirect_iterator.h	/^    sp_indirect_iterator(base_iterator_type const &base_it,$/;"	f	struct:simpla::sp_indirect_iterator
sp_indirect_iterator	core/gtl/iterator/sp_indirect_iterator.h	/^    sp_indirect_iterator(this_type const &other) :$/;"	f	struct:simpla::sp_indirect_iterator
sp_indirect_iterator	core/gtl/iterator/sp_indirect_iterator.h	/^struct sp_indirect_iterator : public BaseIterator$/;"	s	namespace:simpla
sp_indirect_range	core/gtl/iterator/sp_indirect_iterator.h	/^    sp_indirect_range(key_range_type &&key_range,$/;"	f	struct:simpla::sp_indirect_range
sp_indirect_range	core/gtl/iterator/sp_indirect_iterator.h	/^    sp_indirect_range(sp_indirect_range &other, Others &&...others) :$/;"	f	struct:simpla::sp_indirect_range
sp_indirect_range	core/gtl/iterator/sp_indirect_iterator.h	/^    sp_indirect_range(sp_indirect_range const &other) :$/;"	f	struct:simpla::sp_indirect_range
sp_indirect_range	core/gtl/iterator/sp_indirect_iterator.h	/^struct sp_indirect_range$/;"	s	namespace:simpla
sp_max	core/gtl/type_traits_ext.h	/^struct sp_max$/;"	s	namespace:simpla
sp_min	core/gtl/type_traits_ext.h	/^struct sp_min$/;"	s	namespace:simpla
sp_nTuple_range	core/gtl/iterator/sp_ntuple_range.h	/^    sp_nTuple_range()$/;"	f	struct:simpla::sp_nTuple_range
sp_nTuple_range	core/gtl/iterator/sp_ntuple_range.h	/^    sp_nTuple_range(T1 const &min, T2 const &max, T3 const &grain_size,$/;"	f	struct:simpla::sp_nTuple_range
sp_nTuple_range	core/gtl/iterator/sp_ntuple_range.h	/^    sp_nTuple_range(T1 const &min, T2 const &max, bool slow_first = true) :$/;"	f	struct:simpla::sp_nTuple_range
sp_nTuple_range	core/gtl/iterator/sp_ntuple_range.h	/^    sp_nTuple_range(this_type const &other) :$/;"	f	struct:simpla::sp_nTuple_range
sp_nTuple_range	core/gtl/iterator/sp_ntuple_range.h	/^struct sp_nTuple_range$/;"	s	namespace:simpla
sp_swap	core/gtl/type_traits_ext.h	/^		!has_member_function_swap<T>::value, void>::type sp_swap(T& l, T& r)$/;"	f	namespace:simpla
sp_swap	core/gtl/type_traits_ext.h	/^		void>::type sp_swap(T& l, T& r)$/;"	f	namespace:simpla
spatial_domain_type	core/field/FieldFunction.h	/^    typedef typename mesh_type::box_type spatial_domain_type;$/;"	t	class:simpla::Field
sphere	core/geometry/obsolete/geometry_object.h	/^ImplicitFunction<Sphere> sphere(Args && ...args)$/;"	f	namespace:simpla::geometry_object
splice	core/gtl/containers/unordered_set.h	/^    void splice(BucketInputIter first, BucketInputIter last)$/;"	f	class:simpla::UnorderedSet
splice	core/gtl/containers/unordered_set.h	/^    void splice(TRange const &range, this_type &other)$/;"	f	class:simpla::UnorderedSet
split	core/parallel/ParallelDummy.h	/^struct split$/;"	s	namespace:simpla::serial::tags
split	core/task_flow/task_flow_base.h	/^    virtual void split(ContextBase &) { }$/;"	f	class:simpla::task_flow::ContextBase
split_tuple	core/gtl/mpl.h	/^struct split_tuple<0, T0, T...>$/;"	s	namespace:simpla::mpl
split_tuple	core/gtl/mpl.h	/^struct split_tuple<I, T0, T...>$/;"	s	namespace:simpla::mpl
split_tuple	core/gtl/mpl.h	/^struct split_tuple<I>$/;"	s	namespace:simpla::mpl
src_iterator	core/gtl/iterator/indirect_iterator.h	/^	typedef TSIterator src_iterator;$/;"	t	struct:simpla::indirect_iterator
start	core/gtl/utilities/log.h	/^inline Logger &start(Logger &self)$/;"	f	namespace:simpla::logger
startC	core/geometry/obsolete/line_cliping.h	/^	size_t startC; \/* code for start point *\/$/;"	m	class:simpla::polygon_clip
startC0	core/geometry/obsolete/line_cliping.h	/^	size_t startC0;\/* saves startC for next call to CS_EndClip *\/$/;"	m	class:simpla::polygon_clip
startPt	core/geometry/obsolete/line_cliping.h	/^	pnt2d startPt; \/* start point of segment *\/$/;"	m	class:simpla::polygon_clip
std	core/geometry/primitive.h	/^namespace std$/;"	n
std	core/gtl/complex.h	/^namespace std$/;"	n
std	core/gtl/iterator/iterator.h	/^namespace std$/;"	n
std	core/gtl/iterator/sp_iterator_shared_container.h	/^namespace std$/;"	n
std	core/gtl/ntuple.h	/^namespace std$/;"	n
std	core/gtl/sp_complex.h	/^namespace std$/;"	n
std	core/gtl/utilities/pretty_stream.h	/^namespace std$/;"	n
step_counter_	core/particle/obsolete/probe_particle.h	/^    size_t step_counter_ = 0;$/;"	m	struct:simpla::ProbeParticle
storage_policy	core/manifold/obsoleted/embedded_policy.h	/^    typedef this_type storage_policy;$/;"	t	struct:simpla::manifold::policy::EmbeddedPolicy
storage_policy	core/manifold/policy/StoragePolicy.h	/^    typedef this_type storage_policy;$/;"	t	struct:simpla::manifold::policy::StoragePolicy
storage_type	core/gtl/iterator/sp_iterator_mapped.h	/^			conatiner_type>::type storage_type;$/;"	t	struct:simpla::Iterator
storage_type	core/gtl/iterator/sp_iterator_mapped.h	/^	typedef typename std::conditional<IsReference, conatiner_type&, conatiner_type >::type storage_type;$/;"	t	struct:simpla::Iterator
storage_type	core/gtl/iterator/sp_iterator_shared_container.h	/^	typedef StorageContainerPolicy<container_type> storage_type;$/;"	t	class:simpla::TransformIterator
storage_value_type	applications/particle_solver/pic_engine_deltaf2.h	/^	typedef nTuple<8, Real> storage_value_type;$/;"	t	struct:simpla::PICEngineDeltaF
storage_value_type	applications/particle_solver/pic_engine_ggauge.h	/^	typedef nTuple<7 + NMATE, Real> storage_value_type;$/;"	t	class:simpla::PICEngineGGauge
string	core/gtl/any.h	/^    std::string string() const$/;"	f	struct:simpla::any
sub_index	core/manifold/mesh/MeshIds.h	/^    static constexpr int sub_index(id_type const &s)$/;"	f	struct:simpla::mesh::MeshEntityIdCoder
sub_index_to_id	core/manifold/mesh/MeshIds.h	/^    static constexpr int sub_index_to_id(int n = 0)$/;"	f	struct:simpla::mesh::MeshEntityIdCoder
sub_type	core/gtl/ntuple.h	/^            nTuple<value_type, M...>>::type sub_type;$/;"	t	struct:simpla::nTuple
sub_type	core/gtl/ntuple.h	/^    typedef void sub_type;$/;"	t	struct:simpla::nTuple
sub_version	applications/fokker_planck/lhw.cpp	/^static const char sub_version[] = __FILE__ "(version: 0.0.1)";$/;"	v	file:
surffix	core/gtl/utilities/log.cpp	/^void Logger::surffix(std::string const &s)$/;"	f	class:simpla::logger::Logger
swap	core/base/Attribute.h	/^    void swap(Attribute &other)$/;"	f	class:simpla::base::Attribute
swap	core/base/Attribute.h	/^    void swap(AttributeObject &other)$/;"	f	class:simpla::base::AttributeObject
swap	core/base/Attribute.h	/^    void swap(this_type &other)$/;"	f	class:simpla::base::AttributeEntity
swap	core/base/Object.cpp	/^void Object::swap(Object &other) { std::swap(m_click_, other.m_click_); };$/;"	f	class:simpla::base::Object
swap	core/data_model/DataSet.h	/^    void swap(DataSet &other)$/;"	f	struct:simpla::data_model::DataSet
swap	core/data_model/DataSpace.cpp	/^void DataSpace::swap(DataSpace &other)$/;"	f	class:simpla::data_model::DataSpace
swap	core/data_model/DataType.cpp	/^void DataType::swap(DataType &other)$/;"	f	class:simpla::data_model::DataType
swap	core/data_model/data_view.h	/^	void swap(this_type &other)$/;"	f	struct:simpla::data_view
swap	core/field/FieldDense.h	/^    void swap(this_type &other) { std::swap(m_data_, other.m_data_); }$/;"	f	class:simpla::Field
swap	core/field/obsoleted/field_constant.h	/^	void swap(this_type &other)$/;"	f	class:simpla::Field
swap	core/gtl/Properties.h	/^    void swap(this_type &other)$/;"	f	class:simpla::Properties
swap	core/gtl/any.h	/^    void swap(any &other) { std::swap(ptr_, other.ptr_); }$/;"	f	struct:simpla::any
swap	core/gtl/array_view.h	/^    void swap(iterator &other)$/;"	f	struct:simpla::gtl::ArrayView::iterator
swap	core/gtl/containers/container_dense.h	/^	void swap(this_type & rhs)$/;"	f	class:simpla::DenseContainer
swap	core/gtl/containers/container_sparse.h	/^    void swap(this_type &rhs)$/;"	f	class:simpla::SparseContainer
swap	core/gtl/containers/sp_hash_container.h	/^	void swap(this_type & other)$/;"	f	struct:simpla::SpHashContainer
swap	core/gtl/containers/sp_ndarray.h	/^	void swap(this_type & other)$/;"	f	class:simpla::ndArray
swap	core/gtl/containers/unordered_set.h	/^    void swap(this_type &other)$/;"	f	class:simpla::UnorderedSet
swap	core/gtl/iterator/block_iterator.h	/^    void swap(this_type &other)$/;"	f	struct:simpla::block_iterator
swap	core/gtl/iterator/range.h	/^    void swap(this_type &other)$/;"	f	class:simpla::Range
swap	core/gtl/iterator/sp_iterator_cycle.h	/^	void swap(this_type & other)$/;"	f	struct:simpla::CycleIterator
swap	core/gtl/iterator/sp_ntuple_range.h	/^    void swap(iterator &other)$/;"	f	struct:simpla::sp_nTuple_range::iterator
swap	core/gtl/iterator/sp_ntuple_range.h	/^    void swap(this_type &other)$/;"	f	struct:simpla::sp_nTuple_range
swap	core/gtl/ntuple.h	/^void swap(simpla::nTuple<T, N, M...> &l, simpla::nTuple<T, N, M...> &r)$/;"	f	namespace:std
swap	core/gtl/ntuple.h	/^void swap(simpla::nTuple<T, N, M...> &l,$/;"	f	namespace:std
swap	core/gtl/type_traits.h	/^void swap(T &l, T &r)$/;"	f	namespace:simpla::traits
swap	core/gtl/utilities/config_parser.h	/^        void swap(DictObject &other)$/;"	f	struct:simpla::ConfigParser::DictObject
swap	core/gtl/utilities/lua_object.cpp	/^void LuaObject::swap(LuaObject &other)$/;"	f	class:simpla::lua::LuaObject
swap	core/manifold/mesh/GeneralMap.h	/^    void swap(this_type &other) { }$/;"	f	struct:simpla::mesh::SquareMap
swap	core/manifold/mesh/GeneralMap.h	/^    void swap(this_type &other)$/;"	f	struct:simpla::mesh::GeneralMap
swap	core/manifold/mesh/LinearMap.h	/^    void swap(this_type &other)$/;"	f	struct:simpla::mesh::LinearMap
swap	core/manifold/mesh/MeshIds.h	/^        void swap(iterator &other)$/;"	f	struct:simpla::mesh::MeshEntityIdCoder::iterator
swap	core/manifold/mesh/MeshIds.h	/^        void swap(this_type &other)$/;"	f	struct:simpla::mesh::MeshEntityIdCoder::range_type
swap	core/manifold/obsoleted/fiber_bundle.h	/^    void swap(this_type &other)$/;"	f	class:simpla::manifold::FiberBundle
swap	core/numeric/interpolation.h	/^    virtual void swap(this_type &r)$/;"	f	class:simpla::MultiDimesionInterpolation
swap	core/numeric/interpolation.h	/^    void swap(this_type &r)$/;"	f	class:simpla::BiLinearInterpolation
swap	core/numeric/interpolation.h	/^    void swap(this_type &r)$/;"	f	class:simpla::Interpolation
swap	core/numeric/interpolation.h	/^    void swap(this_type &r)$/;"	f	struct:simpla::LinearInterpolation
swap	core/parallel/MPIDataType.cpp	/^void MPIDataType::swap(MPIDataType &other)$/;"	f	class:simpla::MPIDataType
swap	core/parallel/obsoleted/blocked_range.h	/^	void swap(this_type & other)$/;"	f	struct:simpla::BlockedRange
swap	core/parallel/obsoleted/distributed.h	/^	virtual void swap(this_type &other)$/;"	f	class:simpla::Distributed
swap	core/parallel/obsoleted/distributed_unordered_set.h	/^	void swap(this_type &other) { base_type::swap(other) };$/;"	f	struct:simpla::Distributed
swap	core/particle/Particle.h	/^    void swap(this_type const &other) { std::swap(other.m_data_, m_data_); }$/;"	f	struct:simpla::particle::Particle
swap	example/pic/demo_pic.h	/^	void swap(this_type &other)$/;"	f	struct:simpla::FiberBundle
sync	core/base/Attribute.h	/^    virtual void sync()$/;"	f	class:simpla::base::Attribute
sync	core/field/FieldDense.h	/^    void sync() { data()->sync(); }$/;"	f	class:simpla::Field
sync	core/manifold/policy/ParallelPolicy.h	/^ParallelPolicy<TMesh>::sync(T &self) const$/;"	f	class:simpla::manifold::policy::ParallelPolicy
sync	core/manifold/policy/ParallelPolicy.h	/^ParallelPolicy<TMesh>::sync(data_model::DataSet &ds) const$/;"	f	class:simpla::manifold::policy::ParallelPolicy
sync	core/parallel/DistributedObject.cpp	/^void DistributedObject::sync()$/;"	f	class:simpla::parallel::DistributedObject
sync	core/parallel/Parallel.h	/^void sync(Args &&...args)$/;"	f	namespace:simpla::parallel
sync	core/parallel/obsoleted/distributed_unordered_set.h	/^void Distributed<UnorderedSet<TV, Others...>>::sync()$/;"	f	class:simpla::Distributed
sync	core/parallel/obsoleted/parallel_traits.h	/^template<typename ...T> void sync(T &&...) { }$/;"	f	namespace:simpla::parallel
sync	core/parallel/trash/distributed_unordered_set.cpp	/^void DistributedUnorderedSetBase::sync()$/;"	f	class:simpla::DistributedUnorderedSetBase
sync	core/particle/Particle.h	/^    virtual void sync() {\/* m_data_->sync();*\/ }$/;"	f	struct:simpla::particle::Particle
sync	core/particle/ParticleContainer.h	/^ParticleContainer<P, M>::sync() { rehash(); };$/;"	f	class:simpla::particle::ParticleContainer
sync	core/particle/ParticleProxy.h	/^    virtual void sync() { m_self_->sync(); }$/;"	f	class:simpla::particle::ParticleProxy
sync	core/particle/obsolete/kinetic_particle.h	/^void KineticParticle<Engine, TDomain>::sync()$/;"	f	class:KineticParticle
sync	core/particle/obsolete/probe_particle.h	/^void ProbeParticle<Engine>::sync()$/;"	f	class:simpla::ProbeParticle
sync	core/particle/obsolete/sync_particle.h	/^void sync(Particle<Args...> *pool)$/;"	f	namespace:simpla
sync_	core/particle/ParticleContainer.h	/^ParticleContainer<P, M>::sync_(container_type const &buffer, parallel::DistributedObject *dist_obj,$/;"	f	class:simpla::particle::ParticleContainer
sync_global_location	core/parallel/MPIUpdate.cpp	/^std::tuple<int, int> sync_global_location(MPIComm &mpi_comm, int count)$/;"	f	namespace:simpla::parallel
sync_patch	core/manifold/obsoleted/amr_policy.h	/^    virtual void sync_patch() const { \/** TODO sync patches *\/};$/;"	f	class:simpla::manifold::policy::AMR
tag	core/geometry/boost_gemetry_adapted.h	/^struct tag<sgm::Box<CS>>$/;"	s	namespace:boost::geometry::traits
tag	core/geometry/boost_gemetry_adapted.h	/^struct tag<sgm::Polygon<CS> >$/;"	s	namespace:boost::geometry::traits
tag	core/geometry/boost_gemetry_adapted.h	/^struct tag<sgm::Polyline<CS, Others ...> >$/;"	s	namespace:boost::geometry::traits
tag	core/geometry/boost_gemetry_adapted.h	/^struct tag<sgm::Primitive<0, CS, TAG> >$/;"	s	namespace:boost::geometry::traits
tag	core/geometry/boost_gemetry_adapted.h	/^struct tag<sgm::Primitive<1, CS, TAG> >$/;"	s	namespace:boost::geometry::traits
tag	core/geometry/primitive.h	/^struct tag<model::Primitive<Dimension, CoordinateSystem, Tag>>$/;"	s	namespace:simpla::geometry::traits
tag	core/parallel/obsoleted/distributed_comm.h	/^	int tag;$/;"	m	struct:simpla::parallel::link_node
tag_boundary	core/model/obsoleted/model_traits.h	/^	tag_inside = 1, tag_outside = 2, tag_boundary = 4$/;"	e	enum:simpla::tags::__anon8
tag_inside	core/model/obsoleted/model_traits.h	/^	tag_inside = 1, tag_outside = 2, tag_boundary = 4$/;"	e	enum:simpla::tags::__anon8
tag_outside	core/model/obsoleted/model_traits.h	/^	tag_inside = 1, tag_outside = 2, tag_boundary = 4$/;"	e	enum:simpla::tags::__anon8
tag_type	core/geometry/chains.h	/^    typedef typename traits::tag<primitive_type>::type tag_type;$/;"	t	struct:simpla::geometry::model::Chains
tag_type	core/model/obsoleted/model.h	/^    typedef std::uint64_t tag_type;$/;"	t	class:simpla::Model
tags	core/data_model/data_view.h	/^namespace tags$/;"	n	namespace:simpla
tags	core/field/FieldFunction.h	/^namespace tags { struct function; }$/;"	n	namespace:simpla
tags	core/field/obsoleted/field_comm.h	/^namespace tags$/;"	n	namespace:simpla
tags	core/geometry/chains.h	/^namespace tags {$/;"	n	namespace:simpla::geometry
tags	core/geometry/cube.h	/^namespace tags$/;"	n	namespace:simpla::geometry
tags	core/geometry/primitive.h	/^namespace tags$/;"	n	namespace:simpla::geometry
tags	core/geometry/primitive_ext.h	/^namespace tags$/;"	n	namespace:simpla::geometry
tags	core/geometry/simplex.h	/^namespace tags$/;"	n	namespace:simpla::geometry
tags	core/gtl/array_view.h	/^namespace simpla { namespace tags$/;"	n	namespace:simpla
tags	core/gtl/type_traits.h	/^namespace tags$/;"	n	namespace:simpla
tags	core/gtl/utilities/log.h	/^enum tags$/;"	g	namespace:simpla::logger
tags	core/manifold/Calculus.h	/^namespace tags$/;"	n	namespace:simpla::calculus
tags	core/manifold/mesh/CoRectMesh.h	/^namespace tags { struct corect_linear; }$/;"	n	namespace:simpla::mesh
tags	core/manifold/mesh/MeshCommon.h	/^namespace tags$/;"	n	namespace:simpla::topology
tags	core/manifold/mesh/RectMesh.h	/^namespace tags { struct rect_linear; }$/;"	n	namespace:simpla::mesh
tags	core/manifold/obsoleted/ebmesh.h	/^namespace tags { struct embedded; }$/;"	n	namespace:simpla
tags	core/manifold/pre_define/PreDefine.h	/^namespace simpla { namespace tags { struct function; }}$/;"	n	namespace:simpla
tags	core/model/obsoleted/model_traits.h	/^namespace tags$/;"	n	namespace:simpla
tags	core/parallel/ParallelDummy.h	/^namespace tags$/;"	n	namespace:simpla::serial
tags	core/parallel/ParallelTbb.h	/^namespace tags$/;"	n	namespace:simpla::parallel
tail_	core/gtl/containers/container_pool.h	/^	size_t tail_ = 0;$/;"	m	struct:simpla::ContainerPool
tail_	core/gtl/containers/container_save_cache.h	/^	size_t tail_;$/;"	m	class:simpla::ContainerSaveCache
task_flow	core/task_flow/context.cpp	/^namespace simpla { namespace task_flow$/;"	n	namespace:simpla	file:
task_flow	core/task_flow/context.h	/^namespace simpla { namespace task_flow$/;"	n	namespace:simpla
task_flow	core/task_flow/task.cpp	/^namespace simpla { namespace task_flow { namespace _impl$/;"	n	namespace:simpla	file:
task_flow	core/task_flow/task.h	/^namespace simpla { namespace task_flow$/;"	n	namespace:simpla
task_flow	core/task_flow/task_flow_base.h	/^namespace simpla { namespace task_flow$/;"	n	namespace:simpla
task_flow	example/em_tokamak/tokamak.h	/^namespace simpla { namespace task_flow$/;"	n	namespace:simpla
task_type	core/task_flow/task.h	/^    typedef Task<context_type> task_type;$/;"	t	struct:simpla::task_flow::_impl::TaskRegistry
tear_down	core/phy_solver/em_fluid.h	/^void EMFluid<TM>::tear_down()$/;"	f	class:simpla::phy_solver::EMFluid
tear_down	core/task_flow/task_flow_base.h	/^    virtual void tear_down() { };$/;"	f	class:simpla::task_flow::ContextBase
tear_down	example/em_tokamak/tokamak.cpp	/^void EMTokamak::tear_down()$/;"	f	class:simpla::EMTokamak
teardown	core/task_flow/use_case.h	/^    virtual void teardown() { };$/;"	f	class:simpla::use_case::UseCase
temperature	core/particle/ParticleGenerator.h	/^    template<typename TFun> void temperature(TFun const &fun) { m_temperature_ = fun; }$/;"	f	class:simpla::particle::ParticleGeneratorPerCell
this_type	applications/contexts/explicit_em.h	/^    typedef ExplicitEMContext<mesh_type> this_type;$/;"	t	struct:simpla::ExplicitEMContext
this_type	applications/fokker_planck/lhw.cpp	/^	typedef PICDeltaF this_type;$/;"	t	struct:PICDeltaF	file:
this_type	applications/particle_solver/fluid_cold_engine.h	/^	typedef Particle<mesh_type, engine_type, PolicyFluidParticle> this_type;$/;"	t	class:simpla::Particle
this_type	applications/particle_solver/pic_engine_deltaf.h	/^	typedef ParticleEngine<PolicyPICDeltaF> this_type;$/;"	t	struct:simpla::ParticleEngine
this_type	applications/particle_solver/pic_engine_deltaf2.h	/^	typedef PICEngineDeltaF<TM, TS> this_type;$/;"	t	struct:simpla::PICEngineDeltaF
this_type	applications/particle_solver/pic_engine_fullf.h	/^	typedef PICEngineFullF this_type;$/;"	t	class:simpla::PICEngineFullF
this_type	applications/particle_solver/pic_engine_ggauge.h	/^	typedef PICEngineGGauge<TM, NMATE, IMPLICIT, Interpolator> this_type;$/;"	t	class:simpla::PICEngineGGauge
this_type	applications/particle_solver/pic_engine_implicit.h	/^	typedef PICEngineImplicit<mesh_type, interpolator_type> this_type;$/;"	t	struct:simpla::PICEngineImplicit
this_type	core/base/Attribute.h	/^    typedef Attribute<TV, IFORM, TMesh> this_type;$/;"	t	class:simpla::base::Attribute
this_type	core/base/Attribute.h	/^    typedef AttributeEntity<mesh_type> this_type;$/;"	t	class:simpla::base::AttributeEntity
this_type	core/data_model/data_view.h	/^	typedef data_view<value_type, index_range_type, Tags...> this_type;$/;"	t	struct:simpla::data_view
this_type	core/field/FieldDense.h	/^    typedef Field<TV, TMesh, std::integral_constant<int, IFORM>, Policies...> this_type;$/;"	t	class:simpla::Field
this_type	core/field/FieldExpression.h	/^    typedef Field<AssignmentExpression<TOP, TL, TR>> this_type;$/;"	t	struct:simpla::Field
this_type	core/field/FieldExpression.h	/^    typedef Field<Expression<T...> > this_type;$/;"	t	struct:simpla::Field
this_type	core/field/FieldFunction.h	/^    typedef Field<TV, mesh_type, std::integral_constant<int, IFORM>, tags::function, TFun, TBox, Policies...> this_type;$/;"	t	class:simpla::Field
this_type	core/field/obsoleted/field_constant.h	/^	typedef Field<TM, TV, _impl::this_is_constant> this_type;$/;"	t	class:simpla::Field
this_type	core/field/obsoleted/field_sparse.h	/^	typedef Field<mesh_type, value_type, _impl::is_associative_container> this_type;$/;"	t	struct:simpla::Field
this_type	core/field/test/trash/field_continue.h	/^	typedef Field<mesh_type, container_type, _impl::is_sequence_container> this_type;$/;"	t	struct:simpla::Field
this_type	core/geometry/GeoObject.h	/^    typedef GeoObject this_type;$/;"	t	class:simpla::geometry::GeoObject
this_type	core/geometry/implicit_function.h	/^	typedef ImplicitFunction<Expression<TOP, TL, TR>> this_type;$/;"	t	struct:simpla::ImplicitFunction
this_type	core/geometry/implicit_function.h	/^	typedef ImplicitFunction<Expression<_impl::logical_not, TL, std::nullptr_t>> this_type;$/;"	t	struct:simpla::ImplicitFunction
this_type	core/geometry/implicit_function.h	/^	typedef ImplicitFunction<Expression<_impl::logical_or, TL, TR>> this_type;$/;"	t	struct:simpla::ImplicitFunction
this_type	core/geometry/implicit_function.h	/^	typedef ImplicitFunction<Expression<_impl::minus, TL, TR>> this_type;$/;"	t	struct:simpla::ImplicitFunction
this_type	core/geometry/implicit_function.h	/^	typedef ImplicitFunction<Expression<_impl::negate, TL, std::nullptr_t>> this_type;$/;"	t	struct:simpla::ImplicitFunction
this_type	core/geometry/implicit_function.h	/^	typedef ImplicitFunction<Expression<_impl::plus, TL, TR>> this_type;$/;"	t	struct:simpla::ImplicitFunction
this_type	core/geometry/obsolete/surface.h	/^	typedef Surface<mesh_type> this_type;$/;"	t	class:simpla::Surface
this_type	core/geometry/primitive.h	/^    typedef Primitive<Dimension, CoordinateSystem, Tag> this_type;$/;"	t	struct:simpla::geometry::model::Primitive
this_type	core/gtl/Properties.h	/^    typedef Properties this_type;$/;"	t	class:simpla::Properties
this_type	core/gtl/array_view.h	/^    typedef ArrayViewBase this_type;$/;"	t	struct:simpla::gtl::ArrayViewBase
this_type	core/gtl/cache.h	/^	typedef Cache<T*> this_type;$/;"	t	struct:simpla::Cache
this_type	core/gtl/containers/UnorderedSet.h	/^    typedef UnorderedSet<ValueType, Key> this_type;$/;"	t	class:simpla::gtl::UnorderedSet
this_type	core/gtl/containers/container_container.h	/^	typedef ContainerContainer<key_type, value_type, SubContainer> this_type;$/;"	t	class:simpla::ContainerContainer
this_type	core/gtl/containers/container_dense.h	/^	typedef DenseContainer<key_type, value_type> this_type;$/;"	t	class:simpla::DenseContainer
this_type	core/gtl/containers/container_pool.h	/^	typedef ContainerPool<value_type> this_type;$/;"	t	struct:simpla::ContainerPool
this_type	core/gtl/containers/container_sparse.h	/^    typedef SparseContainer<key_type, value_type> this_type;$/;"	t	class:simpla::SparseContainer
this_type	core/gtl/containers/sp_hash_container.h	/^	typedef SpHashContainer<key_type, value_type, hash_function> this_type;$/;"	t	struct:simpla::SpHashContainer
this_type	core/gtl/containers/sp_ndarray.h	/^	typedef ndArray<value_type, ndims> this_type;$/;"	t	class:simpla::ndArray
this_type	core/gtl/containers/unordered_set.h	/^    typedef UnorderedSet<value_type, key_type, allocator_type> this_type;$/;"	t	class:simpla::UnorderedSet
this_type	core/gtl/enable_create_from_this.h	/^	typedef enable_create_from_this<object_type> this_type;$/;"	t	struct:simpla::enable_create_from_this
this_type	core/gtl/expression_template.h	/^    typedef AssignmentExpression<TOP, TL, TR> this_type;$/;"	t	struct:simpla::AssignmentExpression
this_type	core/gtl/expression_template.h	/^    typedef Expression<TOP, Args...> this_type;$/;"	t	struct:simpla::Expression
this_type	core/gtl/function.h	/^    typedef Function<value_type, TFun> this_type;$/;"	t	class:simpla::Function
this_type	core/gtl/function_cache.h	/^	typedef FunctionCache<RectValue, TFun, void> this_type;$/;"	t	struct:simpla::FunctionCache
this_type	core/gtl/iterator/block_iterator.h	/^    typedef block_iterator<TV, NDIMS> this_type;$/;"	t	struct:simpla::block_iterator
this_type	core/gtl/iterator/indirect_iterator.h	/^	typedef indirect_iterator<src_iterator> this_type;$/;"	t	struct:simpla::indirect_iterator
this_type	core/gtl/iterator/iterator_sequence.h	/^	typedef IteratorSequence<TI> this_type;$/;"	t	class:simpla::IteratorSequence
this_type	core/gtl/iterator/range.h	/^    typedef Range<Iterator> this_type;$/;"	t	class:simpla::Range
this_type	core/gtl/iterator/sp_indirect_iterator.h	/^    typedef sp_indirect_iterator<base_iterator_type, container_type> this_type;$/;"	t	struct:simpla::sp_indirect_iterator
this_type	core/gtl/iterator/sp_iterator_cycle.h	/^	typedef CycleIterator<base_iterator> this_type;$/;"	t	struct:simpla::CycleIterator
this_type	core/gtl/iterator/sp_iterator_filter.h	/^	typedef sp_fliter_iterator<base_iterator, predicate_fun> this_type;$/;"	t	struct:simpla::sp_fliter_iterator
this_type	core/gtl/iterator/sp_iterator_index_base.h	/^	typedef Iterator<T*, std::nullptr_t, std::nullptr_t> this_type;$/;"	t	class:simpla::Iterator
this_type	core/gtl/iterator/sp_iterator_mapped.h	/^			IsReference> this_type;$/;"	t	struct:simpla::Iterator
this_type	core/gtl/iterator/sp_iterator_mapped.h	/^	typedef Iterator< key_iterator, conatiner_type,_iterator_policy_mapped, IsReference> this_type;$/;"	t	struct:simpla::Iterator
this_type	core/gtl/iterator/sp_iterator_shared_container.h	/^	typedef StorageSharedContainer<container_type> this_type;$/;"	t	struct:simpla::_impl::StorageSharedContainer
this_type	core/gtl/iterator/sp_ntuple_range.h	/^    typedef iterator this_type;$/;"	t	struct:simpla::sp_nTuple_range::iterator
this_type	core/gtl/iterator/sp_ntuple_range.h	/^    typedef sp_nTuple_range<IndexType, DIMS...> this_type;$/;"	t	struct:simpla::sp_nTuple_range
this_type	core/gtl/ntuple.h	/^            this_type;$/;"	t	struct:simpla::nTuple
this_type	core/gtl/ntuple.h	/^    typedef nTuple<Expression<T...>> this_type;$/;"	t	struct:simpla::nTuple
this_type	core/gtl/ntuple.h	/^    typedef nTuple<Expression<TOP, ARG0, ARG1>> this_type;$/;"	t	struct:simpla::nTuple
this_type	core/gtl/ntuple.h	/^    typedef nTuple<Expression<TOP, ARG0>> this_type;$/;"	t	struct:simpla::nTuple
this_type	core/gtl/ntuple.h	/^    typedef nTuple<value_type, N, M...> this_type;$/;"	t	struct:simpla::nTuple
this_type	core/gtl/utilities/log.h	/^    typedef Logger this_type;$/;"	t	class:simpla::logger::Logger
this_type	core/gtl/utilities/lua_object.h	/^    typedef LuaObject this_type;$/;"	t	class:simpla::lua::LuaObject
this_type	core/manifold/Manifold.h	/^    typedef Manifold<TMesh, Policies ...> this_type;$/;"	t	class:simpla::Manifold
this_type	core/manifold/mesh/CartesianCoRect.h	/^    typedef CartesianCoRect this_type;$/;"	t	struct:simpla::mesh::CartesianCoRect
this_type	core/manifold/mesh/CoRectMesh.h	/^    typedef Mesh<TMetric, tags::corect_linear> this_type;$/;"	t	struct:simpla::mesh::Mesh
this_type	core/manifold/mesh/CylindricalCoRect.h	/^    typedef CylindricalCoRect this_type;$/;"	t	class:simpla::mesh::CylindricalCoRect
this_type	core/manifold/mesh/GeneralMap.h	/^    typedef GeneralMap<LEFT> this_type;$/;"	t	struct:simpla::mesh::GeneralMap
this_type	core/manifold/mesh/GeneralMap.h	/^    typedef SquareMap<TP, N> this_type;$/;"	t	struct:simpla::mesh::SquareMap
this_type	core/manifold/mesh/LinearMap.h	/^    typedef LinearMap this_type;$/;"	t	struct:simpla::mesh::LinearMap
this_type	core/manifold/mesh/MeshBlock.h	/^    typedef MeshBlock this_type;$/;"	t	struct:simpla::mesh::MeshBlock
this_type	core/manifold/mesh/MeshIds.h	/^        typedef range_type this_type;$/;"	t	struct:simpla::mesh::MeshEntityIdCoder::range_type
this_type	core/manifold/mesh/MeshIds.h	/^    typedef MeshEntityIdCoder<LV> this_type;$/;"	t	struct:simpla::mesh::MeshEntityIdCoder
this_type	core/manifold/mesh/RectMesh.h	/^    typedef Mesh<TMetric, tags::rect_linear> this_type;$/;"	t	struct:simpla::mesh::Mesh
this_type	core/manifold/obsoleted/amr_policy.h	/^    typedef AMR<TMesh> this_type;$/;"	t	class:simpla::manifold::policy::AMR
this_type	core/manifold/obsoleted/embedded_policy.h	/^    typedef EmbeddedPolicy<geometry_type> this_type;$/;"	t	struct:simpla::manifold::policy::EmbeddedPolicy
this_type	core/manifold/obsoleted/fiber_bundle.h	/^    typedef FiberBundle<point_type, mesh_type, project_map_type> this_type;$/;"	t	class:simpla::manifold::FiberBundle
this_type	core/manifold/obsoleted/patch/mesh_patch.h	/^    typedef MeshPatch<TM> this_type;$/;"	t	class:simpla::mesh::MeshPatch
this_type	core/manifold/policy/FvmStructuredPolicy.h	/^    typedef FiniteVolume this_type;$/;"	t	struct:simpla::manifold::policy::FiniteVolume
this_type	core/manifold/policy/IOPolicy.h	/^    typedef IOPolicy<geometry_type> this_type;$/;"	t	struct:simpla::manifold::policy::IOPolicy
this_type	core/manifold/policy/LinearInterpolatorPolicy.h	/^    typedef LinearInterpolator this_type;$/;"	t	struct:simpla::manifold::policy::LinearInterpolator
this_type	core/manifold/policy/ParallelPolicy.h	/^    typedef ParallelPolicy<mesh_type> this_type;$/;"	t	struct:simpla::manifold::policy::ParallelPolicy
this_type	core/manifold/policy/StoragePolicy.h	/^    typedef StoragePolicy<geometry_type> this_type;$/;"	t	struct:simpla::manifold::policy::StoragePolicy
this_type	core/model/GEqdsk.h	/^    typedef GEqdsk this_type;$/;"	t	class:simpla::GEqdsk
this_type	core/numeric/interpolation.h	/^    typedef BiLinearInterpolation this_type;$/;"	t	class:simpla::BiLinearInterpolation
this_type	core/numeric/interpolation.h	/^    typedef Interpolation<TInterpolator, TV, TX> this_type;$/;"	t	class:simpla::Interpolation
this_type	core/numeric/interpolation.h	/^    typedef LinearInterpolation this_type;$/;"	t	struct:simpla::LinearInterpolation
this_type	core/numeric/interpolation.h	/^    typedef MultiDimesionInterpolation<TInterpolator, TV> this_type;$/;"	t	class:simpla::MultiDimesionInterpolation
this_type	core/numeric/multi_normal_distribution.h	/^	typedef multi_normal_distribution<N, RealType, TNormalGen> this_type;$/;"	t	class:simpla::multi_normal_distribution
this_type	core/parallel/obsoleted/blocked_range.h	/^	typedef BlockedRange<T, 1> this_type;$/;"	t	struct:simpla::BlockedRange
this_type	core/parallel/obsoleted/distributed.h	/^	typedef Distributed<base_type> this_type;$/;"	t	class:simpla::Distributed
this_type	core/parallel/obsoleted/distributed_unordered_set.h	/^	typedef Distributed<UnorderedSet<TV, Others...>, TRange> this_type;$/;"	t	struct:simpla::Distributed
this_type	core/particle/Particle.h	/^    typedef Particle<P, M> this_type;$/;"	t	struct:simpla::particle::Particle
this_type	core/particle/Particle.h	/^    typedef ParticleBase this_type;$/;"	t	struct:simpla::particle::ParticleBase
this_type	core/particle/ParticleContainer.h	/^    typedef ParticleContainer<ParticleEngine, M> this_type;$/;"	t	struct:simpla::particle::ParticleContainer
this_type	core/particle/ParticleGenerator.h	/^    typedef ParticleGeneratorPerCell<TP, TSeed, XDist, VDist> this_type;$/;"	t	class:simpla::particle::ParticleGeneratorPerCell
this_type	core/particle/ParticleProxy.h	/^    typedef ParticleProxy<TP, TE, TB, TJ, TRho> this_type;$/;"	t	class:simpla::particle::ParticleProxy
this_type	core/particle/ParticleProxy.h	/^    typedef ParticleProxyBase<TE, TB, TJ, TRho> this_type;$/;"	t	struct:simpla::particle::ParticleProxyBase
this_type	core/particle/obsolete/kinetic_particle.h	/^    typedef KineticParticle<engine_type, Others...> this_type;$/;"	t	struct:KineticParticle
this_type	core/particle/obsolete/probe_particle.h	/^    typedef ProbeParticle<engine_type> this_type;$/;"	t	struct:simpla::ProbeParticle
this_type	core/physics/PhysicalConstants.h	/^    typedef PhysicalConstants this_type;$/;"	t	class:simpla::PhysicalConstants
this_type	core/task_flow/task_flow_base.h	/^    typedef ContextBase this_type;$/;"	t	class:simpla::task_flow::ContextBase
this_type	example/pic/demo_pic.h	/^	typedef FiberBundle<pic_demo, TBase> this_type;$/;"	t	struct:simpla::FiberBundle
this_type	example/probe_particle/demo_probe_particle.h	/^	typedef ProbeDemo this_type;$/;"	t	struct:simpla::ProbeDemo
threading_list	cpplint.py	/^threading_list = ($/;"	v
time	core/io/XDMFStream.cpp	/^void XDMFStream::time(Real t)$/;"	f	class:simpla::io::XDMFStream
time	core/manifold/Manifold.h	/^    double time() const { return m_time_; }$/;"	f	class:simpla::Manifold
time	core/manifold/Manifold.h	/^    void time(double t) { m_time_ = t; }$/;"	f	class:simpla::Manifold
time	core/manifold/obsoleted/time_integrator_policy.h	/^    double time() const { return m_time_; }$/;"	f	struct:simpla::manifold::policy::TimeIntegrator
time	core/manifold/obsoleted/time_integrator_policy.h	/^    void time(double t) { m_time_ = t; }$/;"	f	struct:simpla::manifold::policy::TimeIntegrator
time_inegral_policy	core/manifold/obsoleted/time_integrator_policy.h	/^    typedef TimeIntegrator<TGeo, Policy...> time_inegral_policy;$/;"	t	struct:simpla::manifold::policy::TimeIntegrator
time_stamp	core/gtl/utilities/log.cpp	/^    static std::string time_stamp()$/;"	f	struct:simpla::logger::LoggerStreams
to	core/gtl/utilities/lua_object.cpp	/^Converter<Properties>::to(lua_State *L, Properties const &v)$/;"	f	class:simpla::lua::Converter
to	core/gtl/utilities/lua_object_ext.h	/^    static inline unsigned int to(lua_State *L, value_type const &v)$/;"	f	struct:simpla::lua::Converter
to	core/gtl/utilities/lua_object_ext.h	/^    static inline unsigned int to(lua_State *L,$/;"	f	struct:simpla::lua::Converter
to_	core/gtl/utilities/lua_object_ext.h	/^    static inline unsigned int to_(lua_State *L,$/;"	f	struct:simpla::lua::Converter
to_	core/gtl/utilities/lua_object_ext.h	/^    template<unsigned int N> static inline unsigned int to_($/;"	f	struct:simpla::lua::Converter
to_bool	core/gtl/any.h	/^    virtual bool to_bool() const { return _impl::_to_bool(m_value); };$/;"	f	struct:simpla::Derived
to_floating_point	core/gtl/any.h	/^    virtual double to_floating_point() const { return _impl::_to_floating_point(m_value); };$/;"	f	struct:simpla::Derived
to_integer	core/gtl/any.h	/^    virtual int to_integer() const { return _impl::_to_integer(m_value); };$/;"	f	struct:simpla::Derived
to_string	core/gtl/any.h	/^    virtual std::string to_string() const { return _impl::_to_string(m_value); };$/;"	f	struct:simpla::Derived
topology	core/manifold/mesh/MeshCommon.h	/^namespace topology$/;"	n	namespace:simpla
topology	core/parallel/MPIComm.cpp	/^nTuple<int, 3> MPIComm::topology() const$/;"	f	class:simpla::parallel::MPIComm
topology	core/parallel/MPIComm.cpp	/^void MPIComm::topology(nTuple<int, 3> const &d)$/;"	f	class:simpla::parallel::MPIComm
topology_type	core/geometry/obsolete/polygon.h	/^	typedef typename mesh_type::topology_type topology_type;$/;"	t	struct:simpla::PolyGon
touch	core/base/LifeClick.h	/^    size_t touch(size_t *r)$/;"	f	struct:simpla::base::LifeClick
touch	core/base/Object.h	/^    inline void touch() { GLOBAL_CLICK_TOUCH(&m_click_); }$/;"	f	class:simpla::base::Object
track	core/gtl/design_pattern/signal.h	/^    void track(std::shared_ptr<TObject> &object)$/;"	f	struct:simpla::Signal::Slot
traits	core/data_model/DataType.h	/^namespace simpla { namespace traits$/;"	n	namespace:simpla
traits	core/field/FieldDense.h	/^namespace traits$/;"	n	namespace:simpla
traits	core/field/FieldExpression.h	/^namespace traits$/;"	n	namespace:simpla
traits	core/field/FieldTraits.h	/^namespace traits$/;"	n	namespace:simpla
traits	core/geometry/CoordinateSystem.h	/^namespace traits$/;"	n	namespace:simpla::geometry
traits	core/geometry/boost_gemetry_adapted.h	/^namespace traits$/;"	n	namespace:boost::geometry
traits	core/geometry/box.h	/^namespace traits$/;"	n	namespace:simpla::geometry
traits	core/geometry/chains.h	/^namespace traits {$/;"	n	namespace:simpla::geometry
traits	core/geometry/csCylindrical.h	/^namespace traits$/;"	n	namespace:simpla
traits	core/geometry/cube.h	/^namespace traits$/;"	n	namespace:simpla::geometry
traits	core/geometry/geometry.h	/^namespace traits$/;"	n	namespace:simpla::geometry
traits	core/geometry/model.h	/^namespace traits$/;"	n	namespace:simpla::geometry
traits	core/geometry/primitive.h	/^namespace traits$/;"	n	namespace:simpla::geometry
traits	core/geometry/primitive_ext.h	/^namespace traits$/;"	n	namespace:simpla::geometry
traits	core/geometry/simplex.h	/^namespace traits$/;"	n	namespace:simpla::geometry
traits	core/gtl/check_concept.h	/^namespace traits$/;"	n	namespace:simpla
traits	core/gtl/expression_template.h	/^namespace traits$/;"	n	namespace:simpla
traits	core/gtl/ntuple.h	/^namespace traits$/;"	n	namespace:simpla
traits	core/gtl/ntuple_ext.h	/^namespace traits$/;"	n	namespace:simpla
traits	core/gtl/type_cast.h	/^namespace traits$/;"	n	namespace:simpla
traits	core/gtl/type_traits.h	/^namespace traits$/;"	n	namespace:simpla
traits	core/gtl/utilities/lua_object.h	/^namespace traits$/;"	n	namespace:simpla
traits	core/manifold/Calculus.h	/^namespace traits$/;"	n	namespace:simpla
traits	core/manifold/ManifoldTraits.h	/^namespace traits$/;"	n	namespace:simpla
traits	core/manifold/ManifoldTraits.h	/^namespace traits$/;"	n	namespace:simpla::geometry
traits	core/manifold/mesh/Mesh.h	/^namespace simpla { namespace geometry { namespace traits$/;"	n	namespace:simpla::geometry
traits	core/manifold/mesh/MeshCommon.h	/^namespace traits$/;"	n	namespace:simpla
traits	core/manifold/obsoleted/time_integrator_policy.h	/^namespace simpla { namespace traits$/;"	n	namespace:simpla
traits	core/manifold/policy/IOPolicy.h	/^namespace traits$/;"	n	namespace:simpla
traits	core/manifold/pre_define/PreDefine.h	/^namespace simpla { namespace traits$/;"	n	namespace:simpla
transform	core/particle/ParticleConstraint.h	/^void transform(Particle<P, M> &p, model::Constraint<M, T...> const &constraint, Func const &func)$/;"	f	namespace:simpla::particle
trim	core/gtl/utilities/parse_command_line.cpp	/^std::string trim(std::string const & s)$/;"	f	namespace:simpla
try_lock	core/base/Object.h	/^    inline bool try_lock() { return m_mutex_.try_lock(); }$/;"	f	class:simpla::base::Object
try_lock	core/gtl/utilities/lua_object.h	/^        bool try_lock() const { return m_l_->m_mutex_.try_lock(); }$/;"	f	struct:simpla::lua::LuaObject::LuaState
type	core/field/FieldDense.h	/^    typedef TM type;$/;"	t	struct:simpla::traits::mesh_type
type	core/field/FieldDense.h	/^    typedef TV type;$/;"	t	struct:simpla::traits::value_type
type	core/field/FieldExpression.h	/^    typedef bool type;$/;"	t	struct:simpla::traits::field_value_type
type	core/field/FieldExpression.h	/^    typedef bool type;$/;"	t	struct:simpla::traits::value_type
type	core/field/FieldExpression.h	/^    typedef result_of_t<TOP(typename value_type<T>::type ...)> type;$/;"	t	struct:simpla::traits::value_type
type	core/field/FieldTraits.h	/^            value_type_t<T>, nTuple<value_type_t<T>, 3> >::type type;$/;"	t	struct:simpla::traits::field_value_type
type	core/field/FieldTraits.h	/^    typedef Field<TM, TV, Others...> const &type;$/;"	t	struct:simpla::traits::reference
type	core/field/FieldTraits.h	/^    typedef size_t type;$/;"	t	struct:simpla::traits::key_type
type	core/geometry/CoordinateSystem.h	/^    typedef CS type;$/;"	t	struct:simpla::geometry::traits::coordinate_system_type
type	core/geometry/CoordinateSystem.h	/^    typedef Real type;$/;"	t	struct:simpla::geometry::traits::scalar_type
type	core/geometry/CoordinateSystem.h	/^    typedef nTuple <Real, dimension<CS>::value> type;$/;"	t	struct:simpla::geometry::traits::covector_type
type	core/geometry/CoordinateSystem.h	/^    typedef nTuple <Real, dimension<CS>::value> type;$/;"	t	struct:simpla::geometry::traits::point_type
type	core/geometry/CoordinateSystem.h	/^    typedef nTuple <Real, dimension<CS>::value> type;$/;"	t	struct:simpla::geometry::traits::vector_type
type	core/geometry/CoordinateSystem.h	/^    typedef typename T::coordinate_system_type type;$/;"	t	struct:simpla::geometry::traits::coordinate_system_type
type	core/geometry/boost_gemetry_adapted.h	/^	typedef box_tag type;$/;"	t	struct:boost::geometry::traits::tag
type	core/geometry/boost_gemetry_adapted.h	/^	typedef cs::cartesian type;$/;"	t	struct:boost::geometry::traits::coordinate_system
type	core/geometry/boost_gemetry_adapted.h	/^	typedef cs::spherical<radian> type;$/;"	t	struct:boost::geometry::traits::coordinate_system
type	core/geometry/boost_gemetry_adapted.h	/^	typedef point_tag type;$/;"	t	struct:boost::geometry::traits::tag
type	core/geometry/boost_gemetry_adapted.h	/^	typedef polygon_tag type;$/;"	t	struct:boost::geometry::traits::tag
type	core/geometry/boost_gemetry_adapted.h	/^	typedef ring_tag type;$/;"	t	struct:boost::geometry::traits::tag
type	core/geometry/boost_gemetry_adapted.h	/^	typedef segment_tag type;$/;"	t	struct:boost::geometry::traits::tag
type	core/geometry/boost_gemetry_adapted.h	/^	typedef sgm::Point<CS> type;$/;"	t	struct:boost::geometry::traits::point_type
type	core/geometry/boost_gemetry_adapted.h	/^	typedef typename sg::traits::coordinate_type<CS>::type type;$/;"	t	struct:boost::geometry::traits::coordinate_type
type	core/geometry/boost_gemetry_adapted.h	/^	typedef typename sgm::Polygon<CS>::inner_container_type const& type;$/;"	t	class:boost::geometry::traits::interior_const_type::sgm::Polygon
type	core/geometry/boost_gemetry_adapted.h	/^	typedef typename sgm::Polygon<CS>::inner_container_type& type;$/;"	t	struct:boost::geometry::traits::interior_mutable_type
type	core/geometry/boost_gemetry_adapted.h	/^	typedef typename sgm::Polygon<CS>::ring_type const& type;$/;"	t	class:boost::geometry::traits::ring_const_type::sgm::Polygon
type	core/geometry/boost_gemetry_adapted.h	/^	typedef typename sgm::Polygon<CS>::ring_type& type;$/;"	t	struct:boost::geometry::traits::ring_mutable_type
type	core/geometry/boost_gemetry_adapted.h	/^	typedef typename sgm::Primitive<0, CS, sg::tags::simplex> type;$/;"	t	struct:boost::geometry::traits::point_type
type	core/geometry/box.h	/^	typedef CoordinateSystem type;$/;"	t	struct:simpla::geometry::traits::coordinate_system
type	core/geometry/chains.h	/^    typedef typename coordinate_system<PrimitiveType>::type type;$/;"	t	struct:simpla::geometry::traits::coordinate_system
type	core/geometry/cube.h	/^	typedef model::Primitive<0, CS> type;$/;"	t	struct:simpla::geometry::traits::facet
type	core/geometry/cube.h	/^	typedef model::Primitive<1, CS> type;$/;"	t	struct:simpla::geometry::traits::facet
type	core/geometry/model.h	/^	typedef CS type;$/;"	t	struct:simpla::geometry::traits::coordinate_system
type	core/geometry/primitive.h	/^            typename facet<model::Primitive<Dimension, Others...> >::type>::type type;$/;"	t	struct:simpla::geometry::traits::ridge
type	core/geometry/primitive.h	/^            typename ridge<model::Primitive<Dimension, Others...> >::type>::type type;$/;"	t	struct:simpla::geometry::traits::peak
type	core/geometry/primitive.h	/^    typedef CoordinateSystem type;$/;"	t	struct:simpla::geometry::traits::coordinate_system
type	core/geometry/primitive.h	/^    typedef Tag type;$/;"	t	struct:simpla::geometry::traits::tag
type	core/geometry/primitive.h	/^    typedef decltype(std::declval<a_type>() * std::declval<l_type>()) type;$/;"	t	struct:simpla::geometry::traits::volume_type
type	core/geometry/primitive.h	/^    typedef decltype(std::declval<geo>()[0]) type;$/;"	t	struct:simpla::geometry::traits::value_type
type	core/geometry/primitive.h	/^    typedef decltype(std::declval<l_type>() * std::declval<l_type>()) type;$/;"	t	struct:simpla::geometry::traits::area_type
type	core/geometry/primitive.h	/^    typedef model::Primitive<0, CoordinateSystem, Tag> type;$/;"	t	struct:simpla::geometry::traits::point_type
type	core/geometry/primitive.h	/^    typedef model::Primitive<Dimension - 1, Others...> type;$/;"	t	struct:simpla::geometry::traits::facet
type	core/geometry/simplex.h	/^	typedef model::Primitive<0, CS> type;$/;"	t	struct:simpla::geometry::traits::facet
type	core/geometry/simplex.h	/^	typedef model::Primitive<1, CS> type;$/;"	t	struct:simpla::geometry::traits::facet
type	core/gtl/expression_template.h	/^    typedef logical_and type;$/;"	t	struct:simpla::_impl::op_traits
type	core/gtl/expression_template.h	/^    typedef logical_or type;$/;"	t	struct:simpla::_impl::op_traits
type	core/gtl/integer_sequence.h	/^    typedef U type;$/;"	t	struct:simpla::mpl::seq_max
type	core/gtl/integer_sequence.h	/^    typedef U type;$/;"	t	struct:simpla::mpl::seq_min
type	core/gtl/integer_sequence.h	/^    typedef integer_sequence<_Tp, N...> type;$/;"	t	struct:simpla::mpl::seq_max
type	core/gtl/integer_sequence.h	/^    typedef typename seq_max<U, seq_max<T...> >::type type;$/;"	t	struct:simpla::mpl::seq_max
type	core/gtl/integer_sequence.h	/^    typedef typename seq_max<U, seq_max<T> >::type type;$/;"	t	struct:simpla::mpl::seq_max
type	core/gtl/integer_sequence.h	/^    typedef typename seq_min<U, seq_min<T...> >::type type;$/;"	t	struct:simpla::mpl::seq_min
type	core/gtl/integer_sequence.h	/^    typedef void type;$/;"	t	struct:simpla::mpl::seq_max
type	core/gtl/integer_sequence.h	/^    typedef void type;$/;"	t	struct:simpla::mpl::seq_min
type	core/gtl/mpl.h	/^			typename split_tuple<I + 1, T...>::following> type;$/;"	t	struct:simpla::mpl::replace_tuple
type	core/gtl/mpl.h	/^	typedef H<P...> type;$/;"	t	struct:simpla::mpl::assamble_tuple
type	core/gtl/mpl.h	/^	typedef T0 type;$/;"	t	struct:simpla::mpl::unpack_type_seq
type	core/gtl/mpl.h	/^	typedef U type;$/;"	t	struct:simpla::mpl::replace_tuple
type	core/gtl/mpl.h	/^	typedef cat_tuple_t<cat_tuple_t<T0>, cat_tuple_t<T...>> type;$/;"	t	struct:simpla::mpl::cat_tuple
type	core/gtl/mpl.h	/^	typedef std::tuple<> type;$/;"	t	struct:simpla::mpl::cat_tuple
type	core/gtl/mpl.h	/^	typedef std::tuple<T...> type;$/;"	t	struct:simpla::mpl::cat_tuple
type	core/gtl/mpl.h	/^	typedef std::tuple<T0..., T1...> type;$/;"	t	struct:simpla::mpl::cat_tuple
type	core/gtl/mpl.h	/^	typedef std::tuple<T0> type;$/;"	t	struct:simpla::mpl::cat_tuple
type	core/gtl/mpl.h	/^	typedef typename assamble_tuple<H,P...>::type type;$/;"	t	struct:simpla::mpl::assamble_tuple
type	core/gtl/mpl.h	/^	typedef typename unpack_type_seq<N - 1, Others...>::type type;$/;"	t	struct:simpla::mpl::unpack_type_seq
type	core/gtl/mpl.h	/^	typedef void type;$/;"	t	struct:simpla::mpl::unpack_type_seq
type	core/gtl/mpl.h	/^	typename split_tuple<I + 1, T...>::following> > type;$/;"	t	struct:simpla::mpl::replace_tuple
type	core/gtl/ntuple.h	/^            traits::extents_t<nTuple<T, N...>>> type;$/;"	t	struct:simpla::traits::pod_type
type	core/gtl/ntuple.h	/^            type;$/;"	t	struct:simpla::traits::primary_type
type	core/gtl/ntuple.h	/^            typename extents_helper<TOP, Others...>::type>::type type;$/;"	t	struct:simpla::traits::_impl::extents_helper
type	core/gtl/ntuple.h	/^    typedef TV type;$/;"	t	struct:simpla::traits::_impl::make_pod_array
type	core/gtl/ntuple.h	/^    typedef TV type;$/;"	t	struct:simpla::traits::_impl::make_primary_nTuple
type	core/gtl/ntuple.h	/^    typedef bool type;$/;"	t	struct:simpla::traits::pod_type
type	core/gtl/ntuple.h	/^    typedef bool type;$/;"	t	struct:simpla::traits::primary_type
type	core/gtl/ntuple.h	/^    typedef bool type;$/;"	t	struct:simpla::traits::value_type
type	core/gtl/ntuple.h	/^    typedef int type;$/;"	t	struct:simpla::traits::key_type
type	core/gtl/ntuple.h	/^    typedef integer_sequence<_Tp, N...> type;$/;"	t	struct:simpla::traits::_impl::extents_helper
type	core/gtl/ntuple.h	/^    typedef integer_sequence<_Tp> type;$/;"	t	struct:simpla::traits::_impl::extents_helper
type	core/gtl/ntuple.h	/^    typedef integer_sequence<int> type;$/;"	t	struct:simpla::traits::_impl::extents_helper
type	core/gtl/ntuple.h	/^    typedef nTuple<T, M, N...> const &type;$/;"	t	struct:simpla::traits::reference
type	core/gtl/ntuple.h	/^    typedef nTuple<T> type;$/;"	t	struct:simpla::traits::reference
type	core/gtl/ntuple.h	/^    typedef nTuple<TV, N...> type;$/;"	t	struct:simpla::traits::_impl::make_primary_nTuple
type	core/gtl/ntuple.h	/^    typedef traits::result_of_t<TOP(traits::value_type_t<T>...)> type;$/;"	t	struct:simpla::traits::value_type
type	core/gtl/ntuple.h	/^    typedef traits::value_type_t<TV> type;$/;"	t	struct:simpla::traits::value_type
type	core/gtl/ntuple.h	/^    typedef typename make_pod_array<TV, integer_sequence<TI, N...>>::type type[N0];$/;"	t	struct:simpla::traits::_impl::make_pod_array
type	core/gtl/test/ntuple_perf_test.cpp	/^	typedef nTuple<T, M, N> type;$/;"	t	class:nTuplePerf2	file:
type	core/gtl/test/ntuple_perf_test.cpp	/^	typedef nTuple<T, N> type;$/;"	t	class:nTuplePerf1	file:
type	core/gtl/test/ntuple_reduce_test.cpp	/^	typedef T type;$/;"	t	class:TestNtupleReduce	file:
type	core/gtl/type_traits.h	/^            integer_sequence<TP, N - 1> >::type type;$/;"	t	struct:simpla::_impl::gen_seq
type	core/gtl/type_traits.h	/^    typedef First type;$/;"	t	struct:simpla::traits::seq_concat
type	core/gtl/type_traits.h	/^    typedef First type;$/;"	t	struct:simpla::traits::unpack_type
type	core/gtl/type_traits.h	/^    typedef T type;$/;"	t	struct:simpla::traits::pod_type
type	core/gtl/type_traits.h	/^    typedef T type;$/;"	t	struct:simpla::traits::primary_type
type	core/gtl/type_traits.h	/^    typedef T type;$/;"	t	struct:simpla::traits::reference
type	core/gtl/type_traits.h	/^    typedef _Tp type;$/;"	t	struct:simpla::traits::value_type
type	core/gtl/type_traits.h	/^    typedef int type;$/;"	t	struct:simpla::traits::key_type
type	core/gtl/type_traits.h	/^    typedef integer_sequence<TP> type;$/;"	t	struct:simpla::_impl::gen_seq
type	core/gtl/type_traits.h	/^    typedef integer_sequence<_Tp, _I...> type;$/;"	t	struct:simpla::integer_sequence
type	core/gtl/type_traits.h	/^    typedef integer_sequence<_Tp, _M..., _N...> type;$/;"	t	struct:simpla::traits::seq_concat
type	core/gtl/type_traits.h	/^    typedef integer_sequence<_Tp> type;$/;"	t	struct:simpla::integer_sequence
type	core/gtl/type_traits.h	/^    typedef std::nullptr_t type;$/;"	t	struct:simpla::traits::unpack_type
type	core/gtl/type_traits.h	/^    typedef std::string type;$/;"	t	struct:simpla::traits::value_type
type	core/gtl/type_traits.h	/^    typedef typename seq_concat<First, typename seq_concat<Others...>::type>::type type;$/;"	t	struct:simpla::traits::seq_concat
type	core/gtl/type_traits.h	/^    typedef typename std::conditional<std::is_scalar<T>::value, T, std::nullptr_t>::type type;$/;"	t	struct:simpla::traits::value_type
type	core/gtl/type_traits.h	/^    typedef typename std::result_of<_Signature>::type type;$/;"	t	struct:simpla::traits::result_of
type	core/gtl/type_traits.h	/^    typedef typename unpack_type<N - 1, Others...>::type type;$/;"	t	struct:simpla::traits::unpack_type
type	core/gtl/type_traits_ext.h	/^	typedef typename result_of<_impl::GetValue(TC, TI)>::type type;$/;"	t	struct:simpla::index_of
type	core/gtl/type_traits_ext.h	/^	typedef typename std::result_of<F(Args...)>::type type;$/;"	t	struct:simpla::result_of
type	core/manifold/Calculus.h	/^                                      value_type_t<T>)> type;$/;"	t	struct:simpla::traits::value_type
type	core/manifold/Calculus.h	/^            geometry::traits::scalar_type_t<manifold_type_t<T >>, value_type_t<T>)> type;$/;"	t	struct:simpla::traits::value_type
type	core/manifold/Calculus.h	/^            simpla::_impl::multiplies(value_type_t<T0>, value_type_t<T1>)> type;$/;"	t	struct:simpla::traits::value_type
type	core/manifold/Calculus.h	/^            value_type_t<T>, nTuple<value_type_t<T>, 3> >::type type;$/;"	t	struct:simpla::traits::value_type
type	core/manifold/Calculus.h	/^    typedef TV type;$/;"	t	struct:simpla::traits::value_type
type	core/manifold/Calculus.h	/^    typedef value_type_t<T0> type;$/;"	t	struct:simpla::traits::value_type
type	core/manifold/Calculus.h	/^    typedef value_type_t<T> type;$/;"	t	struct:simpla::traits::value_type
type	core/manifold/Calculus.h	/^    typedef value_type_t<value_type_t<T0>> type;$/;"	t	struct:simpla::traits::value_type
type	core/manifold/ManifoldTraits.h	/^    typedef int64_t type;$/;"	t	struct:simpla::traits::id_type
type	core/manifold/ManifoldTraits.h	/^    typedef integer_sequence<int, iform<T>::value...> type;$/;"	t	struct:simpla::traits::iform_list
type	core/manifold/ManifoldTraits.h	/^    typedef std::nullptr_t type;$/;"	t	struct:simpla::traits::geometry_type
type	core/manifold/ManifoldTraits.h	/^    typedef std::nullptr_t type;$/;"	t	struct:simpla::traits::mesh_type
type	core/manifold/ManifoldTraits.h	/^    typedef std::uint64_t type;$/;"	t	struct:simpla::traits::id_type
type	core/manifold/ManifoldTraits.h	/^    typedef typename coordinate_system_type<TM>::type type;$/;"	t	struct:simpla::geometry::traits::coordinate_system_type
type	core/manifold/mesh/Mesh.h	/^    typedef ::simpla::traits::unpack_t<0, T...> type;$/;"	t	struct:simpla::geometry::traits::metric_type
type	core/manifold/mesh/Mesh.h	/^    typedef coordinate_system_t<metric_t<::simpla::mesh::Mesh<T...> >> type;$/;"	t	struct:simpla::geometry::traits::coordinate_system_type
type	core/model/Constraint.h	/^    typedef parallel::concurrent_hash_map<typename TM::id_type, Arg> type;$/;"	t	struct:simpla::model::_impl::constraint_type_choice
type	core/model/Constraint.h	/^    typedef parallel::concurrent_hash_map<typename TM::id_type, std::tuple<Arg0, Args...>> type;$/;"	t	struct:simpla::model::_impl::constraint_type_choice
type	core/model/Constraint.h	/^    typedef parallel::concurrent_unordered_set<typename TM::id_type> type;$/;"	t	struct:simpla::model::_impl::constraint_type_choice
type	core/parallel/MPIDataType.h	/^    MPI_Datatype const &type(...) const$/;"	f	struct:simpla::MPIDataType
type_	core/physics/PhysicalConstants.h	/^    std::string type_;$/;"	m	class:simpla::PhysicalConstants
type_cast	core/gtl/ntuple_ext.h	/^struct type_cast<nTuple<T, N>, std::string>$/;"	s	namespace:simpla::traits
type_cast	core/gtl/ntuple_ext.h	/^struct type_cast<std::string, nTuple<T, N> >$/;"	s	namespace:simpla::traits
type_cast	core/gtl/type_cast.h	/^TDest type_cast(TSrc const & v)$/;"	f	namespace:simpla
type_cast	core/gtl/type_cast.h	/^struct type_cast$/;"	s	namespace:simpla::traits
type_cast	core/gtl/type_cast.h	/^struct type_cast<TSrc, TSrc>$/;"	s	namespace:simpla::traits
type_cast	core/gtl/type_cast.h	/^struct type_cast<TSrc, std::string>$/;"	s	namespace:simpla::traits
type_cast	core/gtl/type_cast.h	/^struct type_cast<std::string, T>$/;"	s	namespace:simpla::traits
type_cast	core/gtl/type_cast.h	/^struct type_cast<std::string, std::string>$/;"	s	namespace:simpla::traits
type_cast	core/gtl/utilities/lua_object.h	/^struct type_cast<lua::LuaObject, TDest>$/;"	s	namespace:simpla::traits
type_cast	core/manifold/mesh/MeshIds.h	/^    static constexpr T type_cast(id_type s)$/;"	f	struct:simpla::mesh::MeshEntityIdCoder
type_id	core/geometry/csCylindrical.h	/^struct type_id<::simpla::geometry::coordinate_system::Cylindrical<IPhiAxis> >$/;"	s	namespace:simpla::traits
type_id	core/gtl/type_traits.h	/^template<typename T, typename ...Others> struct type_id<T, Others...>$/;"	s	namespace:simpla::traits
type_id	core/gtl/type_traits.h	/^template<typename T> struct type_id<T>$/;"	s	namespace:simpla::traits
type_id	core/manifold/ManifoldTraits.h	/^struct type_id<Manifold<TMesh, Policies...> >$/;"	s	namespace:simpla::traits
type_id	core/manifold/mesh/MeshCommon.h	/^template<typename TAG> struct type_id<Topology<TAG>> { static std::string name() { return "Topology<>"; }};$/;"	s	namespace:simpla::traits
type_id	core/manifold/obsoleted/time_integrator_policy.h	/^struct type_id<manifold::policy::TimeIntegrator<T...> >$/;"	s	namespace:simpla::traits
type_id	core/manifold/policy/IOPolicy.h	/^struct type_id<manifold::policy::IOPolicy<TGeo>>$/;"	s	namespace:simpla::traits
type_name	core/gtl/any.h	/^    std::string type_name() const { return typeid(T).name(); }$/;"	f	struct:simpla::Derived
u_	core/numeric/multi_normal_distribution.h	/^	nTuple<RealType, N> u_;$/;"	m	class:simpla::multi_normal_distribution
u_case	core/task_flow/use_case_main.cpp	/^std::shared_ptr<simpla::use_case::UseCase> u_case;$/;"	v
uint	core/gtl/utilities/lua_object_ext.h	/^typedef unsigned int uint;$/;"	t	namespace:simpla::lua
ulong	core/gtl/utilities/lua_object_ext.h	/^typedef unsigned long ulong;$/;"	t	namespace:simpla::lua
unique	core/gtl/utilities/lua_object.h	/^        bool unique() const { return m_l_.unique(); }$/;"	f	struct:simpla::lua::LuaObject::LuaState
unitSymbol_	core/physics/PhysicalConstants.h	/^    std::map<std::string, std::string> unitSymbol_;$/;"	m	class:simpla::PhysicalConstants
unlock	core/base/Object.h	/^    inline void unlock() { m_mutex_.unlock(); }$/;"	f	class:simpla::base::Object
unlock	core/gtl/containers/container_container.h	/^	void unlock()$/;"	f	class:simpla::ContainerContainer
unlock	core/gtl/containers/container_dense.h	/^	void unlock()$/;"	f	class:simpla::DenseContainer
unlock	core/gtl/containers/container_sparse.h	/^    void unlock()$/;"	f	class:simpla::SparseContainer
unpack	core/manifold/mesh/MeshIds.h	/^    static constexpr id_tuple unpack(id_type s)$/;"	f	struct:simpla::mesh::MeshEntityIdCoder
unpack_args_helper	core/gtl/type_traits.h	/^struct unpack_args_helper$/;"	s	namespace:simpla::traits::_impl
unpack_args_helper	core/gtl/type_traits.h	/^struct unpack_args_helper<0>$/;"	s	namespace:simpla::traits::_impl
unpack_id	core/manifold/mesh/MeshIds.h	/^    static constexpr id_type unpack_id(id_type const &s, int n)$/;"	f	struct:simpla::mesh::MeshEntityIdCoder
unpack_index	core/manifold/mesh/MeshIds.h	/^    static constexpr index_tuple unpack_index(id_type s)$/;"	f	struct:simpla::mesh::MeshEntityIdCoder
unpack_index	core/manifold/mesh/MeshIds.h	/^    static constexpr index_type unpack_index(id_type const &s, int n)$/;"	f	struct:simpla::mesh::MeshEntityIdCoder
unpack_int_seq	core/gtl/mpl.h	/^struct unpack_int_seq<0, _Tp, I0, I...> : public std::integral_constant<_Tp, I0>$/;"	s	namespace:simpla::mpl
unpack_int_seq	core/gtl/mpl.h	/^struct unpack_int_seq<N, _Tp, I0, I...> : public std::integral_constant<_Tp,$/;"	s	namespace:simpla::mpl
unpack_int_seq	core/gtl/mpl.h	/^struct unpack_int_seq<N, _Tp> : public std::integral_constant<_Tp, 0>$/;"	s	namespace:simpla::mpl
unpack_type	core/gtl/type_traits.h	/^struct unpack_type<0, First, Others...>$/;"	s	namespace:simpla::traits
unpack_type	core/gtl/type_traits.h	/^struct unpack_type<N, First, Others...>$/;"	s	namespace:simpla::traits
unpack_type	core/gtl/type_traits.h	/^struct unpack_type<N>$/;"	s	namespace:simpla::traits
unpack_type_seq	core/gtl/mpl.h	/^struct unpack_type_seq<0, T0, Others...>$/;"	s	namespace:simpla::mpl
unpack_type_seq	core/gtl/mpl.h	/^struct unpack_type_seq<N, T0, Others...>$/;"	s	namespace:simpla::mpl
unpack_type_seq	core/gtl/mpl.h	/^struct unpack_type_seq<N>$/;"	s	namespace:simpla::mpl
unset	core/model/obsoleted/model.h	/^    void unset(TR const &r, tag_type const &tag)$/;"	f	class:simpla::Model
unset	core/model/obsoleted/model.h	/^    void unset(id_type const &s, tag_type const &tag)$/;"	f	class:simpla::Model
update	applications/particle_solver/pic_engine_deltaf.h	/^	void update()$/;"	f	struct:simpla::ParticleEngine
update	applications/particle_solver/pic_engine_deltaf2.h	/^	void update()$/;"	f	struct:simpla::PICEngineDeltaF
update	core/manifold/obsoleted/mesh_graph.h	/^void MeshCoarsen::update(DataSet *ds)$/;"	f	class:simpla::mesh::MeshCoarsen
update	core/manifold/obsoleted/mesh_graph.h	/^void MeshRefinement::update(DataSet *ds)$/;"	f	class:simpla::mesh::MeshRefinement
update	core/manifold/obsoleted/mesh_graph.h	/^void MeshTransform<TV, IFORM>::update(DataSet *ds)$/;"	f	class:simpla::mesh::MeshTransform
update	core/manifold/policy/ParallelPolicy.h	/^void ParallelPolicy<TMesh>::update(Func const &fun, Args &&...args) const$/;"	f	class:simpla::manifold::policy::ParallelPolicy
update	core/numeric/interpolation.h	/^    inline void update()$/;"	f	class:simpla::BiLinearInterpolation
update	core/numeric/interpolation.h	/^    void update()$/;"	f	class:simpla::MultiDimesionInterpolation
update	core/particle/obsolete/kinetic_particle.h	/^bool KineticParticle<Engine, TDomain>::update()$/;"	f	class:KineticParticle
update	core/particle/obsolete/simple_particle.h	/^	void update()$/;"	f	struct:simpla::SimpleParticleEngine
update	core/particle/test/particle_generator_test.cpp	/^    void update() { }$/;"	f	struct:simpla::PICDemo
update	example/pic/demo_pic.h	/^	void update()$/;"	f	struct:simpla::FiberBundle
update	example/probe_particle/demo_probe_particle.h	/^	void update()$/;"	f	struct:simpla::ProbeDemo
updateFields	applications/particle_solver/fluid_cold_engine.h	/^void Particle<TM, ColdFluid, PolicyFluidParticle>::updateFields()$/;"	f	class:simpla::Particle
update_cache	core/model/Constraint.h	/^void update_cache(TM const &m, geometry::GeoObject const &geo, CellCache<TM> *cache, int flag = 0)$/;"	f	namespace:simpla::model
upload_cache	core/particle/obsolete/probe_particle.h	/^void ProbeParticle<Engine>::upload_cache()$/;"	f	class:simpla::ProbeParticle
use_case	core/task_flow/use_case.h	/^namespace simpla { namespace use_case$/;"	n	namespace:simpla
v	applications/fokker_planck/lhw.cpp	/^		Vec3 v;$/;"	m	struct:PICDeltaF::Point_s	file:
v	applications/particle_solver/pic_engine_deltaf2.h	/^		Vec3 v;$/;"	m	struct:simpla::PICEngineDeltaF::Point_s
v	applications/particle_solver/pic_engine_fullf.h	/^		vector_type v;$/;"	m	struct:simpla::PICEngineFullF::Point_s
v	applications/particle_solver/pic_engine_ggauge.h	/^		Vec3 v;$/;"	m	struct:simpla::PICEngineGGauge::Point_s
v	applications/particle_solver/pic_engine_implicit.h	/^		Vec3 v;$/;"	m	struct:simpla::PICEngineImplicit::Point_s
v	core/geometry/obsolete/polygons.h	/^	vec v;$/;"	m	struct:__anon2
vA	core/gtl/test/ntuple_perf_test.cpp	/^	type vA, vB, vC, vD;$/;"	m	class:nTuplePerf1	file:
vA	core/gtl/test/ntuple_perf_test.cpp	/^	type vA, vB, vC, vD;$/;"	m	class:nTuplePerf2	file:
vA	core/gtl/test/ntuple_reduce_test.cpp	/^	type vA, vB, vC, vD;$/;"	m	class:TestNtupleReduce	file:
vB	core/gtl/test/ntuple_perf_test.cpp	/^	type vA, vB, vC, vD;$/;"	m	class:nTuplePerf1	file:
vB	core/gtl/test/ntuple_perf_test.cpp	/^	type vA, vB, vC, vD;$/;"	m	class:nTuplePerf2	file:
vB	core/gtl/test/ntuple_reduce_test.cpp	/^	type vA, vB, vC, vD;$/;"	m	class:TestNtupleReduce	file:
vC	core/gtl/test/ntuple_perf_test.cpp	/^	type vA, vB, vC, vD;$/;"	m	class:nTuplePerf1	file:
vC	core/gtl/test/ntuple_perf_test.cpp	/^	type vA, vB, vC, vD;$/;"	m	class:nTuplePerf2	file:
vC	core/gtl/test/ntuple_reduce_test.cpp	/^	type vA, vB, vC, vD;$/;"	m	class:TestNtupleReduce	file:
vD	core/gtl/test/ntuple_perf_test.cpp	/^	type vA, vB, vC, vD;$/;"	m	class:nTuplePerf1	file:
vD	core/gtl/test/ntuple_perf_test.cpp	/^	type vA, vB, vC, vD;$/;"	m	class:nTuplePerf2	file:
vD	core/gtl/test/ntuple_reduce_test.cpp	/^	type vA, vB, vC, vD;$/;"	m	class:TestNtupleReduce	file:
vT_	applications/particle_solver/pic_engine_ggauge.h	/^	Real cmr_, T_, vT_;$/;"	m	class:simpla::PICEngineGGauge
v_dist_engine	core/particle/ParticleGenerator.h	/^    typedef VDist v_dist_engine;$/;"	t	struct:simpla::particle::ParticleGenerator
v_type	core/field/test/trash/field_vector_calculus_Cartesian_complex_test.cpp	/^typedef std::complex<Real> v_type;$/;"	t	file:
v_type	core/field/test/trash/field_vector_calculus_Cartesian_vec3_test.cpp	/^typedef nTuple<Real, 3> v_type;$/;"	t	file:
v_type	core/field/test/trash/field_vector_calculus_cylindrical_test.cpp	/^typedef Real v_type;$/;"	t	file:
value	core/geometry/CoordinateSystem.h	/^    static constexpr bool value = false;$/;"	m	struct:simpla::geometry::traits::is_homogeneous
value	core/geometry/CoordinateSystem.h	/^    static constexpr bool value = true;$/;"	m	struct:simpla::geometry::traits::is_homogeneous
value	core/geometry/CoordinateSystem.h	/^    static constexpr int value = 2;$/;"	m	struct:simpla::geometry::traits::dimension
value	core/geometry/CoordinateSystem.h	/^    static constexpr int value = 3;$/;"	m	struct:simpla::geometry::traits::dimension
value	core/geometry/CoordinateSystem.h	/^    static constexpr int value = N;$/;"	m	struct:simpla::geometry::traits::dimension
value	core/geometry/boost_gemetry_adapted.h	/^	static const order_selector value =$/;"	m	struct:boost::geometry::traits::point_order
value	core/geometry/boost_gemetry_adapted.h	/^	static constexpr closure_selector value =$/;"	m	struct:boost::geometry::traits::closure
value	core/geometry/chains.h	/^    static constexpr bool value = false;$/;"	m	struct:simpla::geometry::traits::is_primitive
value	core/geometry/chains.h	/^    static constexpr bool value = mpl::find_type_in_list<tags::is_structed,$/;"	m	struct:simpla::geometry::traits::is_structed
value	core/geometry/chains.h	/^    static constexpr bool value = true;$/;"	m	struct:simpla::geometry::traits::is_chains
value	core/geometry/chains.h	/^    static constexpr int value =$/;"	m	struct:simpla::geometry::traits::closure
value	core/geometry/chains.h	/^    static constexpr int value =$/;"	m	struct:simpla::geometry::traits::point_order
value	core/geometry/chains.h	/^    static constexpr size_t value = dimension<PrimitiveType>::value;$/;"	m	struct:simpla::geometry::traits::dimension
value	core/geometry/cube.h	/^	static constexpr size_t value = number_of_points<$/;"	m	struct:simpla::geometry::traits::number_of_points
value	core/geometry/primitive.h	/^    static constexpr bool value = false;$/;"	m	struct:simpla::geometry::traits::is_chains
value	core/geometry/primitive.h	/^    static constexpr bool value = true;$/;"	m	struct:simpla::geometry::traits::is_primitive
value	core/geometry/primitive.h	/^    static constexpr size_t value = 1;$/;"	m	struct:simpla::geometry::traits::number_of_points
value	core/geometry/primitive.h	/^    static constexpr size_t value = 2;$/;"	m	struct:simpla::geometry::traits::number_of_points
value	core/geometry/primitive.h	/^    static constexpr size_t value = Dimension;$/;"	m	struct:simpla::geometry::traits::dimension
value	core/geometry/primitive_ext.h	/^    static constexpr size_t value = 5;$/;"	m	struct:simpla::geometry::traits::number_of_vertices
value	core/geometry/primitive_ext.h	/^    static constexpr size_t value = 6;$/;"	m	struct:simpla::geometry::traits::number_of_vertices
value	core/geometry/simplex.h	/^	static constexpr size_t value = N + 1;$/;"	m	struct:simpla::geometry::traits::number_of_points
value	core/gtl/check_concept.h	/^	static constexpr bool value = false;$/;"	m	struct:simpla::traits::is_shared_ptr
value	core/gtl/check_concept.h	/^	static constexpr bool value = true;$/;"	m	struct:simpla::traits::is_shared_ptr
value	core/gtl/check_concept.h	/^	static constexpr bool value =$/;"	m	struct:simpla::traits::is_callable
value	core/gtl/check_concept.h	/^	static constexpr bool value =$/;"	m	struct:simpla::traits::is_indexable
value	core/gtl/check_concept.h	/^	static constexpr bool value =$/;"	m	struct:simpla::traits::is_iterator
value	core/gtl/complex.h	/^	static constexpr bool value = false;$/;"	m	struct:simpla::is_complex
value	core/gtl/complex.h	/^	static constexpr bool value = true;$/;"	m	struct:simpla::is_arithmetic_scalar
value	core/gtl/complex.h	/^	static constexpr bool value = true;$/;"	m	struct:simpla::is_complex
value	core/gtl/concept_check.h	/^	static constexpr bool value =$/;"	m	struct:simpla::is_callable
value	core/gtl/concept_check.h	/^	static constexpr bool value =$/;"	m	struct:simpla::is_indexable
value	core/gtl/expression_template.h	/^    static constexpr bool value = false;$/;"	m	struct:simpla::traits::is_expresson
value	core/gtl/expression_template.h	/^    static constexpr bool value = true;$/;"	m	struct:simpla::traits::is_expresson
value	core/gtl/expression_template.h	/^    value_type value;$/;"	m	struct:simpla::Constant
value	core/gtl/integer_sequence.h	/^    static constexpr Tp value = 0;$/;"	m	struct:simpla::mpl::seq_get
value	core/gtl/integer_sequence.h	/^    static constexpr Tp value = M;$/;"	m	struct:simpla::mpl::seq_get
value	core/gtl/integer_sequence.h	/^    static constexpr Tp value =$/;"	m	struct:simpla::mpl::seq_get
value	core/gtl/mpl.h	/^	static constexpr bool value = false;$/;"	m	struct:simpla::mpl::find_type_in_list
value	core/gtl/mpl.h	/^	static constexpr bool value = find_type_in_list<T, U>::value$/;"	m	struct:simpla::mpl::find_type_in_list
value	core/gtl/mpl.h	/^	static constexpr bool value = std::is_same<T, U>::value;$/;"	m	struct:simpla::mpl::find_type_in_list
value	core/gtl/ntuple.h	/^    static constexpr bool value = false;$/;"	m	struct:simpla::traits::is_ntuple
value	core/gtl/ntuple.h	/^    static constexpr bool value = true;$/;"	m	struct:simpla::traits::is_ntuple
value	core/gtl/primitives.h	/^    static constexpr bool value = (std::is_arithmetic<TL>::value$/;"	m	struct:simpla::is_arithmetic_scalar
value	core/gtl/primitives.h	/^    static constexpr bool value = false;$/;"	m	struct:simpla::has_PlaceHolder
value	core/gtl/primitives.h	/^    static constexpr bool value = false;$/;"	m	struct:simpla::is_expression
value	core/gtl/primitives.h	/^    static constexpr bool value = false;$/;"	m	struct:simpla::is_real
value	core/gtl/primitives.h	/^    static constexpr bool value = is_arithmetic_scalar<T>::value;$/;"	m	struct:simpla::is_primitive
value	core/gtl/primitives.h	/^    static constexpr bool value = true;$/;"	m	struct:simpla::is_real
value	core/gtl/sp_complex.h	/^	static constexpr bool value = false;$/;"	m	struct:simpla::is_complex
value	core/gtl/sp_complex.h	/^	static constexpr bool value = true;$/;"	m	struct:simpla::is_arithmetic_scalar
value	core/gtl/sp_complex.h	/^	static constexpr bool value = true;$/;"	m	struct:simpla::is_complex
value	core/gtl/type_traits.h	/^    static constexpr _Tp value[] = {N...};$/;"	m	struct:simpla::traits::seq_value
value	core/gtl/type_traits.h	/^    static constexpr int value = sizeof...(N);$/;"	m	struct:simpla::traits::extent
value	core/gtl/type_traits.h	/^constexpr _Tp seq_value<integer_sequence<_Tp, N...> >::value[];$/;"	m	class:simpla::traits::seq_value
value	core/gtl/type_traits_ext.h	/^	static constexpr TI value = L > R ? L : R;$/;"	m	struct:simpla::sp_max
value	core/gtl/utilities/lua_object.cpp	/^std::pair<LuaObject, LuaObject> LuaObject::iterator::value() const$/;"	f	class:simpla::lua::LuaObject::iterator
value	core/gtl/utilities/lua_object.h	/^    static constexpr bool value = true;$/;"	m	struct:simpla::check::is_callable
value	core/gtl/utilities/lua_object.h	/^    static constexpr bool value = true;$/;"	m	struct:simpla::check::is_indexable
value	core/io/XDMFIO.h	/^    static const int value = XDMF_UNKNOWN_TYPE;$/;"	m	struct:simpla::io::XdmfTypeTraits
value_	core/gtl/utilities/lua_object.h	/^        int value_;$/;"	m	class:simpla::lua::LuaObject::iterator
value_conatinaer_type	core/gtl/containers/sp_indirect_container.h	/^	typedef ValueContiner value_conatinaer_type;$/;"	t	struct:simpla::indirect_container
value_container_type	core/gtl/iterator/sp_indirect_iterator.h	/^    typedef ValueContainer value_container_type;$/;"	t	struct:simpla::sp_indirect_range
value_in_range	core/gtl/ntuple.h	/^bool value_in_range(T0 const &b, T1 const &e, T2 const &x)$/;"	f	namespace:simpla
value_in_range	core/gtl/ntuple.h	/^struct value_in_range<>$/;"	s	namespace:simpla::_impl
value_in_range	core/gtl/ntuple.h	/^struct value_in_range<N, DIMS...>$/;"	s	namespace:simpla::_impl
value_type	core/base/Attribute.h	/^    typedef TV value_type;$/;"	t	class:simpla::base::Attribute
value_type	core/data_model/data_view.h	/^	typedef TV value_type;$/;"	t	struct:simpla::data_view
value_type	core/field/FieldDense.h	/^    typedef TV value_type;$/;"	t	class:simpla::Field
value_type	core/field/FieldDense.h	/^struct value_type<Field<TV, Policies...>>$/;"	s	namespace:simpla::traits
value_type	core/field/FieldExpression.h	/^    typedef traits::value_type_t<TL> value_type;$/;"	t	struct:simpla::Field
value_type	core/field/FieldExpression.h	/^struct value_type<Field<BooleanExpression<TOP, T...> > >$/;"	s	namespace:simpla::traits
value_type	core/field/FieldExpression.h	/^struct value_type<Field<Expression<TOP, T...> > >$/;"	s	namespace:simpla::traits
value_type	core/field/FieldFunction.h	/^    typedef TV value_type;$/;"	t	class:simpla::Field
value_type	core/field/obsoleted/field_constant.h	/^	typedef TV value_type;$/;"	t	class:simpla::Field
value_type	core/field/obsoleted/field_patch.h	/^    typedef typename field_type::value_type value_type;$/;"	t	class:simpla::FieldAMRPolicy
value_type	core/field/obsoleted/field_sparse.h	/^	typedef TV value_type;$/;"	t	struct:simpla::Field
value_type	core/field/test/field_basic_algebra_test.h	/^    typedef traits::value_type_t<field_type> value_type;$/;"	t	class:TestField
value_type	core/field/test/field_diff_calculus_test.h	/^    typedef Real value_type;$/;"	t	class:FETLTest
value_type	core/field/test/field_dummy.cpp	/^	typedef TV value_type;$/;"	t	class:FieldTest	file:
value_type	core/field/test/field_io_test.h	/^	typedef typename TParam::value_type value_type;$/;"	t	class:simpla::TestFieldIO
value_type	core/field/test/trash/fetl_test2.h	/^	typedef typename TField::value_type value_type;$/;"	t	class:TestField
value_type	core/field/test/trash/fetl_test3.h	/^	typedef Real value_type;$/;"	t	class:TestFETL
value_type	core/field/test/trash/field_basic_test.h	/^	typedef typename field_type::value_type value_type;$/;"	t	class:TestField
value_type	core/field/test/trash/field_continue.h	/^	typedef typename container_type::value_type value_type;$/;"	t	struct:simpla::Field
value_type	core/geometry/boost_gemetry_adapted.h	/^			decltype((simpla::traits::get<M,Index>( (std::declval<Geo>()))))>::type value_type;$/;"	t	struct:boost::geometry::traits::indexed_access
value_type	core/geometry/boost_gemetry_adapted.h	/^			decltype((simpla::traits::get<M>( (std::declval<Geo>()))))>::type value_type;$/;"	t	struct:boost::geometry::traits::access
value_type	core/geometry/primitive.h	/^    typedef typename simpla::geometry::traits::coordinate_type<CoordinateSystem>::type value_type;$/;"	t	struct:simpla::geometry::model::CoVector
value_type	core/geometry/primitive.h	/^    typedef typename simpla::geometry::traits::coordinate_type<CoordinateSystem>::type value_type;$/;"	t	struct:simpla::geometry::model::Primitive
value_type	core/geometry/primitive.h	/^    typedef typename simpla::geometry::traits::coordinate_type<CoordinateSystem>::type value_type;$/;"	t	struct:simpla::geometry::model::Vector
value_type	core/geometry/primitive.h	/^struct value_type<model::Primitive<Dimension, CoordinateSystem, Tag>>$/;"	s	namespace:simpla::geometry::traits
value_type	core/geometry/test/geometry_test.cpp	/^	typedef Real value_type;$/;"	t	class:TestModel	file:
value_type	core/gtl/array_view.h	/^    typedef T value_type;$/;"	t	class:simpla::gtl::ArrayView
value_type	core/gtl/containers/UnorderedSet.h	/^    typedef ValueType value_type;$/;"	t	class:simpla::gtl::UnorderedSet
value_type	core/gtl/containers/container_container.h	/^	typedef SubContainer<TV> value_type;$/;"	t	class:simpla::ContainerContainer
value_type	core/gtl/containers/container_dense.h	/^	typedef TV value_type;$/;"	t	class:simpla::DenseContainer
value_type	core/gtl/containers/container_pool.h	/^	typedef ValueType value_type;$/;"	t	struct:simpla::ContainerPool
value_type	core/gtl/containers/container_save_cache.h	/^	typedef TV value_type;$/;"	t	class:simpla::ContainerSaveCache
value_type	core/gtl/containers/container_sparse.h	/^    typedef TV value_type;$/;"	t	class:simpla::SparseContainer
value_type	core/gtl/containers/container_traits.h	/^	typedef TV value_type;$/;"	t	struct:simpla::container_traits
value_type	core/gtl/containers/container_traits.h	/^	typedef typename TContainer::mapped_type value_type;$/;"	t	struct:simpla::container_traits
value_type	core/gtl/containers/sp_hash_container.h	/^	typedef Value value_type;$/;"	t	struct:simpla::SpHashContainer
value_type	core/gtl/containers/sp_indirect_container.h	/^	typedef typename value_conatinaer_type::value_type value_type;$/;"	t	struct:simpla::indirect_container
value_type	core/gtl/containers/sp_ndarray.h	/^	typedef T value_type;$/;"	t	class:simpla::ndArray
value_type	core/gtl/containers/unordered_set.h	/^    typedef T value_type;$/;"	t	class:simpla::UnorderedSet
value_type	core/gtl/function_cache.h	/^	typedef RectValue value_type;$/;"	t	struct:simpla::FunctionCache
value_type	core/gtl/iterator/indirect_iterator.h	/^	typedef typename std::iterator_traits<base_iterator>::value_type value_type;$/;"	t	struct:simpla::indirect_iterator
value_type	core/gtl/iterator/iterator.h	/^	typedef typename iterator::value_type value_type;$/;"	t	struct:std::iterator_traits
value_type	core/gtl/iterator/iterator_sequence.h	/^	typedef TI value_type;$/;"	t	class:simpla::IteratorSequence
value_type	core/gtl/iterator/sp_indirect_iterator.h	/^    typedef typename container_traits<container_type>::value_type value_type;$/;"	t	struct:simpla::sp_indirect_iterator
value_type	core/gtl/iterator/sp_iterator.h	/^	typedef T value_type;$/;"	t	class:simpla::sp_back_insert_iterator
value_type	core/gtl/iterator/sp_iterator_mapped.h	/^	typedef typename conatiner_type::mapped_type value_type;$/;"	t	struct:simpla::Iterator
value_type	core/gtl/iterator/sp_iterator_mapped.h	/^	typename std::remove_pointer<conatiner_type>::type, typename conatiner_type::value_type>::type value_type;$/;"	t	struct:simpla::Iterator
value_type	core/gtl/iterator/sp_iterator_shared_container.h	/^	typedef T value_type;$/;"	t	struct:simpla::_impl::StorageSharedContainer
value_type	core/gtl/iterator/sp_iterator_shared_container.h	/^	typedef typename ContainerTraits<T>::value_type value_type;$/;"	t	struct:simpla::_impl::StorageSharedContainer
value_type	core/gtl/iterator/sp_iterator_shared_container.h	/^	typedef typename ContainerTraits<conatiner_type>::value_type value_type;$/;"	t	class:simpla::TransformIterator
value_type	core/gtl/iterator/sp_ntuple_range.h	/^    typedef nTuple<IndexType, DIMS...> value_type;$/;"	t	struct:simpla::sp_nTuple_range
value_type	core/gtl/iterator/sp_range_filter.h	/^	typedef decltype(*std::declval<base_iterator>()) value_type;$/;"	t	struct:simpla::FilterRange
value_type	core/gtl/ntuple.h	/^    typedef TV value_type;$/;"	t	struct:simpla::nTuple
value_type	core/gtl/ntuple.h	/^struct value_type<nTuple<BooleanExpression<TOP, T...> > >$/;"	s	namespace:simpla::traits
value_type	core/gtl/ntuple.h	/^struct value_type<nTuple<Expression<TOP, T...> > >$/;"	s	namespace:simpla::traits
value_type	core/gtl/ntuple.h	/^struct value_type<nTuple<TV, N, M...> >$/;"	s	namespace:simpla::traits
value_type	core/gtl/test/ntuple_perf_test.cpp	/^	typedef T value_type;$/;"	t	class:nTuplePerf1	file:
value_type	core/gtl/test/ntuple_perf_test.cpp	/^	typedef T value_type;$/;"	t	class:nTuplePerf2	file:
value_type	core/gtl/test/ntuple_reduce_test.cpp	/^	typedef traits::value_type_t<type> value_type;$/;"	t	class:TestNtupleReduce	file:
value_type	core/gtl/type_traits.h	/^struct value_type$/;"	s	namespace:simpla::traits
value_type	core/gtl/type_traits.h	/^struct value_type<integer_sequence<_Tp, N...> >$/;"	s	namespace:simpla::traits
value_type	core/gtl/type_traits.h	/^struct value_type<std::string>$/;"	s	namespace:simpla::traits
value_type	core/gtl/utilities/lua_object_ext.h	/^    typedef Properties value_type;$/;"	t	struct:simpla::lua::Converter
value_type	core/gtl/utilities/lua_object_ext.h	/^    typedef T value_type;$/;"	t	struct:simpla::lua::Converter
value_type	core/gtl/utilities/lua_object_ext.h	/^    typedef nTuple<T, N, M...> value_type;$/;"	t	struct:simpla::lua::Converter
value_type	core/gtl/utilities/lua_object_ext.h	/^    typedef nTuple<T, N> value_type;$/;"	t	struct:simpla::lua::Converter
value_type	core/gtl/utilities/lua_object_ext.h	/^    typedef std::complex<T> value_type;$/;"	t	struct:simpla::lua::Converter
value_type	core/gtl/utilities/lua_object_ext.h	/^    typedef std::list<T> value_type;$/;"	t	struct:simpla::lua::Converter
value_type	core/gtl/utilities/lua_object_ext.h	/^    typedef std::map<T1, T2> value_type;$/;"	t	struct:simpla::lua::Converter
value_type	core/gtl/utilities/lua_object_ext.h	/^    typedef std::pair<T1, T2> value_type;$/;"	t	struct:simpla::lua::Converter
value_type	core/gtl/utilities/lua_object_ext.h	/^    typedef std::string value_type;$/;"	t	struct:simpla::lua::Converter
value_type	core/gtl/utilities/lua_object_ext.h	/^    typedef std::tuple<T...> value_type;$/;"	t	struct:simpla::lua::Converter
value_type	core/gtl/utilities/lua_object_ext.h	/^    typedef std::vector<T> value_type;$/;"	t	struct:simpla::lua::Converter
value_type	core/io/WriteBuffer.h	/^    typedef T value_type;$/;"	t	class:simpla::io::WriteBufferProxy
value_type	core/manifold/Calculus.h	/^struct value_type<Field<Expression<calculus::tags::CodifferentialDerivative, T> > >$/;"	s	namespace:simpla::traits
value_type	core/manifold/Calculus.h	/^struct value_type<Field<Expression<calculus::tags::Cross, T0, T1> > >$/;"	s	namespace:simpla::traits
value_type	core/manifold/Calculus.h	/^struct value_type<Field<Expression<calculus::tags::Dot, T0, T1> > >$/;"	s	namespace:simpla::traits
value_type	core/manifold/Calculus.h	/^struct value_type<Field<Expression<calculus::tags::ExteriorDerivative, T> > >$/;"	s	namespace:simpla::traits
value_type	core/manifold/Calculus.h	/^struct value_type<Field<Expression<calculus::tags::HodgeStar, T> > >$/;"	s	namespace:simpla::traits
value_type	core/manifold/Calculus.h	/^struct value_type<Field<Expression<calculus::tags::InteriorProduct, T0, T1> > >$/;"	s	namespace:simpla::traits
value_type	core/manifold/Calculus.h	/^struct value_type<Field<Expression<calculus::tags::MapTo, Field<nTuple<TV, 3>, TM, std::integral_constant<int, VERTEX>, Others...>,$/;"	s	namespace:simpla::traits
value_type	core/manifold/Calculus.h	/^struct value_type<Field<Expression<calculus::tags::MapTo, T, Others...> > >$/;"	s	namespace:simpla::traits
value_type	core/manifold/Calculus.h	/^struct value_type<Field<Expression<calculus::tags::MapTo, T, std::integral_constant<int, VERTEX>>> >$/;"	s	namespace:simpla::traits
value_type	core/manifold/Calculus.h	/^struct value_type<Field<Expression<calculus::tags::MapTo, T, std::integral_constant<int, VOLUME>>> >$/;"	s	namespace:simpla::traits
value_type	core/manifold/Calculus.h	/^struct value_type<Field<Expression<calculus::tags::Wedge, T0, T1> > >$/;"	s	namespace:simpla::traits
value_type	core/manifold/obsoleted/patch/mesh_patch.h	/^    typedef TV value_type;$/;"	t	class:simpla::mesh::PatchPolicy
value_type	core/model/test/model_test.cpp	/^	typedef Real value_type;$/;"	t	class:TestModel	file:
value_type	core/numeric/compound_distribution.h	/^    std::tuple<traits::value_type_t< Dist>...> value_type;$/;"	m	struct:simpla::compound_distribution
value_type	core/numeric/interpolation.h	/^    typedef TV value_type;$/;"	t	class:simpla::Interpolation
value_type	core/numeric/interpolation.h	/^    typedef TV value_type;$/;"	t	class:simpla::MultiDimesionInterpolation
value_type	core/numeric/rectangle_distribution.h	/^    typedef nTuple <Real, NDIMS> value_type;$/;"	t	class:simpla::rectangle_distribution
value_type	core/parallel/obsoleted/blocked_range.h	/^	typedef T value_type;$/;"	t	struct:simpla::BlockedRange
value_type	core/parallel/obsoleted/blocked_range.h	/^	typedef id_type value_type;$/;"	t	struct:simpla::iterator
value_type	core/particle/ParticleContainer.h	/^    typedef sample_type value_type;$/;"	t	struct:simpla::particle::ParticleContainer
value_type	core/particle/ParticleGenerator.h	/^    typedef TV value_type;$/;"	t	struct:simpla::particle::ParticleGenerator
value_type	core/particle/ParticleTracker.h	/^    typedef typename P::sample_type value_type;$/;"	t	class:simpla::particle::enable_tracking
value_type	core/particle/obsolete/kinetic_particle.h	/^    typedef TPoint_s value_type;$/;"	t	struct:simpla::_impl::particle_hasher
vec	core/geometry/obsolete/polygons.h	/^} vec_t, *vec;$/;"	t	typeref:struct:__anon1
vec_t	core/geometry/obsolete/polygons.h	/^} vec_t, *vec;$/;"	t	typeref:struct:__anon1
vector_type	applications/particle_solver/pic_engine_deltaf.h	/^	typedef Vec3 vector_type;$/;"	t	struct:simpla::ParticleEngine
vector_type	applications/particle_solver/pic_engine_fullf.h	/^	typedef Vec3 vector_type;$/;"	t	class:simpla::PICEngineFullF
vector_type	applications/particle_solver/pic_engine_implicit.h	/^	typedef Vec3 vector_type;$/;"	t	struct:simpla::PICEngineImplicit
vector_type	core/geometry/CoordinateSystem.h	/^struct vector_type$/;"	s	namespace:simpla::geometry::traits
vector_type	core/geometry/GeoObject.h	/^    typedef nTuple<Real, 3> vector_type;$/;"	t	class:simpla::geometry::GeoObject
vector_type	core/geometry/csCartesian.h	/^    typedef nTuple<scalar_type, 3> vector_type;$/;"	t	struct:simpla::geometry::CartesianMetric
vector_type	core/geometry/csCylindrical.h	/^    typedef nTuple<scalar_type, 3> vector_type;$/;"	t	struct:simpla::geometry::Metric
vector_type	core/geometry/model.h	/^	typedef typename traits::vector_type<CS>::type vector_type;$/;"	t	struct:simpla::geometry::model::Primitive
vector_type	core/manifold/mesh/CoRectMesh.h	/^    typedef typename metric_type::vector_type vector_type;$/;"	t	struct:simpla::mesh::Mesh
vector_type	core/manifold/mesh/MeshIds.h	/^    typedef nTuple<Real, ndims> vector_type;$/;"	t	struct:simpla::mesh::MeshEntityIdCoder
vector_type	core/manifold/obsoleted/fiber_bundle.h	/^    typedef Vec3 vector_type;$/;"	t	class:simpla::manifold::FiberBundle
vector_type	core/manifold/obsoleted/fiber_bundle.h	/^    typedef mesh_type::vector_type vector_type;$/;"	t	struct:simpla::manifold::DirectMap
vector_type	core/particle/ParticleTracker.h	/^    typedef typename P::vector_type vector_type;$/;"	t	class:simpla::particle::enable_tracking
vector_type	core/particle/obsolete/simple_particle.h	/^	typedef nTuple<scalar_type, 3> vector_type;$/;"	t	struct:simpla::SimpleParticleEngine
vector_type	core/particle/pre_define/GuidingCenter.h	/^    typedef typename geometry::CylindricalMetric::vector_type vector_type;$/;"	t	struct:simpla::particle::engine::GuidingCenterEngine
vector_type	core/particle/pre_define/PICBoris.h	/^    typedef typename mesh_type::vector_type vector_type;$/;"	t	struct:simpla::particle::engine::BorisEngine
vector_type	core/particle/pre_define/PICGyro.h	/^    typedef typename mesh_type::vector_type vector_type;$/;"	t	struct:simpla::particle::engine::GyroParticleWithCylindricalCoord
vector_type	core/phy_solver/em_fluid.h	/^    typedef nTuple<scalar_type, 3> vector_type;$/;"	t	class:simpla::phy_solver::EMFluid
vector_type	example/em_tokamak/tokamak.cpp	/^    typedef nTuple<scalar_type, 3> vector_type;$/;"	t	struct:simpla::EMTokamak	file:
vector_type	example/pic/demo_pic.h	/^	typedef Vec3 vector_type;$/;"	t	struct:simpla::FiberBundle
vector_type	example/probe_particle/demo_probe_particle.h	/^	typedef Vec3 vector_type;$/;"	t	struct:simpla::ProbeDemo
vertex_boundary	core/phy_solver/em_fluid.h	/^    model::IdSet<mesh_type> vertex_boundary;$/;"	m	class:simpla::phy_solver::EMFluid
vertex_boundary	example/em_tokamak/tokamak.cpp	/^    model::IdSet<mesh_type> vertex_boundary;$/;"	m	struct:simpla::EMTokamak	file:
vertex_type	core/geometry/primitive.h	/^    typedef typename traits::point_type<this_type>::type vertex_type;$/;"	t	struct:simpla::geometry::model::Primitive
vfield_type	core/field/test/trash/field_simple_mesh_shared_ptr_test.cpp	/^typedef Field<SimpleMesh, std::shared_ptr<nTuple<double, 3> > > vfield_type;$/;"	t	file:
visit	core/gtl/design_pattern/visitor.h	/^    void visit(AcceptorBase &obj)$/;"	f	struct:simpla::Visitor
visit	core/gtl/design_pattern/visitor.h	/^    void visit(void *p) const { visit_(p); }$/;"	f	struct:simpla::VisitorBase
visit	core/task_flow/task.h	/^    virtual void visit(ContextBase &ctx)$/;"	f	class:simpla::task_flow::Task
visit	core/task_flow/task.h	/^    virtual void visit(context_type &ctx) { UNIMPLEMENTED; }$/;"	f	class:simpla::task_flow::Task
visit	core/task_flow/task_flow_base.h	/^    virtual void visit(ContextBase &ctx) { };$/;"	f	struct:simpla::task_flow::TaskBase
volume	core/geometry/cube.h	/^typename traits::volume_type<CS>::type volume($/;"	f	namespace:simpla::geometry
volume	core/geometry/simplex.h	/^typename traits::volume_type<CS>::type volume($/;"	f	namespace:simpla::geometry
volume	core/manifold/mesh/CartesianCoRect.h	/^    virtual Real volume(id_type s) const { return m_volume_[node_id(s)]; }$/;"	f	struct:simpla::mesh::CartesianCoRect
volume	core/manifold/mesh/CoRectMesh.h	/^    virtual Real volume(id_type s) const { return m_volume_[node_id(s)]; }$/;"	f	struct:simpla::mesh::Mesh
volume	core/manifold/mesh/CylindricalCoRect.h	/^    virtual Real volume(id_type s) const$/;"	f	class:simpla::mesh::CylindricalCoRect
volume	core/manifold/mesh/RectMesh.h	/^    virtual Real volume(id_type s) const$/;"	f	struct:simpla::mesh::Mesh
volume_type	core/geometry/primitive.h	/^template<typename CS> struct volume_type$/;"	s	namespace:simpla::geometry::traits
vsub	core/geometry/obsolete/polygons.h	/^inline vec vsub(vec a, vec b, vec res)$/;"	f
vtkAMRSimPlaParticlesReader	plugins/vtk_reader/vtkAMRSimPlaParticlesReader.cpp	/^vtkAMRSimPlaParticlesReader::vtkAMRSimPlaParticlesReader() : m_pimpl_(new pimpl_s)$/;"	f	class:vtkAMRSimPlaParticlesReader
vtkAMRSimPlaParticlesReader	plugins/vtk_reader/vtkAMRSimPlaParticlesReader.cpp	/^vtkStandardNewMacro(vtkAMRSimPlaParticlesReader);$/;"	v
vtkAMRSimPlaParticlesReader	plugins/vtk_reader/vtkAMRSimPlaParticlesReader.h	/^class vtkAMRSimPlaParticlesReader :$/;"	c
vtkAMRSimPlaReader	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^vtkAMRSimPlaReader::vtkAMRSimPlaReader() : m_pimpl_(new pimpl_s)$/;"	f	class:vtkAMRSimPlaReader
vtkAMRSimPlaReader	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^vtkStandardNewMacro(vtkAMRSimPlaReader);$/;"	v
vtkAMRSimPlaReader	plugins/vtk_reader/vtkAMRSimPlaReader.h	/^class VTKIOAMR_EXPORT vtkAMRSimPlaReader : public vtkAMRBaseReader$/;"	c
vtkAMRSimPlaReaderBlock	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^    vtkAMRSimPlaReaderBlock() { this->Init(); }$/;"	f	class:vtkAMRSimPlaReaderBlock
vtkAMRSimPlaReaderBlock	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^    vtkAMRSimPlaReaderBlock(const vtkAMRSimPlaReaderBlock &other) { this->DeepCopy(&other); }$/;"	f	class:vtkAMRSimPlaReaderBlock
vtkAMRSimPlaReaderBlock	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^class vtkAMRSimPlaReaderBlock$/;"	c	file:
w	applications/fokker_planck/lhw.cpp	/^		scalar_type w;$/;"	m	struct:PICDeltaF::Point_s	file:
w	applications/particle_solver/pic_engine_deltaf2.h	/^		scalar_type w;$/;"	m	struct:simpla::PICEngineDeltaF::Point_s
w	applications/particle_solver/pic_engine_ggauge.h	/^		nTuple<NMATE, scalar_type> w;$/;"	m	struct:simpla::PICEngineGGauge::Point_s
wait	core/parallel/DistributedObject.cpp	/^void DistributedObject::wait()$/;"	f	class:simpla::parallel::DistributedObject
wait	core/parallel/obsoleted/distributed_unordered_set.h	/^void Distributed<UnorderedSet<TV, Others...>>::wait()$/;"	f	class:simpla::Distributed
wait	core/parallel/obsoleted/parallel_traits.h	/^template<typename ...T> void wait(T &&...) { }$/;"	f	namespace:simpla::parallel
wait	core/parallel/trash/distributed_unordered_set.cpp	/^void DistributedUnorderedSetBase::wait() const$/;"	f	class:simpla::DistributedUnorderedSetBase
within	core/geometry/GeoObject.h	/^    inline int within(int num, point_type const *p_tuple) const$/;"	f	class:simpla::geometry::GeoObject
within	core/geometry/GeoObject.h	/^    inline int within(point_type const &b, Others &&...others) const$/;"	f	class:simpla::geometry::GeoObject
within	core/geometry/GeoObject.h	/^    inline int within(std::tuple<Others...> const &p_tuple) const$/;"	f	class:simpla::geometry::GeoObject
within	core/geometry/polygon.cpp	/^int  Polygon<2>::within(point_type const &p) const$/;"	f	class:simpla::geometry::Polygon
write	core/io/HDF5Stream.cpp	/^std::string HDF5Stream::write(std::string const &url, data_model::DataSet const &ds, size_t flag)$/;"	f	class:simpla::io::HDF5Stream
write	core/io/IO.cpp	/^std::string write(std::string const &url, data_model::DataSet const &ds, size_t flag)$/;"	f	namespace:simpla::io
write	core/io/IO.h	/^std::string write(std::string const &url, T const &d, size_t flag = 0UL)$/;"	f	namespace:simpla::io
write	core/io/IO.h	/^std::string write(std::string const &url, size_t num, T const *d, size_t flag = 0UL)$/;"	f	namespace:simpla::io
write	core/io/WriteBuffer.cpp	/^std::string WriteBuffer::write(bool is_flush)$/;"	f	class:simpla::io::WriteBuffer
write	core/io/WriteBuffer.h	/^    std::string write(TI const &b, TI const &e)$/;"	f	class:simpla::io::WriteBufferProxy
write	core/io/XDMFStream.cpp	/^void XDMFStream::write(std::string const &ds_name, data_model::DataSet const &ds)$/;"	f	class:simpla::io::XDMFStream
write	core/io/XDMFStream.cpp	/^void XDMFStream::write(std::string const &ds_name,$/;"	f	class:simpla::io::XDMFStream
write	core/model/GEqdsk.cpp	/^void GEqdsk::pimpl_s::write(std::string const &url)$/;"	f	class:simpla::GEqdsk::pimpl_s
write	core/model/GEqdsk.cpp	/^void GEqdsk::write(std::string const &url)$/;"	f	class:simpla::GEqdsk
write_buffer	core/io/HDF5Stream.cpp	/^std::string HDF5Stream::write_buffer(std::string const &url, bool is_forced_flush)$/;"	f	class:simpla::io::HDF5Stream
write_geqdsk	scripts/geqdsk.py	/^def write_geqdsk(filename):$/;"	f
write_lock_	core/gtl/containers/container_container.h	/^	std::mutex write_lock_;$/;"	m	class:simpla::ContainerContainer
write_lock_	core/gtl/containers/container_dense.h	/^	std::mutex write_lock_;$/;"	m	class:simpla::DenseContainer
write_lock_	core/gtl/containers/container_sparse.h	/^    std::mutex write_lock_;$/;"	m	class:simpla::SparseContainer
write_to	scripts/PreProcess/input_geqdsk.py	/^    def write_to(self,f):$/;"	m	class:GEQDSK
writer	scripts/animation.py	/^writer =animation.FFMpegWriter(fps=30, metadata=metadata)$/;"	v
x	applications/fokker_planck/lhw.cpp	/^		coordinate_tuple x;$/;"	m	struct:PICDeltaF::Point_s	file:
x	applications/particle_solver/pic_engine_deltaf2.h	/^		coordinate_tuple x;$/;"	m	struct:simpla::PICEngineDeltaF::Point_s
x	applications/particle_solver/pic_engine_fullf.h	/^		coordinate_tuple x;$/;"	m	struct:simpla::PICEngineFullF::Point_s
x	applications/particle_solver/pic_engine_ggauge.h	/^		coordinate_tuple x;$/;"	m	struct:simpla::PICEngineGGauge::Point_s
x	applications/particle_solver/pic_engine_implicit.h	/^		coordinate_tuple x;$/;"	m	struct:simpla::PICEngineImplicit::Point_s
x	core/geometry/obsolete/geometry_object.h	/^	Real x, y, z;$/;"	m	struct:simpla::geometry_object::Sphere
x	core/geometry/obsolete/line_cliping.h	/^		double x, y;$/;"	m	struct:simpla::polygon_clip::pnt2d
x	core/geometry/obsolete/polygons.h	/^	double x, y;$/;"	m	struct:__anon1
x	scripts/PostProcesse/particle_time_scripts.py	/^x=f1["\/record\/H"][:,:][:,req_time,0]$/;"	v
x	scripts/PostProcesse/pv_prog_source.py	/^x=f1["\/record\/0\/H"][:]['p']['v']$/;"	v
x0	core/geometry/obsolete/geometry_object.h	/^	Real x0, y0, z0;$/;"	m	struct:simpla::geometry_object::Cylinder
x0	core/geometry/obsolete/geometry_object.h	/^	Real x0, y0, z0;$/;"	m	struct:simpla::geometry_object::Ring
x1	core/geometry/obsolete/geometry_object.h	/^	Real x1, y1, z1;$/;"	m	struct:simpla::geometry_object::Cylinder
x1	core/geometry/obsolete/geometry_object.h	/^	Real x1, y1, z1;$/;"	m	struct:simpla::geometry_object::Ring
x_dist_engine	core/particle/ParticleGenerator.h	/^    typedef XDist x_dist_engine;$/;"	t	struct:simpla::particle::ParticleGenerator
xmax	core/field/test/field_diff_calculus_test.h	/^    point_type xmin, xmax;$/;"	m	class:FETLTest
xmax	core/field/test/trash/fetl_test3.h	/^	nTuple<NDIMS, Real> xmax;$/;"	m	class:TestFETL
xmax	core/geometry/test/geometry_test.cpp	/^	nTuple<Real, ndims> xmax\/* = { 1.0, 2.0, 3.0 }*\/;$/;"	m	class:TestModel	file:
xmax	core/gtl/test/sp_iterator_test.cpp	/^	nTuple<3, Real> xmin, xmax;$/;"	m	class:TestIterator	file:
xmax	core/model/test/model_test.cpp	/^	nTuple<Real, ndims> xmax\/* = { 1.0, 2.0, 3.0 }*\/;$/;"	m	class:TestModel	file:
xmax	core/particle/test/kinetic_particle_test.h	/^	nTuple<Real, 3> xmin, xmax;$/;"	m	class:TestKineticParticle
xmax_	core/numeric/interpolation.h	/^    nTuple <Real, NDIMS> xmin_, xmax_, inv_dx_;$/;"	m	class:simpla::BiLinearInterpolation
xmax_	core/numeric/rectangle_distribution.h	/^    nTuple<double, NDIMS> xmax_;$/;"	m	class:simpla::rectangle_distribution
xmin	core/field/test/field_diff_calculus_test.h	/^    point_type xmin, xmax;$/;"	m	class:FETLTest
xmin	core/field/test/trash/fetl_test3.h	/^	nTuple<NDIMS, Real> xmin;$/;"	m	class:TestFETL
xmin	core/geometry/test/geometry_test.cpp	/^	nTuple<Real, ndims> xmin\/* = { 0.0, 0.0, 0.0, }*\/;$/;"	m	class:TestModel	file:
xmin	core/gtl/test/sp_iterator_test.cpp	/^	nTuple<3, Real> xmin, xmax;$/;"	m	class:TestIterator	file:
xmin	core/model/test/model_test.cpp	/^	nTuple<Real, ndims> xmin\/* = { 0.0, 0.0, 0.0, }*\/;$/;"	m	class:TestModel	file:
xmin	core/particle/test/kinetic_particle_test.h	/^	nTuple<Real, 3> xmin, xmax;$/;"	m	class:TestKineticParticle
xmin_	core/numeric/interpolation.h	/^    nTuple <Real, NDIMS> xmin_, xmax_, inv_dx_;$/;"	m	class:simpla::BiLinearInterpolation
xmin_	core/numeric/rectangle_distribution.h	/^    nTuple<double, NDIMS> xmin_;$/;"	m	class:simpla::rectangle_distribution
xn_	core/numeric/simplex_distribution.h	/^	std::vector<double> xn_;$/;"	m	class:simpla::simplex_distribution
y	core/geometry/obsolete/geometry_object.h	/^	Real x, y, z;$/;"	m	struct:simpla::geometry_object::Sphere
y	core/geometry/obsolete/line_cliping.h	/^		double x, y;$/;"	m	struct:simpla::polygon_clip::pnt2d
y	core/geometry/obsolete/polygons.h	/^	double x, y;$/;"	m	struct:__anon1
y	scripts/PostProcesse/particle_time_scripts.py	/^y=f1["\/record\/H"][:,:][:,req_time,1]$/;"	v
y0	core/geometry/obsolete/geometry_object.h	/^	Real x0, y0, z0;$/;"	m	struct:simpla::geometry_object::Cylinder
y0	core/geometry/obsolete/geometry_object.h	/^	Real x0, y0, z0;$/;"	m	struct:simpla::geometry_object::Ring
y1	core/geometry/obsolete/geometry_object.h	/^	Real x1, y1, z1;$/;"	m	struct:simpla::geometry_object::Cylinder
y1	core/geometry/obsolete/geometry_object.h	/^	Real x1, y1, z1;$/;"	m	struct:simpla::geometry_object::Ring
yes	core/gtl/check_concept.h	/^	typedef std::true_type yes;$/;"	t	struct:simpla::traits::is_callable
yes	core/gtl/check_concept.h	/^	typedef std::true_type yes;$/;"	t	struct:simpla::traits::is_indexable
yes	core/gtl/check_concept.h	/^	typedef std::true_type yes;$/;"	t	struct:simpla::traits::is_iterator
yes	core/gtl/concept_check.h	/^	typedef std::true_type yes;$/;"	t	struct:simpla::is_callable
yes	core/gtl/concept_check.h	/^	typedef std::true_type yes;$/;"	t	struct:simpla::is_indexable
z	core/geometry/obsolete/geometry_object.h	/^	Real x, y, z;$/;"	m	struct:simpla::geometry_object::Sphere
z	scripts/PostProcesse/particle_time_scripts.py	/^z=f1["\/record\/H"][:,:][:,req_time,2]$/;"	v
z0	core/geometry/obsolete/geometry_object.h	/^	Real x0, y0, z0;$/;"	m	struct:simpla::geometry_object::Cylinder
z0	core/geometry/obsolete/geometry_object.h	/^	Real x0, y0, z0;$/;"	m	struct:simpla::geometry_object::Ring
z1	core/geometry/obsolete/geometry_object.h	/^	Real x1, y1, z1;$/;"	m	struct:simpla::geometry_object::Cylinder
z1	core/geometry/obsolete/geometry_object.h	/^	Real x1, y1, z1;$/;"	m	struct:simpla::geometry_object::Ring
~AMR	core/manifold/obsoleted/amr_policy.h	/^AMR::~AMR()$/;"	f	class:simpla::manifold::policy::AMR
~AMR	core/manifold/obsoleted/amr_policy.h	/^AMR<TM>::~AMR() { }$/;"	f	class:simpla::manifold::policy::AMR
~AbstractTracker	core/gtl/design_pattern/signal.h	/^        virtual ~AbstractTracker()$/;"	f	struct:simpla::Signal::Slot::AbstractTracker
~AcceptorBase	core/gtl/design_pattern/visitor.h	/^    virtual ~AcceptorBase()$/;"	f	struct:simpla::AcceptorBase
~ArrayViewBase	core/gtl/array_view.h	/^    ~ArrayViewBase() { }$/;"	f	struct:simpla::gtl::ArrayViewBase
~AssignmentExpression	core/gtl/expression_template.h	/^    ~AssignmentExpression()$/;"	f	struct:simpla::AssignmentExpression
~Attribute	core/base/Attribute.h	/^    virtual ~Attribute() { }$/;"	f	class:simpla::base::Attribute
~AttributeEntity	core/base/Attribute.h	/^    virtual ~AttributeEntity() { };$/;"	f	class:simpla::base::AttributeEntity
~AttributeObject	core/base/Attribute.h	/^    virtual ~AttributeObject() { }$/;"	f	class:simpla::base::AttributeObject
~Base	core/gtl/any.h	/^    virtual ~Base() { }$/;"	f	struct:simpla::Base
~BiLinearInterpolation	core/numeric/interpolation.h	/^    ~BiLinearInterpolation()$/;"	f	class:simpla::BiLinearInterpolation
~BorisEngine	core/particle/pre_define/PICBoris.h	/^    ~BorisEngine() { }$/;"	f	struct:simpla::particle::engine::BorisEngine
~CartesianCoRect	core/manifold/mesh/CartesianCoRect.h	/^    virtual  ~CartesianCoRect() { }$/;"	f	struct:simpla::mesh::CartesianCoRect
~ConfigParser	core/gtl/utilities/config_parser.cpp	/^ConfigParser::~ConfigParser()$/;"	f	class:simpla::ConfigParser
~ContainerContainer	core/gtl/containers/container_container.h	/^	~ContainerContainer()$/;"	f	class:simpla::ContainerContainer
~ContainerSaveCache	core/gtl/containers/container_save_cache.h	/^	~ContainerSaveCache()$/;"	f	class:simpla::ContainerSaveCache
~ContextBase	core/task_flow/context_base.h	/^	virtual ~ContextBase()$/;"	f	class:simpla::ContextBase
~ContextBase	core/task_flow/task_flow_base.h	/^    virtual ~ContextBase() { };$/;"	f	class:simpla::task_flow::ContextBase
~CycleIterator	core/gtl/iterator/sp_iterator_cycle.h	/^	~CycleIterator()$/;"	f	struct:simpla::CycleIterator
~CylindricalCoRect	core/manifold/mesh/CylindricalCoRect.h	/^    virtual  ~CylindricalCoRect() { }$/;"	f	class:simpla::mesh::CylindricalCoRect
~DataSet	core/data_model/DataSet.h	/^    virtual ~DataSet() { }$/;"	f	struct:simpla::data_model::DataSet
~DataSpace	core/data_model/DataSpace.cpp	/^DataSpace::~DataSpace()$/;"	f	class:simpla::data_model::DataSpace
~DataType	core/data_model/DataType.cpp	/^DataType::~DataType()$/;"	f	class:simpla::data_model::DataType
~DenseContainer	core/gtl/containers/container_dense.h	/^	virtual ~DenseContainer()$/;"	f	class:simpla::DenseContainer
~DictObject	core/gtl/utilities/config_parser.h	/^        ~DictObject()$/;"	f	struct:simpla::ConfigParser::DictObject
~DirectMap	core/manifold/obsoleted/fiber_bundle.h	/^    ~DirectMap() { }$/;"	f	struct:simpla::manifold::DirectMap
~Distributed	core/parallel/obsoleted/distributed_unordered_set.h	/^	virtual ~Distributed() { };$/;"	f	struct:simpla::Distributed
~DistributedCounter	core/parallel/DistributedCounter.h	/^    virtual ~DistributedCounter() { }$/;"	f	struct:simpla::parallel::DistributedCounter
~DistributedObject	core/parallel/DistributedObject.cpp	/^DistributedObject::~DistributedObject()$/;"	f	class:simpla::parallel::DistributedObject
~DistributedUnorderedSetBase	core/parallel/trash/distributed_unordered_set.cpp	/^DistributedUnorderedSetBase::~DistributedUnorderedSetBase()$/;"	f	class:simpla::DistributedUnorderedSetBase
~EMFluid	core/phy_solver/em_fluid.h	/^    ~EMFluid() { }$/;"	f	class:simpla::phy_solver::EMFluid
~EMTokamak	example/em_tokamak/tokamak.cpp	/^    virtual ~EMTokamak() { }$/;"	f	struct:simpla::EMTokamak
~EmbeddedPolicy	core/manifold/obsoleted/embedded_policy.h	/^    virtual ~EmbeddedPolicy() { }$/;"	f	struct:simpla::manifold::policy::EmbeddedPolicy
~ExplicitEMContext	applications/contexts/explicit_em.h	/^ExplicitEMContext<TM>::~ExplicitEMContext()$/;"	f	class:simpla::ExplicitEMContext
~Expression	core/gtl/expression_template.h	/^    ~Expression()$/;"	f	struct:simpla::Expression
~FETLTest	core/field/test/field_diff_calculus_test.h	/^    virtual ~FETLTest()$/;"	f	class:FETLTest
~Factory	core/gtl/design_pattern/factory.h	/^	~Factory()$/;"	f	struct:simpla::Factory
~FiberBundle	core/manifold/obsoleted/fiber_bundle.h	/^    virtual  ~FiberBundle()$/;"	f	class:simpla::manifold::FiberBundle
~FiberBundle	example/pic/demo_pic.h	/^	~FiberBundle()$/;"	f	struct:simpla::FiberBundle
~Field	core/field/FieldDense.h	/^    virtual ~Field() { }$/;"	f	class:simpla::Field
~Field	core/field/FieldExpression.h	/^    ~Field()$/;"	f	struct:simpla::Field
~Field	core/field/FieldFunction.h	/^    ~Field() { }$/;"	f	class:simpla::Field
~Field	core/field/obsoleted/field_constant.h	/^	~Field()$/;"	f	class:simpla::Field
~Field	core/field/obsoleted/field_sparse.h	/^	~Field()$/;"	f	struct:simpla::Field
~Field	core/field/test/trash/field_continue.h	/^	~Field()$/;"	f	struct:simpla::Field
~FieldTest	core/field/test/field_dummy.cpp	/^	virtual ~FieldTest()$/;"	f	class:FieldTest
~FilterRange	core/gtl/iterator/sp_range_filter.h	/^	~FilterRange()$/;"	f	struct:simpla::FilterRange
~FiniteVolume	core/manifold/policy/FvmStructuredPolicy.h	/^    virtual ~FiniteVolume() { }$/;"	f	struct:simpla::manifold::policy::FiniteVolume
~Function	core/gtl/function.h	/^    ~Function()$/;"	f	class:simpla::Function
~FunctionCache	core/gtl/function_cache.h	/^	~FunctionCache()$/;"	f	struct:simpla::FunctionCache
~GEqdsk	core/model/GEqdsk.cpp	/^GEqdsk::~GEqdsk() { }$/;"	f	class:simpla::GEqdsk
~GeneralMap	core/manifold/mesh/GeneralMap.h	/^    virtual ~GeneralMap() { }$/;"	f	struct:simpla::mesh::GeneralMap
~GeoObject	core/geometry/GeoObject.h	/^    virtual ~GeoObject() { }$/;"	f	class:simpla::geometry::GeoObject
~GyroParticleWithCylindricalCoord	core/particle/pre_define/PICGyro.h	/^    virtual ~GyroParticleWithCylindricalCoord() { }$/;"	f	struct:simpla::particle::engine::GyroParticleWithCylindricalCoord
~HDF5Stream	core/io/HDF5Stream.cpp	/^HDF5Stream::~HDF5Stream() { close(); }$/;"	f	class:simpla::io::HDF5Stream
~IOPolicy	core/manifold/policy/IOPolicy.h	/^    virtual ~IOPolicy() { }$/;"	f	struct:simpla::manifold::policy::IOPolicy
~IOStream	core/io/IOStream.cpp	/^IOStream::~IOStream()$/;"	f	class:simpla::io::IOStream
~ImplicitFunction	core/geometry/implicit_function.h	/^	~ImplicitFunction()$/;"	f	class:simpla::ImplicitFunction
~ImplicitFunction	core/geometry/obsolete/geometry_object.h	/^	~ImplicitFunction()$/;"	f	struct:simpla::geometry_object::ImplicitFunction
~Interpolation	core/numeric/interpolation.h	/^    ~Interpolation()$/;"	f	class:simpla::Interpolation
~Iterator	core/gtl/iterator/sp_iterator_index_base.h	/^	virtual ~Iterator()$/;"	f	class:simpla::Iterator
~Iterator	core/gtl/iterator/sp_iterator_mapped.h	/^	~Iterator()$/;"	f	struct:simpla::Iterator
~IteratorSequence	core/gtl/iterator/iterator_sequence.h	/^	~IteratorSequence()$/;"	f	class:simpla::IteratorSequence
~KineticParticle	core/particle/obsolete/kinetic_particle.h	/^KineticParticle<Engine, TDomain>::~KineticParticle()$/;"	f	class:KineticParticle
~LinearInterpolator	core/manifold/policy/LinearInterpolatorPolicy.h	/^    virtual ~LinearInterpolator() { }$/;"	f	struct:simpla::manifold::policy::LinearInterpolator
~LinearMap	core/manifold/mesh/LinearMap.h	/^    virtual   ~LinearMap() { }$/;"	f	struct:simpla::mesh::LinearMap
~Logger	core/gtl/utilities/log.cpp	/^Logger::~Logger()$/;"	f	class:simpla::logger::Logger
~LoggerStreams	core/gtl/utilities/log.cpp	/^    ~LoggerStreams()$/;"	f	struct:simpla::logger::LoggerStreams
~LuaObject	core/gtl/utilities/lua_object.cpp	/^LuaObject::~LuaObject()$/;"	f	class:simpla::lua::LuaObject
~LuaState	core/gtl/utilities/lua_object.h	/^        ~LuaState() { }$/;"	f	struct:simpla::lua::LuaObject::LuaState
~MPIComm	core/parallel/MPIComm.cpp	/^MPIComm::~MPIComm()$/;"	f	class:simpla::parallel::MPIComm
~MPIDataType	core/parallel/MPIDataType.cpp	/^MPIDataType::~MPIDataType()$/;"	f	class:simpla::MPIDataType
~Manifold	core/manifold/Manifold.h	/^    virtual ~Manifold() { }$/;"	f	class:simpla::Manifold
~MemoryPool	core/gtl/utilities/memory_pool.cpp	/^MemoryPool::~MemoryPool()$/;"	f	class:simpla::MemoryPool
~Mesh	core/manifold/mesh/CoRectMesh.h	/^    virtual  ~Mesh() { }$/;"	f	struct:simpla::mesh::Mesh
~Mesh	core/manifold/mesh/RectMesh.h	/^    virtual  ~Mesh() { }$/;"	f	struct:simpla::mesh::Mesh
~MeshBlock	core/manifold/mesh/MeshBlock.cpp	/^MeshBlock::~MeshBlock() { }$/;"	f	class:simpla::mesh::MeshBlock
~MeshPatch	core/manifold/obsoleted/patch/mesh_patch.h	/^MeshPatch<TM>::~MeshPatch() { }$/;"	f	class:simpla::mesh::MeshPatch
~Model	core/model/obsoleted/model.h	/^    ~Model()$/;"	f	class:simpla::Model
~MultiDimesionInterpolation	core/numeric/interpolation.h	/^    virtual ~MultiDimesionInterpolation()$/;"	f	class:simpla::MultiDimesionInterpolation
~Object	core/base/Object.cpp	/^Object::~Object() { }$/;"	f	class:simpla::base::Object
~Observable	core/gtl/design_pattern/observer.h	/^	virtual ~Observable()$/;"	f	struct:simpla::Observable
~Observer	core/gtl/design_pattern/observer.h	/^	virtual ~Observer()$/;"	f	struct:simpla::Observer
~PICDeltaF	applications/fokker_planck/lhw.cpp	/^	~PICDeltaF()$/;"	f	struct:PICDeltaF
~PICEngineDeltaF	applications/particle_solver/pic_engine_deltaf2.h	/^	~PICEngineDeltaF()$/;"	f	struct:simpla::PICEngineDeltaF
~PICEngineFullF	applications/particle_solver/pic_engine_fullf.h	/^	~PICEngineFullF()$/;"	f	class:simpla::PICEngineFullF
~PICEngineGGauge	applications/particle_solver/pic_engine_ggauge.h	/^	~PICEngineGGauge()$/;"	f	class:simpla::PICEngineGGauge
~PICEngineImplicit	applications/particle_solver/pic_engine_implicit.h	/^	~PICEngineImplicit()$/;"	f	struct:simpla::PICEngineImplicit
~PML	applications/field_solver/pml.h	/^PML<TM>::~PML()$/;"	f	class:simpla::PML
~ParallelPolicy	core/manifold/policy/ParallelPolicy.h	/^    virtual ~ParallelPolicy() { }$/;"	f	struct:simpla::manifold::policy::ParallelPolicy
~ParserConfigure	core/gtl/utilities/parser_configure.h	/^ParserConfigure<TDict>::~ParserConfigure()$/;"	f	class:simpla::ParserConfigure
~Particle	applications/particle_solver/fluid_cold_engine.h	/^Particle<TM, ColdFluid, PolicyFluidParticle>::~Particle()$/;"	f	class:simpla::Particle
~Particle	core/particle/Particle.h	/^    ~Particle() { }$/;"	f	struct:simpla::particle::Particle
~ParticleBase	core/particle/Particle.h	/^    virtual ~ParticleBase() { }$/;"	f	struct:simpla::particle::ParticleBase
~ParticleContainer	core/particle/ParticleContainer.h	/^ParticleContainer<P, M>::~ParticleContainer() { }$/;"	f	class:simpla::particle::ParticleContainer
~ParticleEngine	applications/particle_solver/pic_engine_deltaf.h	/^	~ParticleEngine()$/;"	f	struct:simpla::ParticleEngine
~ParticleGenerator	core/particle/ParticleGenerator.h	/^    virtual  ~ParticleGenerator() { }$/;"	f	struct:simpla::particle::ParticleGenerator
~ParticleGeneratorPerCell	core/particle/ParticleGenerator.h	/^    ~ParticleGeneratorPerCell() { }$/;"	f	class:simpla::particle::ParticleGeneratorPerCell
~ParticleProxy	core/particle/ParticleProxy.h	/^    virtual  ~ParticleProxy() { }$/;"	f	class:simpla::particle::ParticleProxy
~ParticleProxyBase	core/particle/ParticleProxy.h	/^    virtual ~ParticleProxyBase() { }$/;"	f	struct:simpla::particle::ParticleProxyBase
~Patch	core/base/Patch.h	/^    virtual ~Patch() { }$/;"	f	class:simpla::base::Patch
~PhysicalConstants	core/physics/PhysicalConstants.cpp	/^PhysicalConstants::~PhysicalConstants()$/;"	f	class:simpla::PhysicalConstants
~Polygon	core/geometry/polygon.h	/^    ~Polygon() { }$/;"	f	struct:simpla::geometry::Polygon
~ProbeDemo	example/probe_particle/demo_probe_particle.h	/^	~ProbeDemo()$/;"	f	struct:simpla::ProbeDemo
~ProbeParticle	core/particle/obsolete/probe_particle.h	/^ProbeParticle<Engine>::~ProbeParticle()$/;"	f	class:simpla::ProbeParticle
~Properties	core/gtl/Properties.h	/^    ~Properties() { }$/;"	f	class:simpla::Properties
~RandomGenerator	core/parallel/ParallelRandomGenerator.h	/^    ~RandomGenerator() { }$/;"	f	struct:simpla::parallel::DistributedCounter
~Range	core/gtl/iterator/range.h	/^    ~Range() { }$/;"	f	class:simpla::Range
~SimpleParticleEngine	core/particle/obsolete/simple_particle.h	/^	~SimpleParticleEngine()$/;"	f	struct:simpla::SimpleParticleEngine
~SingletonHolder	core/gtl/design_pattern/singleton_holder.h	/^	~SingletonHolder()$/;"	f	class:simpla::SingletonHolder
~SpApp	core/task_flow/application.h	/^    virtual ~SpApp()$/;"	f	struct:simpla::SpApp
~SpHashContainer	core/gtl/containers/sp_hash_container.h	/^	~SpHashContainer()$/;"	f	struct:simpla::SpHashContainer
~SparseContainer	core/gtl/containers/container_sparse.h	/^    ~SparseContainer()$/;"	f	class:simpla::SparseContainer
~SquareMap	core/manifold/mesh/GeneralMap.h	/^    virtual ~SquareMap() { }$/;"	f	struct:simpla::mesh::SquareMap
~StoragePolicy	core/manifold/policy/StoragePolicy.h	/^    virtual ~StoragePolicy() { }$/;"	f	struct:simpla::manifold::policy::StoragePolicy
~Surface	core/geometry/obsolete/surface.h	/^	~Surface()$/;"	f	class:simpla::Surface
~Task	core/task_flow/task.h	/^    virtual ~Task() { };$/;"	f	class:simpla::task_flow::Task
~TestFETL	core/field/test/trash/fetl_test3.h	/^	virtual ~TestFETL()$/;"	f	class:TestFETL
~TimeIntegrator	core/manifold/obsoleted/time_integrator_policy.h	/^    virtual ~TimeIntegrator() { }$/;"	f	struct:simpla::manifold::policy::TimeIntegrator
~Tracker	core/gtl/design_pattern/signal.h	/^        ~Tracker()$/;"	f	struct:simpla::Signal::Slot::Tracker
~TransformIterator	core/gtl/iterator/sp_iterator_shared_container.h	/^	~TransformIterator()$/;"	f	class:simpla::TransformIterator
~TransformRevolve	core/model/obsoleted/trans_revolve.h	/^    ~TransformRevolve() { };$/;"	f	struct:simpla::TransformRevolve
~UnorderedSet	core/gtl/containers/UnorderedSet.h	/^UnorderedSet<ValueType, Key>::~UnorderedSet() { }$/;"	f	class:simpla::gtl::UnorderedSet
~UnorderedSet	core/gtl/containers/unordered_set.h	/^    ~UnorderedSet()$/;"	f	class:simpla::UnorderedSet
~UseCase	core/task_flow/use_case.h	/^    virtual ~UseCase()$/;"	f	class:simpla::use_case::UseCase
~Visitor	core/gtl/design_pattern/visitor.h	/^    ~Visitor()$/;"	f	struct:simpla::Visitor
~VisitorBase	core/gtl/design_pattern/visitor.h	/^    virtual ~VisitorBase() { }$/;"	f	struct:simpla::VisitorBase
~WriteBuffer	core/io/WriteBuffer.cpp	/^WriteBuffer::~WriteBuffer() { flush(); }$/;"	f	class:simpla::io::WriteBuffer
~WriteBufferProxy	core/io/WriteBuffer.h	/^    virtual ~ WriteBufferProxy() { }$/;"	f	class:simpla::io::WriteBufferProxy
~XDMFStream	core/io/XDMFStream.cpp	/^XDMFStream::~XDMFStream()$/;"	f	class:simpla::io::XDMFStream
~accessor	core/gtl/utilities/lua_object.h	/^            ~accessor() { m_l_->m_mutex_.unlock(); }$/;"	f	struct:simpla::lua::LuaObject::LuaState::accessor
~block_iterator	core/gtl/iterator/block_iterator.h	/^    ~block_iterator() { }$/;"	f	struct:simpla::block_iterator
~const_accessor	core/gtl/utilities/lua_object.h	/^            ~const_accessor() { m_l_->m_mutex_.unlock(); }$/;"	f	struct:simpla::lua::LuaObject::LuaState::const_accessor
~deleter_s	core/gtl/utilities/memory_pool.h	/^        ~deleter_s()$/;"	f	struct:simpla::MemoryPool::deleter_s
~enable_create_from_this	core/gtl/enable_create_from_this.h	/^	virtual ~enable_create_from_this()$/;"	f	struct:simpla::enable_create_from_this
~enable_tracking	core/particle/ParticleTracker.h	/^    ~enable_tracking() { }$/;"	f	class:simpla::particle::enable_tracking
~indirect_iterator	core/gtl/iterator/indirect_iterator.h	/^	~indirect_iterator()$/;"	f	struct:simpla::indirect_iterator
~input_iterator	core/parallel/ParallelRandomGenerator.h	/^    ~input_iterator() { }$/;"	f	struct:simpla::parallel::DistributedCounter::input_iterator
~input_iterator	core/particle/ParticleGenerator.h	/^        virtual ~input_iterator() { }$/;"	f	struct:simpla::particle::ParticleGenerator::input_iterator
~iterator	core/gtl/array_view.h	/^    ~iterator() { }$/;"	f	struct:simpla::gtl::ArrayView::iterator
~iterator	core/gtl/containers/iterator_proxy.h	/^	virtual ~iterator()$/;"	f	struct:simpla::iterator_proxy
~iterator	core/gtl/iterator/sp_ntuple_range.h	/^    ~iterator()$/;"	f	struct:simpla::sp_nTuple_range::iterator
~iterator	core/gtl/utilities/lua_object.cpp	/^LuaObject::iterator::~iterator()$/;"	f	class:simpla::lua::LuaObject::iterator
~iterator	core/manifold/mesh/MeshIds.h	/^        ~iterator() { }$/;"	f	struct:simpla::mesh::MeshEntityIdCoder::iterator
~iterator	core/parallel/obsoleted/blocked_range.h	/^	~iterator()$/;"	f	struct:simpla::iterator
~iterator_cycle	core/gtl/iterator/iterator_cycle.h	/^	~iterator_cycle()$/;"	f	struct:simpla::iterator_cycle
~lua_s	core/gtl/utilities/lua_object.h	/^            ~lua_s() { lua_close(m_state_); }$/;"	f	struct:simpla::lua::LuaObject::LuaState::lua_s
~multi_normal_distribution	core/numeric/multi_normal_distribution.h	/^	~multi_normal_distribution()$/;"	f	class:simpla::multi_normal_distribution
~ndArray	core/gtl/containers/sp_ndarray.h	/^	~ndArray()$/;"	f	class:simpla::ndArray
~particle_hasher	core/particle/obsolete/kinetic_particle.h	/^    ~particle_hasher()$/;"	f	struct:simpla::_impl::particle_hasher
~pimpl_s	core/data_model/DataType.cpp	/^DataType::pimpl_s::~pimpl_s()$/;"	f	class:simpla::data_model::DataType::pimpl_s
~pimpl_s	core/io/HDF5Stream.cpp	/^HDF5Stream::pimpl_s::~pimpl_s()$/;"	f	class:simpla::io::HDF5Stream::pimpl_s
~pimpl_s	core/parallel/DistributedObject.cpp	/^    ~pimpl_s() { }$/;"	f	struct:simpla::parallel::DistributedObject::pimpl_s
~pimpl_s	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^vtkAMRSimPlaReader::pimpl_s::~pimpl_s()$/;"	f	class:vtkAMRSimPlaReader::pimpl_s
~range	core/parallel/obsoleted/blocked_range.h	/^	~range()$/;"	f	struct:simpla::range
~range_type	core/manifold/mesh/MeshIds.h	/^        ~range_type() { }$/;"	f	struct:simpla::mesh::MeshEntityIdCoder::range_type
~rectangle_distribution	core/numeric/rectangle_distribution.h	/^    ~rectangle_distribution()$/;"	f	class:simpla::rectangle_distribution
~simplex_distribution	core/numeric/simplex_distribution.h	/^	~simplex_distribution()$/;"	f	class:simpla::simplex_distribution
~sobol_engine	core/numeric/sobol_engine.h	/^	~sobol_engine()$/;"	f	class:simpla::sobol_engine
~sp_fliter_iterator	core/gtl/iterator/sp_iterator_filter.h	/^	~sp_fliter_iterator()$/;"	f	struct:simpla::sp_fliter_iterator
~sp_indirect_iterator	core/gtl/iterator/sp_indirect_iterator.h	/^    ~sp_indirect_iterator()$/;"	f	struct:simpla::sp_indirect_iterator
~sp_indirect_range	core/gtl/iterator/sp_indirect_iterator.h	/^    ~sp_indirect_range()$/;"	f	struct:simpla::sp_indirect_range
~vtkAMRSimPlaParticlesReader	plugins/vtk_reader/vtkAMRSimPlaParticlesReader.cpp	/^vtkAMRSimPlaParticlesReader::~vtkAMRSimPlaParticlesReader()$/;"	f	class:vtkAMRSimPlaParticlesReader
~vtkAMRSimPlaReader	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^vtkAMRSimPlaReader::~vtkAMRSimPlaReader()$/;"	f	class:vtkAMRSimPlaReader
~vtkAMRSimPlaReaderBlock	plugins/vtk_reader/vtkAMRSimPlaReader.cpp	/^    ~vtkAMRSimPlaReaderBlock() { this->Init(); }$/;"	f	class:vtkAMRSimPlaReaderBlock
